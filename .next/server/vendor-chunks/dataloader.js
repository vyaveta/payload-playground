"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dataloader";
exports.ids = ["vendor-chunks/dataloader"];
exports.modules = {

/***/ "(ssr)/./node_modules/dataloader/index.js":
/*!******************************************!*\
  !*** ./node_modules/dataloader/index.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n/**\n * Copyright (c) 2019-present, GraphQL Foundation\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */ // A Function, which when given an Array of keys, returns a Promise of an Array\n// of values or Errors.\n// Optionally turn off batching or caching or provide a cache key function or a\n// custom cache instance.\n// If a custom cache is provided, it must be of this type (a subset of ES6 Map).\n/**\n * A `DataLoader` creates a public API for loading data from a particular\n * data back-end with unique keys such as the `id` column of a SQL table or\n * document name in a MongoDB database, given a batch loading function.\n *\n * Each `DataLoader` instance contains a unique memoized cache. Use caution when\n * used in long-lived applications or those which serve many users with\n * different access permissions and consider creating a new instance per\n * web request.\n */ var DataLoader = /*#__PURE__*/ function() {\n    function DataLoader(batchLoadFn, options) {\n        if (typeof batchLoadFn !== \"function\") {\n            throw new TypeError(\"DataLoader must be constructed with a function which accepts \" + (\"Array<key> and returns Promise<Array<value>>, but got: \" + batchLoadFn + \".\"));\n        }\n        this._batchLoadFn = batchLoadFn;\n        this._maxBatchSize = getValidMaxBatchSize(options);\n        this._batchScheduleFn = getValidBatchScheduleFn(options);\n        this._cacheKeyFn = getValidCacheKeyFn(options);\n        this._cacheMap = getValidCacheMap(options);\n        this._batch = null;\n        this.name = getValidName(options);\n    } // Private\n    var _proto = DataLoader.prototype;\n    /**\n   * Loads a key, returning a `Promise` for the value represented by that key.\n   */ _proto.load = function load(key) {\n        if (key === null || key === undefined) {\n            throw new TypeError(\"The loader.load() function must be called with a value, \" + (\"but got: \" + String(key) + \".\"));\n        }\n        var batch = getCurrentBatch(this);\n        var cacheMap = this._cacheMap;\n        var cacheKey = this._cacheKeyFn(key); // If caching and there is a cache-hit, return cached Promise.\n        if (cacheMap) {\n            var cachedPromise = cacheMap.get(cacheKey);\n            if (cachedPromise) {\n                var cacheHits = batch.cacheHits || (batch.cacheHits = []);\n                return new Promise(function(resolve) {\n                    cacheHits.push(function() {\n                        resolve(cachedPromise);\n                    });\n                });\n            }\n        } // Otherwise, produce a new Promise for this key, and enqueue it to be\n        // dispatched along with the current batch.\n        batch.keys.push(key);\n        var promise = new Promise(function(resolve, reject) {\n            batch.callbacks.push({\n                resolve: resolve,\n                reject: reject\n            });\n        }); // If caching, cache this promise.\n        if (cacheMap) {\n            cacheMap.set(cacheKey, promise);\n        }\n        return promise;\n    } /**\n   * Loads multiple keys, promising an array of values:\n   *\n   *     var [ a, b ] = await myLoader.loadMany([ 'a', 'b' ]);\n   *\n   * This is similar to the more verbose:\n   *\n   *     var [ a, b ] = await Promise.all([\n   *       myLoader.load('a'),\n   *       myLoader.load('b')\n   *     ]);\n   *\n   * However it is different in the case where any load fails. Where\n   * Promise.all() would reject, loadMany() always resolves, however each result\n   * is either a value or an Error instance.\n   *\n   *     var [ a, b, c ] = await myLoader.loadMany([ 'a', 'b', 'badkey' ]);\n   *     // c instanceof Error\n   *\n   */ ;\n    _proto.loadMany = function loadMany(keys) {\n        if (!isArrayLike(keys)) {\n            throw new TypeError(\"The loader.loadMany() function must be called with Array<key> \" + (\"but got: \" + keys + \".\"));\n        } // Support ArrayLike by using only minimal property access\n        var loadPromises = [];\n        for(var i = 0; i < keys.length; i++){\n            loadPromises.push(this.load(keys[i])[\"catch\"](function(error) {\n                return error;\n            }));\n        }\n        return Promise.all(loadPromises);\n    } /**\n   * Clears the value at `key` from the cache, if it exists. Returns itself for\n   * method chaining.\n   */ ;\n    _proto.clear = function clear(key) {\n        var cacheMap = this._cacheMap;\n        if (cacheMap) {\n            var cacheKey = this._cacheKeyFn(key);\n            cacheMap[\"delete\"](cacheKey);\n        }\n        return this;\n    } /**\n   * Clears the entire cache. To be used when some event results in unknown\n   * invalidations across this particular `DataLoader`. Returns itself for\n   * method chaining.\n   */ ;\n    _proto.clearAll = function clearAll() {\n        var cacheMap = this._cacheMap;\n        if (cacheMap) {\n            cacheMap.clear();\n        }\n        return this;\n    } /**\n   * Adds the provided key and value to the cache. If the key already\n   * exists, no change is made. Returns itself for method chaining.\n   *\n   * To prime the cache with an error at a key, provide an Error instance.\n   */ ;\n    _proto.prime = function prime(key, value) {\n        var cacheMap = this._cacheMap;\n        if (cacheMap) {\n            var cacheKey = this._cacheKeyFn(key); // Only add the key if it does not already exist.\n            if (cacheMap.get(cacheKey) === undefined) {\n                // Cache a rejected promise if the value is an Error, in order to match\n                // the behavior of load(key).\n                var promise;\n                if (value instanceof Error) {\n                    promise = Promise.reject(value); // Since this is a case where an Error is intentionally being primed\n                    // for a given key, we want to disable unhandled promise rejection.\n                    promise[\"catch\"](function() {});\n                } else {\n                    promise = Promise.resolve(value);\n                }\n                cacheMap.set(cacheKey, promise);\n            }\n        }\n        return this;\n    } /**\n   * The name given to this `DataLoader` instance. Useful for APM tools.\n   *\n   * Is `null` if not set in the constructor.\n   */ ;\n    return DataLoader;\n}(); // Private: Enqueue a Job to be executed after all \"PromiseJobs\" Jobs.\n//\n// ES6 JavaScript uses the concepts Job and JobQueue to schedule work to occur\n// after the current execution context has completed:\n// http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n//\n// Node.js uses the `process.nextTick` mechanism to implement the concept of a\n// Job, maintaining a global FIFO JobQueue for all Jobs, which is flushed after\n// the current call stack ends.\n//\n// When calling `then` on a Promise, it enqueues a Job on a specific\n// \"PromiseJobs\" JobQueue which is flushed in Node as a single Job on the\n// global JobQueue.\n//\n// DataLoader batches all loads which occur in a single frame of execution, but\n// should include in the batch all loads which occur during the flushing of the\n// \"PromiseJobs\" JobQueue after that same execution frame.\n//\n// In order to avoid the DataLoader dispatch Job occuring before \"PromiseJobs\",\n// A Promise Job is created with the sole purpose of enqueuing a global Job,\n// ensuring that it always occurs after \"PromiseJobs\" ends.\n//\n// Node.js's job queue is unique. Browsers do not have an equivalent mechanism\n// for enqueuing a job to be performed after promise microtasks and before the\n// next macrotask. For browser environments, a macrotask is used (via\n// setImmediate or setTimeout) at a potential performance penalty.\nvar enqueuePostPromiseJob = typeof process === \"object\" && typeof process.nextTick === \"function\" ? function(fn) {\n    if (!resolvedPromise) {\n        resolvedPromise = Promise.resolve();\n    }\n    resolvedPromise.then(function() {\n        process.nextTick(fn);\n    });\n} : typeof setImmediate === \"function\" ? function(fn) {\n    setImmediate(fn);\n} : function(fn) {\n    setTimeout(fn);\n}; // Private: cached resolved Promise instance\nvar resolvedPromise; // Private: Describes a batch of requests\n// Private: Either returns the current batch, or creates and schedules a\n// dispatch of a new batch for the given loader.\nfunction getCurrentBatch(loader) {\n    // If there is an existing batch which has not yet dispatched and is within\n    // the limit of the batch size, then return it.\n    var existingBatch = loader._batch;\n    if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize) {\n        return existingBatch;\n    } // Otherwise, create a new batch for this loader.\n    var newBatch = {\n        hasDispatched: false,\n        keys: [],\n        callbacks: []\n    }; // Store it on the loader so it may be reused.\n    loader._batch = newBatch; // Then schedule a task to dispatch this batch of requests.\n    loader._batchScheduleFn(function() {\n        dispatchBatch(loader, newBatch);\n    });\n    return newBatch;\n}\nfunction dispatchBatch(loader, batch) {\n    // Mark this batch as having been dispatched.\n    batch.hasDispatched = true; // If there's nothing to load, resolve any cache hits and return early.\n    if (batch.keys.length === 0) {\n        resolveCacheHits(batch);\n        return;\n    } // Call the provided batchLoadFn for this loader with the batch's keys and\n    // with the loader as the `this` context.\n    var batchPromise;\n    try {\n        batchPromise = loader._batchLoadFn(batch.keys);\n    } catch (e) {\n        return failedDispatch(loader, batch, new TypeError(\"DataLoader must be constructed with a function which accepts \" + \"Array<key> and returns Promise<Array<value>>, but the function \" + (\"errored synchronously: \" + String(e) + \".\")));\n    } // Assert the expected response from batchLoadFn\n    if (!batchPromise || typeof batchPromise.then !== \"function\") {\n        return failedDispatch(loader, batch, new TypeError(\"DataLoader must be constructed with a function which accepts \" + \"Array<key> and returns Promise<Array<value>>, but the function did \" + (\"not return a Promise: \" + String(batchPromise) + \".\")));\n    } // Await the resolution of the call to batchLoadFn.\n    batchPromise.then(function(values) {\n        // Assert the expected resolution from batchLoadFn.\n        if (!isArrayLike(values)) {\n            throw new TypeError(\"DataLoader must be constructed with a function which accepts \" + \"Array<key> and returns Promise<Array<value>>, but the function did \" + (\"not return a Promise of an Array: \" + String(values) + \".\"));\n        }\n        if (values.length !== batch.keys.length) {\n            throw new TypeError(\"DataLoader must be constructed with a function which accepts \" + \"Array<key> and returns Promise<Array<value>>, but the function did \" + \"not return a Promise of an Array of the same length as the Array \" + \"of keys.\" + (\"\\n\\nKeys:\\n\" + String(batch.keys)) + (\"\\n\\nValues:\\n\" + String(values)));\n        } // Resolve all cache hits in the same micro-task as freshly loaded values.\n        resolveCacheHits(batch); // Step through values, resolving or rejecting each Promise in the batch.\n        for(var i = 0; i < batch.callbacks.length; i++){\n            var value = values[i];\n            if (value instanceof Error) {\n                batch.callbacks[i].reject(value);\n            } else {\n                batch.callbacks[i].resolve(value);\n            }\n        }\n    })[\"catch\"](function(error) {\n        failedDispatch(loader, batch, error);\n    });\n} // Private: do not cache individual loads if the entire batch dispatch fails,\n// but still reject each request so they do not hang.\nfunction failedDispatch(loader, batch, error) {\n    // Cache hits are resolved, even though the batch failed.\n    resolveCacheHits(batch);\n    for(var i = 0; i < batch.keys.length; i++){\n        loader.clear(batch.keys[i]);\n        batch.callbacks[i].reject(error);\n    }\n} // Private: Resolves the Promises for any cache hits in this batch.\nfunction resolveCacheHits(batch) {\n    if (batch.cacheHits) {\n        for(var i = 0; i < batch.cacheHits.length; i++){\n            batch.cacheHits[i]();\n        }\n    }\n} // Private: given the DataLoader's options, produce a valid max batch size.\nfunction getValidMaxBatchSize(options) {\n    var shouldBatch = !options || options.batch !== false;\n    if (!shouldBatch) {\n        return 1;\n    }\n    var maxBatchSize = options && options.maxBatchSize;\n    if (maxBatchSize === undefined) {\n        return Infinity;\n    }\n    if (typeof maxBatchSize !== \"number\" || maxBatchSize < 1) {\n        throw new TypeError(\"maxBatchSize must be a positive number: \" + maxBatchSize);\n    }\n    return maxBatchSize;\n} // Private\nfunction getValidBatchScheduleFn(options) {\n    var batchScheduleFn = options && options.batchScheduleFn;\n    if (batchScheduleFn === undefined) {\n        return enqueuePostPromiseJob;\n    }\n    if (typeof batchScheduleFn !== \"function\") {\n        throw new TypeError(\"batchScheduleFn must be a function: \" + batchScheduleFn);\n    }\n    return batchScheduleFn;\n} // Private: given the DataLoader's options, produce a cache key function.\nfunction getValidCacheKeyFn(options) {\n    var cacheKeyFn = options && options.cacheKeyFn;\n    if (cacheKeyFn === undefined) {\n        return function(key) {\n            return key;\n        };\n    }\n    if (typeof cacheKeyFn !== \"function\") {\n        throw new TypeError(\"cacheKeyFn must be a function: \" + cacheKeyFn);\n    }\n    return cacheKeyFn;\n} // Private: given the DataLoader's options, produce a CacheMap to be used.\nfunction getValidCacheMap(options) {\n    var shouldCache = !options || options.cache !== false;\n    if (!shouldCache) {\n        return null;\n    }\n    var cacheMap = options && options.cacheMap;\n    if (cacheMap === undefined) {\n        return new Map();\n    }\n    if (cacheMap !== null) {\n        var cacheFunctions = [\n            \"get\",\n            \"set\",\n            \"delete\",\n            \"clear\"\n        ];\n        var missingFunctions = cacheFunctions.filter(function(fnName) {\n            return cacheMap && typeof cacheMap[fnName] !== \"function\";\n        });\n        if (missingFunctions.length !== 0) {\n            throw new TypeError(\"Custom cacheMap missing methods: \" + missingFunctions.join(\", \"));\n        }\n    }\n    return cacheMap;\n}\nfunction getValidName(options) {\n    if (options && options.name) {\n        return options.name;\n    }\n    return null;\n} // Private\nfunction isArrayLike(x) {\n    return typeof x === \"object\" && x !== null && typeof x.length === \"number\" && (x.length === 0 || x.length > 0 && Object.prototype.hasOwnProperty.call(x, x.length - 1));\n}\nmodule.exports = DataLoader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZGF0YWxvYWRlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Ozs7O0NBT0MsR0FDRCwrRUFBK0U7QUFDL0UsdUJBQXVCO0FBQ3ZCLCtFQUErRTtBQUMvRSx5QkFBeUI7QUFDekIsZ0ZBQWdGO0FBRWhGOzs7Ozs7Ozs7Q0FTQyxHQUNELElBQUlBLGFBQ0osV0FBVyxHQUNYO0lBQ0UsU0FBU0EsV0FBV0MsV0FBVyxFQUFFQyxPQUFPO1FBQ3RDLElBQUksT0FBT0QsZ0JBQWdCLFlBQVk7WUFDckMsTUFBTSxJQUFJRSxVQUFVLGtFQUFtRSw2REFBNERGLGNBQWMsR0FBRTtRQUNySztRQUVBLElBQUksQ0FBQ0csWUFBWSxHQUFHSDtRQUNwQixJQUFJLENBQUNJLGFBQWEsR0FBR0MscUJBQXFCSjtRQUMxQyxJQUFJLENBQUNLLGdCQUFnQixHQUFHQyx3QkFBd0JOO1FBQ2hELElBQUksQ0FBQ08sV0FBVyxHQUFHQyxtQkFBbUJSO1FBQ3RDLElBQUksQ0FBQ1MsU0FBUyxHQUFHQyxpQkFBaUJWO1FBQ2xDLElBQUksQ0FBQ1csTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdDLGFBQWFiO0lBQzNCLEVBQUUsVUFBVTtJQUdaLElBQUljLFNBQVNoQixXQUFXaUIsU0FBUztJQUVqQzs7R0FFQyxHQUNERCxPQUFPRSxJQUFJLEdBQUcsU0FBU0EsS0FBS0MsR0FBRztRQUM3QixJQUFJQSxRQUFRLFFBQVFBLFFBQVFDLFdBQVc7WUFDckMsTUFBTSxJQUFJakIsVUFBVSw2REFBOEQsZUFBY2tCLE9BQU9GLE9BQU8sR0FBRTtRQUNsSDtRQUVBLElBQUlHLFFBQVFDLGdCQUFnQixJQUFJO1FBQ2hDLElBQUlDLFdBQVcsSUFBSSxDQUFDYixTQUFTO1FBRTdCLElBQUljLFdBQVcsSUFBSSxDQUFDaEIsV0FBVyxDQUFDVSxNQUFNLDhEQUE4RDtRQUdwRyxJQUFJSyxVQUFVO1lBQ1osSUFBSUUsZ0JBQWdCRixTQUFTRyxH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LGVBQWVFLE1BQU0sQ0FBQyxTQUFVQyxNQUFNO1lBQzNELE9BQU90RCxZQUFZLE9BQU9BLFFBQVEsQ0FBQ3NELE9BQU8sS0FBSztRQUNqRDtRQUVBLElBQUlGLGlCQUFpQm5DLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLE1BQU0sSUFBSXRDLFVBQVUsc0NBQXNDeUUsaUJBQWlCRyxJQUFJLENBQUM7UUFDbEY7SUFDRjtJQUVBLE9BQU92RDtBQUNUO0FBRUEsU0FBU1QsYUFBYWIsT0FBTztJQUMzQixJQUFJQSxXQUFXQSxRQUFRWSxJQUFJLEVBQUU7UUFDM0IsT0FBT1osUUFBUVksSUFBSTtJQUNyQjtJQUVBLE9BQU87QUFDVCxFQUFFLFVBQVU7QUFHWixTQUFTd0IsWUFBWTBDLENBQUM7SUFDcEIsT0FBTyxPQUFPQSxNQUFNLFlBQVlBLE1BQU0sUUFBUSxPQUFPQSxFQUFFdkMsTUFBTSxLQUFLLFlBQWF1QyxDQUFBQSxFQUFFdkMsTUFBTSxLQUFLLEtBQUt1QyxFQUFFdkMsTUFBTSxHQUFHLEtBQUt3QyxPQUFPaEUsU0FBUyxDQUFDaUUsY0FBYyxDQUFDQyxJQUFJLENBQUNILEdBQUdBLEVBQUV2QyxNQUFNLEdBQUcsRUFBQztBQUN2SztBQUVBMkMsT0FBT0MsT0FBTyxHQUFHckYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXlsb2FkLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvZGF0YWxvYWRlci9pbmRleC5qcz85MTcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxOS1wcmVzZW50LCBHcmFwaFFMIEZvdW5kYXRpb25cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuLy8gQSBGdW5jdGlvbiwgd2hpY2ggd2hlbiBnaXZlbiBhbiBBcnJheSBvZiBrZXlzLCByZXR1cm5zIGEgUHJvbWlzZSBvZiBhbiBBcnJheVxuLy8gb2YgdmFsdWVzIG9yIEVycm9ycy5cbi8vIE9wdGlvbmFsbHkgdHVybiBvZmYgYmF0Y2hpbmcgb3IgY2FjaGluZyBvciBwcm92aWRlIGEgY2FjaGUga2V5IGZ1bmN0aW9uIG9yIGFcbi8vIGN1c3RvbSBjYWNoZSBpbnN0YW5jZS5cbi8vIElmIGEgY3VzdG9tIGNhY2hlIGlzIHByb3ZpZGVkLCBpdCBtdXN0IGJlIG9mIHRoaXMgdHlwZSAoYSBzdWJzZXQgb2YgRVM2IE1hcCkuXG5cbi8qKlxuICogQSBgRGF0YUxvYWRlcmAgY3JlYXRlcyBhIHB1YmxpYyBBUEkgZm9yIGxvYWRpbmcgZGF0YSBmcm9tIGEgcGFydGljdWxhclxuICogZGF0YSBiYWNrLWVuZCB3aXRoIHVuaXF1ZSBrZXlzIHN1Y2ggYXMgdGhlIGBpZGAgY29sdW1uIG9mIGEgU1FMIHRhYmxlIG9yXG4gKiBkb2N1bWVudCBuYW1lIGluIGEgTW9uZ29EQiBkYXRhYmFzZSwgZ2l2ZW4gYSBiYXRjaCBsb2FkaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVhY2ggYERhdGFMb2FkZXJgIGluc3RhbmNlIGNvbnRhaW5zIGEgdW5pcXVlIG1lbW9pemVkIGNhY2hlLiBVc2UgY2F1dGlvbiB3aGVuXG4gKiB1c2VkIGluIGxvbmctbGl2ZWQgYXBwbGljYXRpb25zIG9yIHRob3NlIHdoaWNoIHNlcnZlIG1hbnkgdXNlcnMgd2l0aFxuICogZGlmZmVyZW50IGFjY2VzcyBwZXJtaXNzaW9ucyBhbmQgY29uc2lkZXIgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UgcGVyXG4gKiB3ZWIgcmVxdWVzdC5cbiAqL1xudmFyIERhdGFMb2FkZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEYXRhTG9hZGVyKGJhdGNoTG9hZEZuLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBiYXRjaExvYWRGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YUxvYWRlciBtdXN0IGJlIGNvbnN0cnVjdGVkIHdpdGggYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzICcgKyAoXCJBcnJheTxrZXk+IGFuZCByZXR1cm5zIFByb21pc2U8QXJyYXk8dmFsdWU+PiwgYnV0IGdvdDogXCIgKyBiYXRjaExvYWRGbiArIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmF0Y2hMb2FkRm4gPSBiYXRjaExvYWRGbjtcbiAgICB0aGlzLl9tYXhCYXRjaFNpemUgPSBnZXRWYWxpZE1heEJhdGNoU2l6ZShvcHRpb25zKTtcbiAgICB0aGlzLl9iYXRjaFNjaGVkdWxlRm4gPSBnZXRWYWxpZEJhdGNoU2NoZWR1bGVGbihvcHRpb25zKTtcbiAgICB0aGlzLl9jYWNoZUtleUZuID0gZ2V0VmFsaWRDYWNoZUtleUZuKG9wdGlvbnMpO1xuICAgIHRoaXMuX2NhY2hlTWFwID0gZ2V0VmFsaWRDYWNoZU1hcChvcHRpb25zKTtcbiAgICB0aGlzLl9iYXRjaCA9IG51bGw7XG4gICAgdGhpcy5uYW1lID0gZ2V0VmFsaWROYW1lKG9wdGlvbnMpO1xuICB9IC8vIFByaXZhdGVcblxuXG4gIHZhciBfcHJvdG8gPSBEYXRhTG9hZGVyLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogTG9hZHMgYSBrZXksIHJldHVybmluZyBhIGBQcm9taXNlYCBmb3IgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoYXQga2V5LlxuICAgKi9cbiAgX3Byb3RvLmxvYWQgPSBmdW5jdGlvbiBsb2FkKGtleSkge1xuICAgIGlmIChrZXkgPT09IG51bGwgfHwga2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsb2FkZXIubG9hZCgpIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggYSB2YWx1ZSwgJyArIChcImJ1dCBnb3Q6IFwiICsgU3RyaW5nKGtleSkgKyBcIi5cIikpO1xuICAgIH1cblxuICAgIHZhciBiYXRjaCA9IGdldEN1cnJlbnRCYXRjaCh0aGlzKTtcbiAgICB2YXIgY2FjaGVNYXAgPSB0aGlzLl9jYWNoZU1hcDtcblxuICAgIHZhciBjYWNoZUtleSA9IHRoaXMuX2NhY2hlS2V5Rm4oa2V5KTsgLy8gSWYgY2FjaGluZyBhbmQgdGhlcmUgaXMgYSBjYWNoZS1oaXQsIHJldHVybiBjYWNoZWQgUHJvbWlzZS5cblxuXG4gICAgaWYgKGNhY2hlTWFwKSB7XG4gICAgICB2YXIgY2FjaGVkUHJvbWlzZSA9IGNhY2hlTWFwLmdldChjYWNoZUtleSk7XG5cbiAgICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICAgIHZhciBjYWNoZUhpdHMgPSBiYXRjaC5jYWNoZUhpdHMgfHwgKGJhdGNoLmNhY2hlSGl0cyA9IFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgY2FjaGVIaXRzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZShjYWNoZWRQcm9taXNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBuZXcgUHJvbWlzZSBmb3IgdGhpcyBrZXksIGFuZCBlbnF1ZXVlIGl0IHRvIGJlXG4gICAgLy8gZGlzcGF0Y2hlZCBhbG9uZyB3aXRoIHRoZSBjdXJyZW50IGJhdGNoLlxuXG5cbiAgICBiYXRjaC5rZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGJhdGNoLmNhbGxiYWNrcy5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBJZiBjYWNoaW5nLCBjYWNoZSB0aGlzIHByb21pc2UuXG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIGNhY2hlTWFwLnNldChjYWNoZUtleSwgcHJvbWlzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIExvYWRzIG11bHRpcGxlIGtleXMsIHByb21pc2luZyBhbiBhcnJheSBvZiB2YWx1ZXM6XG4gICAqXG4gICAqICAgICB2YXIgWyBhLCBiIF0gPSBhd2FpdCBteUxvYWRlci5sb2FkTWFueShbICdhJywgJ2InIF0pO1xuICAgKlxuICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gdGhlIG1vcmUgdmVyYm9zZTpcbiAgICpcbiAgICogICAgIHZhciBbIGEsIGIgXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICogICAgICAgbXlMb2FkZXIubG9hZCgnYScpLFxuICAgKiAgICAgICBteUxvYWRlci5sb2FkKCdiJylcbiAgICogICAgIF0pO1xuICAgKlxuICAgKiBIb3dldmVyIGl0IGlzIGRpZmZlcmVudCBpbiB0aGUgY2FzZSB3aGVyZSBhbnkgbG9hZCBmYWlscy4gV2hlcmVcbiAgICogUHJvbWlzZS5hbGwoKSB3b3VsZCByZWplY3QsIGxvYWRNYW55KCkgYWx3YXlzIHJlc29sdmVzLCBob3dldmVyIGVhY2ggcmVzdWx0XG4gICAqIGlzIGVpdGhlciBhIHZhbHVlIG9yIGFuIEVycm9yIGluc3RhbmNlLlxuICAgKlxuICAgKiAgICAgdmFyIFsgYSwgYiwgYyBdID0gYXdhaXQgbXlMb2FkZXIubG9hZE1hbnkoWyAnYScsICdiJywgJ2JhZGtleScgXSk7XG4gICAqICAgICAvLyBjIGluc3RhbmNlb2YgRXJyb3JcbiAgICpcbiAgICovXG4gIDtcblxuICBfcHJvdG8ubG9hZE1hbnkgPSBmdW5jdGlvbiBsb2FkTWFueShrZXlzKSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShrZXlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxvYWRlci5sb2FkTWFueSgpIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIHdpdGggQXJyYXk8a2V5PiAnICsgKFwiYnV0IGdvdDogXCIgKyBrZXlzICsgXCIuXCIpKTtcbiAgICB9IC8vIFN1cHBvcnQgQXJyYXlMaWtlIGJ5IHVzaW5nIG9ubHkgbWluaW1hbCBwcm9wZXJ0eSBhY2Nlc3NcblxuXG4gICAgdmFyIGxvYWRQcm9taXNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2FkUHJvbWlzZXMucHVzaCh0aGlzLmxvYWQoa2V5c1tpXSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChsb2FkUHJvbWlzZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIHZhbHVlIGF0IGBrZXlgIGZyb20gdGhlIGNhY2hlLCBpZiBpdCBleGlzdHMuIFJldHVybnMgaXRzZWxmIGZvclxuICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoa2V5KSB7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIHZhciBjYWNoZUtleSA9IHRoaXMuX2NhY2hlS2V5Rm4oa2V5KTtcblxuICAgICAgY2FjaGVNYXBbXCJkZWxldGVcIl0oY2FjaGVLZXkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGVudGlyZSBjYWNoZS4gVG8gYmUgdXNlZCB3aGVuIHNvbWUgZXZlbnQgcmVzdWx0cyBpbiB1bmtub3duXG4gICAqIGludmFsaWRhdGlvbnMgYWNyb3NzIHRoaXMgcGFydGljdWxhciBgRGF0YUxvYWRlcmAuIFJldHVybnMgaXRzZWxmIGZvclxuICAgKiBtZXRob2QgY2hhaW5pbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsZWFyQWxsID0gZnVuY3Rpb24gY2xlYXJBbGwoKSB7XG4gICAgdmFyIGNhY2hlTWFwID0gdGhpcy5fY2FjaGVNYXA7XG5cbiAgICBpZiAoY2FjaGVNYXApIHtcbiAgICAgIGNhY2hlTWFwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgdGhlIHByb3ZpZGVkIGtleSBhbmQgdmFsdWUgdG8gdGhlIGNhY2hlLiBJZiB0aGUga2V5IGFscmVhZHlcbiAgICogZXhpc3RzLCBubyBjaGFuZ2UgaXMgbWFkZS4gUmV0dXJucyBpdHNlbGYgZm9yIG1ldGhvZCBjaGFpbmluZy5cbiAgICpcbiAgICogVG8gcHJpbWUgdGhlIGNhY2hlIHdpdGggYW4gZXJyb3IgYXQgYSBrZXksIHByb3ZpZGUgYW4gRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnByaW1lID0gZnVuY3Rpb24gcHJpbWUoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBjYWNoZU1hcCA9IHRoaXMuX2NhY2hlTWFwO1xuXG4gICAgaWYgKGNhY2hlTWFwKSB7XG4gICAgICB2YXIgY2FjaGVLZXkgPSB0aGlzLl9jYWNoZUtleUZuKGtleSk7IC8vIE9ubHkgYWRkIHRoZSBrZXkgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdC5cblxuXG4gICAgICBpZiAoY2FjaGVNYXAuZ2V0KGNhY2hlS2V5KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENhY2hlIGEgcmVqZWN0ZWQgcHJvbWlzZSBpZiB0aGUgdmFsdWUgaXMgYW4gRXJyb3IsIGluIG9yZGVyIHRvIG1hdGNoXG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciBvZiBsb2FkKGtleSkuXG4gICAgICAgIHZhciBwcm9taXNlO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KHZhbHVlKTsgLy8gU2luY2UgdGhpcyBpcyBhIGNhc2Ugd2hlcmUgYW4gRXJyb3IgaXMgaW50ZW50aW9uYWxseSBiZWluZyBwcmltZWRcbiAgICAgICAgICAvLyBmb3IgYSBnaXZlbiBrZXksIHdlIHdhbnQgdG8gZGlzYWJsZSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGVNYXAuc2V0KGNhY2hlS2V5LCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIG5hbWUgZ2l2ZW4gdG8gdGhpcyBgRGF0YUxvYWRlcmAgaW5zdGFuY2UuIFVzZWZ1bCBmb3IgQVBNIHRvb2xzLlxuICAgKlxuICAgKiBJcyBgbnVsbGAgaWYgbm90IHNldCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAqL1xuICA7XG5cbiAgcmV0dXJuIERhdGFMb2FkZXI7XG59KCk7IC8vIFByaXZhdGU6IEVucXVldWUgYSBKb2IgdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIFwiUHJvbWlzZUpvYnNcIiBKb2JzLlxuLy9cbi8vIEVTNiBKYXZhU2NyaXB0IHVzZXMgdGhlIGNvbmNlcHRzIEpvYiBhbmQgSm9iUXVldWUgdG8gc2NoZWR1bGUgd29yayB0byBvY2N1clxuLy8gYWZ0ZXIgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQgaGFzIGNvbXBsZXRlZDpcbi8vIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1qb2JzLWFuZC1qb2ItcXVldWVzXG4vL1xuLy8gTm9kZS5qcyB1c2VzIHRoZSBgcHJvY2Vzcy5uZXh0VGlja2AgbWVjaGFuaXNtIHRvIGltcGxlbWVudCB0aGUgY29uY2VwdCBvZiBhXG4vLyBKb2IsIG1haW50YWluaW5nIGEgZ2xvYmFsIEZJRk8gSm9iUXVldWUgZm9yIGFsbCBKb2JzLCB3aGljaCBpcyBmbHVzaGVkIGFmdGVyXG4vLyB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGVuZHMuXG4vL1xuLy8gV2hlbiBjYWxsaW5nIGB0aGVuYCBvbiBhIFByb21pc2UsIGl0IGVucXVldWVzIGEgSm9iIG9uIGEgc3BlY2lmaWNcbi8vIFwiUHJvbWlzZUpvYnNcIiBKb2JRdWV1ZSB3aGljaCBpcyBmbHVzaGVkIGluIE5vZGUgYXMgYSBzaW5nbGUgSm9iIG9uIHRoZVxuLy8gZ2xvYmFsIEpvYlF1ZXVlLlxuLy9cbi8vIERhdGFMb2FkZXIgYmF0Y2hlcyBhbGwgbG9hZHMgd2hpY2ggb2NjdXIgaW4gYSBzaW5nbGUgZnJhbWUgb2YgZXhlY3V0aW9uLCBidXRcbi8vIHNob3VsZCBpbmNsdWRlIGluIHRoZSBiYXRjaCBhbGwgbG9hZHMgd2hpY2ggb2NjdXIgZHVyaW5nIHRoZSBmbHVzaGluZyBvZiB0aGVcbi8vIFwiUHJvbWlzZUpvYnNcIiBKb2JRdWV1ZSBhZnRlciB0aGF0IHNhbWUgZXhlY3V0aW9uIGZyYW1lLlxuLy9cbi8vIEluIG9yZGVyIHRvIGF2b2lkIHRoZSBEYXRhTG9hZGVyIGRpc3BhdGNoIEpvYiBvY2N1cmluZyBiZWZvcmUgXCJQcm9taXNlSm9ic1wiLFxuLy8gQSBQcm9taXNlIEpvYiBpcyBjcmVhdGVkIHdpdGggdGhlIHNvbGUgcHVycG9zZSBvZiBlbnF1ZXVpbmcgYSBnbG9iYWwgSm9iLFxuLy8gZW5zdXJpbmcgdGhhdCBpdCBhbHdheXMgb2NjdXJzIGFmdGVyIFwiUHJvbWlzZUpvYnNcIiBlbmRzLlxuLy9cbi8vIE5vZGUuanMncyBqb2IgcXVldWUgaXMgdW5pcXVlLiBCcm93c2VycyBkbyBub3QgaGF2ZSBhbiBlcXVpdmFsZW50IG1lY2hhbmlzbVxuLy8gZm9yIGVucXVldWluZyBhIGpvYiB0byBiZSBwZXJmb3JtZWQgYWZ0ZXIgcHJvbWlzZSBtaWNyb3Rhc2tzIGFuZCBiZWZvcmUgdGhlXG4vLyBuZXh0IG1hY3JvdGFzay4gRm9yIGJyb3dzZXIgZW52aXJvbm1lbnRzLCBhIG1hY3JvdGFzayBpcyB1c2VkICh2aWFcbi8vIHNldEltbWVkaWF0ZSBvciBzZXRUaW1lb3V0KSBhdCBhIHBvdGVudGlhbCBwZXJmb3JtYW5jZSBwZW5hbHR5LlxuXG5cbnZhciBlbnF1ZXVlUG9zdFByb21pc2VKb2IgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCFyZXNvbHZlZFByb21pc2UpIHtcbiAgICByZXNvbHZlZFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgfSk7XG59IDogdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uIChmbikge1xuICBzZXRJbW1lZGlhdGUoZm4pO1xufSA6IGZ1bmN0aW9uIChmbikge1xuICBzZXRUaW1lb3V0KGZuKTtcbn07IC8vIFByaXZhdGU6IGNhY2hlZCByZXNvbHZlZCBQcm9taXNlIGluc3RhbmNlXG5cbnZhciByZXNvbHZlZFByb21pc2U7IC8vIFByaXZhdGU6IERlc2NyaWJlcyBhIGJhdGNoIG9mIHJlcXVlc3RzXG5cbi8vIFByaXZhdGU6IEVpdGhlciByZXR1cm5zIHRoZSBjdXJyZW50IGJhdGNoLCBvciBjcmVhdGVzIGFuZCBzY2hlZHVsZXMgYVxuLy8gZGlzcGF0Y2ggb2YgYSBuZXcgYmF0Y2ggZm9yIHRoZSBnaXZlbiBsb2FkZXIuXG5mdW5jdGlvbiBnZXRDdXJyZW50QmF0Y2gobG9hZGVyKSB7XG4gIC8vIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGJhdGNoIHdoaWNoIGhhcyBub3QgeWV0IGRpc3BhdGNoZWQgYW5kIGlzIHdpdGhpblxuICAvLyB0aGUgbGltaXQgb2YgdGhlIGJhdGNoIHNpemUsIHRoZW4gcmV0dXJuIGl0LlxuICB2YXIgZXhpc3RpbmdCYXRjaCA9IGxvYWRlci5fYmF0Y2g7XG5cbiAgaWYgKGV4aXN0aW5nQmF0Y2ggIT09IG51bGwgJiYgIWV4aXN0aW5nQmF0Y2guaGFzRGlzcGF0Y2hlZCAmJiBleGlzdGluZ0JhdGNoLmtleXMubGVuZ3RoIDwgbG9hZGVyLl9tYXhCYXRjaFNpemUpIHtcbiAgICByZXR1cm4gZXhpc3RpbmdCYXRjaDtcbiAgfSAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBiYXRjaCBmb3IgdGhpcyBsb2FkZXIuXG5cblxuICB2YXIgbmV3QmF0Y2ggPSB7XG4gICAgaGFzRGlzcGF0Y2hlZDogZmFsc2UsXG4gICAga2V5czogW10sXG4gICAgY2FsbGJhY2tzOiBbXVxuICB9OyAvLyBTdG9yZSBpdCBvbiB0aGUgbG9hZGVyIHNvIGl0IG1heSBiZSByZXVzZWQuXG5cbiAgbG9hZGVyLl9iYXRjaCA9IG5ld0JhdGNoOyAvLyBUaGVuIHNjaGVkdWxlIGEgdGFzayB0byBkaXNwYXRjaCB0aGlzIGJhdGNoIG9mIHJlcXVlc3RzLlxuXG4gIGxvYWRlci5fYmF0Y2hTY2hlZHVsZUZuKGZ1bmN0aW9uICgpIHtcbiAgICBkaXNwYXRjaEJhdGNoKGxvYWRlciwgbmV3QmF0Y2gpO1xuICB9KTtcblxuICByZXR1cm4gbmV3QmF0Y2g7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQmF0Y2gobG9hZGVyLCBiYXRjaCkge1xuICAvLyBNYXJrIHRoaXMgYmF0Y2ggYXMgaGF2aW5nIGJlZW4gZGlzcGF0Y2hlZC5cbiAgYmF0Y2guaGFzRGlzcGF0Y2hlZCA9IHRydWU7IC8vIElmIHRoZXJlJ3Mgbm90aGluZyB0byBsb2FkLCByZXNvbHZlIGFueSBjYWNoZSBoaXRzIGFuZCByZXR1cm4gZWFybHkuXG5cbiAgaWYgKGJhdGNoLmtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmVzb2x2ZUNhY2hlSGl0cyhiYXRjaCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIENhbGwgdGhlIHByb3ZpZGVkIGJhdGNoTG9hZEZuIGZvciB0aGlzIGxvYWRlciB3aXRoIHRoZSBiYXRjaCdzIGtleXMgYW5kXG4gIC8vIHdpdGggdGhlIGxvYWRlciBhcyB0aGUgYHRoaXNgIGNvbnRleHQuXG5cblxuICB2YXIgYmF0Y2hQcm9taXNlO1xuXG4gIHRyeSB7XG4gICAgYmF0Y2hQcm9taXNlID0gbG9hZGVyLl9iYXRjaExvYWRGbihiYXRjaC5rZXlzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWlsZWREaXNwYXRjaChsb2FkZXIsIGJhdGNoLCBuZXcgVHlwZUVycm9yKCdEYXRhTG9hZGVyIG11c3QgYmUgY29uc3RydWN0ZWQgd2l0aCBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgJyArICdBcnJheTxrZXk+IGFuZCByZXR1cm5zIFByb21pc2U8QXJyYXk8dmFsdWU+PiwgYnV0IHRoZSBmdW5jdGlvbiAnICsgKFwiZXJyb3JlZCBzeW5jaHJvbm91c2x5OiBcIiArIFN0cmluZyhlKSArIFwiLlwiKSkpO1xuICB9IC8vIEFzc2VydCB0aGUgZXhwZWN0ZWQgcmVzcG9uc2UgZnJvbSBiYXRjaExvYWRGblxuXG5cbiAgaWYgKCFiYXRjaFByb21pc2UgfHwgdHlwZW9mIGJhdGNoUHJvbWlzZS50aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhaWxlZERpc3BhdGNoKGxvYWRlciwgYmF0Y2gsIG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgJ0FycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgdGhlIGZ1bmN0aW9uIGRpZCAnICsgKFwibm90IHJldHVybiBhIFByb21pc2U6IFwiICsgU3RyaW5nKGJhdGNoUHJvbWlzZSkgKyBcIi5cIikpKTtcbiAgfSAvLyBBd2FpdCB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgY2FsbCB0byBiYXRjaExvYWRGbi5cblxuXG4gIGJhdGNoUHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAvLyBBc3NlcnQgdGhlIGV4cGVjdGVkIHJlc29sdXRpb24gZnJvbSBiYXRjaExvYWRGbi5cbiAgICBpZiAoIWlzQXJyYXlMaWtlKHZhbHVlcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGFMb2FkZXIgbXVzdCBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyAnICsgJ0FycmF5PGtleT4gYW5kIHJldHVybnMgUHJvbWlzZTxBcnJheTx2YWx1ZT4+LCBidXQgdGhlIGZ1bmN0aW9uIGRpZCAnICsgKFwibm90IHJldHVybiBhIFByb21pc2Ugb2YgYW4gQXJyYXk6IFwiICsgU3RyaW5nKHZhbHVlcykgKyBcIi5cIikpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBiYXRjaC5rZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGF0YUxvYWRlciBtdXN0IGJlIGNvbnN0cnVjdGVkIHdpdGggYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzICcgKyAnQXJyYXk8a2V5PiBhbmQgcmV0dXJucyBQcm9taXNlPEFycmF5PHZhbHVlPj4sIGJ1dCB0aGUgZnVuY3Rpb24gZGlkICcgKyAnbm90IHJldHVybiBhIFByb21pc2Ugb2YgYW4gQXJyYXkgb2YgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBBcnJheSAnICsgJ29mIGtleXMuJyArIChcIlxcblxcbktleXM6XFxuXCIgKyBTdHJpbmcoYmF0Y2gua2V5cykpICsgKFwiXFxuXFxuVmFsdWVzOlxcblwiICsgU3RyaW5nKHZhbHVlcykpKTtcbiAgICB9IC8vIFJlc29sdmUgYWxsIGNhY2hlIGhpdHMgaW4gdGhlIHNhbWUgbWljcm8tdGFzayBhcyBmcmVzaGx5IGxvYWRlZCB2YWx1ZXMuXG5cblxuICAgIHJlc29sdmVDYWNoZUhpdHMoYmF0Y2gpOyAvLyBTdGVwIHRocm91Z2ggdmFsdWVzLCByZXNvbHZpbmcgb3IgcmVqZWN0aW5nIGVhY2ggUHJvbWlzZSBpbiB0aGUgYmF0Y2guXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoLmNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuXG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBiYXRjaC5jYWxsYmFja3NbaV0ucmVqZWN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhdGNoLmNhbGxiYWNrc1tpXS5yZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgZmFpbGVkRGlzcGF0Y2gobG9hZGVyLCBiYXRjaCwgZXJyb3IpO1xuICB9KTtcbn0gLy8gUHJpdmF0ZTogZG8gbm90IGNhY2hlIGluZGl2aWR1YWwgbG9hZHMgaWYgdGhlIGVudGlyZSBiYXRjaCBkaXNwYXRjaCBmYWlscyxcbi8vIGJ1dCBzdGlsbCByZWplY3QgZWFjaCByZXF1ZXN0IHNvIHRoZXkgZG8gbm90IGhhbmcuXG5cblxuZnVuY3Rpb24gZmFpbGVkRGlzcGF0Y2gobG9hZGVyLCBiYXRjaCwgZXJyb3IpIHtcbiAgLy8gQ2FjaGUgaGl0cyBhcmUgcmVzb2x2ZWQsIGV2ZW4gdGhvdWdoIHRoZSBiYXRjaCBmYWlsZWQuXG4gIHJlc29sdmVDYWNoZUhpdHMoYmF0Y2gpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYmF0Y2gua2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGxvYWRlci5jbGVhcihiYXRjaC5rZXlzW2ldKTtcbiAgICBiYXRjaC5jYWxsYmFja3NbaV0ucmVqZWN0KGVycm9yKTtcbiAgfVxufSAvLyBQcml2YXRlOiBSZXNvbHZlcyB0aGUgUHJvbWlzZXMgZm9yIGFueSBjYWNoZSBoaXRzIGluIHRoaXMgYmF0Y2guXG5cblxuZnVuY3Rpb24gcmVzb2x2ZUNhY2hlSGl0cyhiYXRjaCkge1xuICBpZiAoYmF0Y2guY2FjaGVIaXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaC5jYWNoZUhpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhdGNoLmNhY2hlSGl0c1tpXSgpO1xuICAgIH1cbiAgfVxufSAvLyBQcml2YXRlOiBnaXZlbiB0aGUgRGF0YUxvYWRlcidzIG9wdGlvbnMsIHByb2R1Y2UgYSB2YWxpZCBtYXggYmF0Y2ggc2l6ZS5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZE1heEJhdGNoU2l6ZShvcHRpb25zKSB7XG4gIHZhciBzaG91bGRCYXRjaCA9ICFvcHRpb25zIHx8IG9wdGlvbnMuYmF0Y2ggIT09IGZhbHNlO1xuXG4gIGlmICghc2hvdWxkQmF0Y2gpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBtYXhCYXRjaFNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMubWF4QmF0Y2hTaXplO1xuXG4gIGlmIChtYXhCYXRjaFNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBJbmZpbml0eTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4QmF0Y2hTaXplICE9PSAnbnVtYmVyJyB8fCBtYXhCYXRjaFNpemUgPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heEJhdGNoU2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyOiBcIiArIG1heEJhdGNoU2l6ZSk7XG4gIH1cblxuICByZXR1cm4gbWF4QmF0Y2hTaXplO1xufSAvLyBQcml2YXRlXG5cblxuZnVuY3Rpb24gZ2V0VmFsaWRCYXRjaFNjaGVkdWxlRm4ob3B0aW9ucykge1xuICB2YXIgYmF0Y2hTY2hlZHVsZUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLmJhdGNoU2NoZWR1bGVGbjtcblxuICBpZiAoYmF0Y2hTY2hlZHVsZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZW5xdWV1ZVBvc3RQcm9taXNlSm9iO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiYXRjaFNjaGVkdWxlRm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYmF0Y2hTY2hlZHVsZUZuIG11c3QgYmUgYSBmdW5jdGlvbjogXCIgKyBiYXRjaFNjaGVkdWxlRm4pO1xuICB9XG5cbiAgcmV0dXJuIGJhdGNoU2NoZWR1bGVGbjtcbn0gLy8gUHJpdmF0ZTogZ2l2ZW4gdGhlIERhdGFMb2FkZXIncyBvcHRpb25zLCBwcm9kdWNlIGEgY2FjaGUga2V5IGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIGdldFZhbGlkQ2FjaGVLZXlGbihvcHRpb25zKSB7XG4gIHZhciBjYWNoZUtleUZuID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlS2V5Rm47XG5cbiAgaWYgKGNhY2hlS2V5Rm4gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIGNhY2hlS2V5Rm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FjaGVLZXlGbiBtdXN0IGJlIGEgZnVuY3Rpb246IFwiICsgY2FjaGVLZXlGbik7XG4gIH1cblxuICByZXR1cm4gY2FjaGVLZXlGbjtcbn0gLy8gUHJpdmF0ZTogZ2l2ZW4gdGhlIERhdGFMb2FkZXIncyBvcHRpb25zLCBwcm9kdWNlIGEgQ2FjaGVNYXAgdG8gYmUgdXNlZC5cblxuXG5mdW5jdGlvbiBnZXRWYWxpZENhY2hlTWFwKG9wdGlvbnMpIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gZmFsc2U7XG5cbiAgaWYgKCFzaG91bGRDYWNoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNhY2hlTWFwID0gb3B0aW9ucyAmJiBvcHRpb25zLmNhY2hlTWFwO1xuXG4gIGlmIChjYWNoZU1hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgfVxuXG4gIGlmIChjYWNoZU1hcCAhPT0gbnVsbCkge1xuICAgIHZhciBjYWNoZUZ1bmN0aW9ucyA9IFsnZ2V0JywgJ3NldCcsICdkZWxldGUnLCAnY2xlYXInXTtcbiAgICB2YXIgbWlzc2luZ0Z1bmN0aW9ucyA9IGNhY2hlRnVuY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoZm5OYW1lKSB7XG4gICAgICByZXR1cm4gY2FjaGVNYXAgJiYgdHlwZW9mIGNhY2hlTWFwW2ZuTmFtZV0gIT09ICdmdW5jdGlvbic7XG4gICAgfSk7XG5cbiAgICBpZiAobWlzc2luZ0Z1bmN0aW9ucy5sZW5ndGggIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0N1c3RvbSBjYWNoZU1hcCBtaXNzaW5nIG1ldGhvZHM6ICcgKyBtaXNzaW5nRnVuY3Rpb25zLmpvaW4oJywgJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYWNoZU1hcDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWROYW1lKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubmFtZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBQcml2YXRlXG5cblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJyAmJiAoeC5sZW5ndGggPT09IDAgfHwgeC5sZW5ndGggPiAwICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCB4Lmxlbmd0aCAtIDEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTG9hZGVyOyJdLCJuYW1lcyI6WyJEYXRhTG9hZGVyIiwiYmF0Y2hMb2FkRm4iLCJvcHRpb25zIiwiVHlwZUVycm9yIiwiX2JhdGNoTG9hZEZuIiwiX21heEJhdGNoU2l6ZSIsImdldFZhbGlkTWF4QmF0Y2hTaXplIiwiX2JhdGNoU2NoZWR1bGVGbiIsImdldFZhbGlkQmF0Y2hTY2hlZHVsZUZuIiwiX2NhY2hlS2V5Rm4iLCJnZXRWYWxpZENhY2hlS2V5Rm4iLCJfY2FjaGVNYXAiLCJnZXRWYWxpZENhY2hlTWFwIiwiX2JhdGNoIiwibmFtZSIsImdldFZhbGlkTmFtZSIsIl9wcm90byIsInByb3RvdHlwZSIsImxvYWQiLCJrZXkiLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJiYXRjaCIsImdldEN1cnJlbnRCYXRjaCIsImNhY2hlTWFwIiwiY2FjaGVLZXkiLCJjYWNoZWRQcm9taXNlIiwiZ2V0IiwiY2FjaGVIaXRzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwdXNoIiwia2V5cyIsInByb21pc2UiLCJyZWplY3QiLCJjYWxsYmFja3MiLCJzZXQiLCJsb2FkTWFueSIsImlzQXJyYXlMaWtlIiwibG9hZFByb21pc2VzIiwiaSIsImxlbmd0aCIsImVycm9yIiwiYWxsIiwiY2xlYXIiLCJjbGVhckFsbCIsInByaW1lIiwidmFsdWUiLCJFcnJvciIsImVucXVldWVQb3N0UHJvbWlzZUpvYiIsInByb2Nlc3MiLCJuZXh0VGljayIsImZuIiwicmVzb2x2ZWRQcm9taXNlIiwidGhlbiIsInNldEltbWVkaWF0ZSIsInNldFRpbWVvdXQiLCJsb2FkZXIiLCJleGlzdGluZ0JhdGNoIiwiaGFzRGlzcGF0Y2hlZCIsIm5ld0JhdGNoIiwiZGlzcGF0Y2hCYXRjaCIsInJlc29sdmVDYWNoZUhpdHMiLCJiYXRjaFByb21pc2UiLCJlIiwiZmFpbGVkRGlzcGF0Y2giLCJ2YWx1ZXMiLCJzaG91bGRCYXRjaCIsIm1heEJhdGNoU2l6ZSIsIkluZmluaXR5IiwiYmF0Y2hTY2hlZHVsZUZuIiwiY2FjaGVLZXlGbiIsInNob3VsZENhY2hlIiwiY2FjaGUiLCJNYXAiLCJjYWNoZUZ1bmN0aW9ucyIsIm1pc3NpbmdGdW5jdGlvbnMiLCJmaWx0ZXIiLCJmbk5hbWUiLCJqb2luIiwieCIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dataloader/index.js\n");

/***/ })

};
;