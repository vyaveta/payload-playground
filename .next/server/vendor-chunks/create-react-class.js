"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/create-react-class";
exports.ids = ["vendor-chunks/create-react-class"];
exports.modules = {

/***/ "(ssr)/./node_modules/create-react-class/factory.js":
/*!****************************************************!*\
  !*** ./node_modules/create-react-class/factory.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar _assign = __webpack_require__(/*! object-assign */ \"(ssr)/./node_modules/object-assign/index.js\");\n// -- Inlined from fbjs --\nvar emptyObject = {};\nif (true) {\n    Object.freeze(emptyObject);\n}\nvar validateFormat = function validateFormat(format) {};\nif (true) {\n    validateFormat = function validateFormat(format) {\n        if (format === undefined) {\n            throw new Error(\"invariant requires an error message argument\");\n        }\n    };\n}\nfunction _invariant(condition, format, a, b, c, d, e, f) {\n    validateFormat(format);\n    if (!condition) {\n        var error;\n        if (format === undefined) {\n            error = new Error(\"Minified exception occurred; use the non-minified dev environment \" + \"for the full error message and additional helpful warnings.\");\n        } else {\n            var args = [\n                a,\n                b,\n                c,\n                d,\n                e,\n                f\n            ];\n            var argIndex = 0;\n            error = new Error(format.replace(/%s/g, function() {\n                return args[argIndex++];\n            }));\n            error.name = \"Invariant Violation\";\n        }\n        error.framesToPop = 1; // we don't care about invariant's own frame\n        throw error;\n    }\n}\nvar warning = function() {};\nif (true) {\n    var printWarning = function printWarning(format) {\n        for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        var argIndex = 0;\n        var message = \"Warning: \" + format.replace(/%s/g, function() {\n            return args[argIndex++];\n        });\n        if (typeof console !== \"undefined\") {\n            console.error(message);\n        }\n        try {\n            // --- Welcome to debugging React ---\n            // This error was thrown as a convenience so that you can use this stack\n            // to find the callsite that caused this warning to fire.\n            throw new Error(message);\n        } catch (x) {}\n    };\n    warning = function warning(condition, format) {\n        if (format === undefined) {\n            throw new Error(\"`warning(condition, format, ...args)` requires a warning \" + \"message argument\");\n        }\n        if (format.indexOf(\"Failed Composite propType: \") === 0) {\n            return; // Ignore CompositeComponent proptype check.\n        }\n        if (!condition) {\n            for(var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++){\n                args[_key2 - 2] = arguments[_key2];\n            }\n            printWarning.apply(undefined, [\n                format\n            ].concat(args));\n        }\n    };\n}\n// /-- Inlined from fbjs --\nvar MIXINS_KEY = \"mixins\";\n// Helper function to allow the creation of anonymous functions which do not\n// have .name set to the name of the variable being assigned to.\nfunction identity(fn) {\n    return fn;\n}\nvar ReactPropTypeLocationNames;\nif (true) {\n    ReactPropTypeLocationNames = {\n        prop: \"prop\",\n        context: \"context\",\n        childContext: \"child context\"\n    };\n} else {}\nfunction factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {\n    /**\n   * Policies that describe methods in `ReactClassInterface`.\n   */ var injectedMixins = [];\n    /**\n   * Composite components are higher-level components that compose other composite\n   * or host components.\n   *\n   * To create a new type of `ReactClass`, pass a specification of\n   * your new class to `React.createClass`. The only requirement of your class\n   * specification is that you implement a `render` method.\n   *\n   *   var MyComponent = React.createClass({\n   *     render: function() {\n   *       return <div>Hello World</div>;\n   *     }\n   *   });\n   *\n   * The class specification supports a specific protocol of methods that have\n   * special meaning (e.g. `render`). See `ReactClassInterface` for\n   * more the comprehensive protocol. Any other properties and methods in the\n   * class specification will be available on the prototype.\n   *\n   * @interface ReactClassInterface\n   * @internal\n   */ var ReactClassInterface = {\n        /**\n     * An array of Mixin objects to include when defining your component.\n     *\n     * @type {array}\n     * @optional\n     */ mixins: \"DEFINE_MANY\",\n        /**\n     * An object containing properties and methods that should be defined on\n     * the component's constructor instead of its prototype (static methods).\n     *\n     * @type {object}\n     * @optional\n     */ statics: \"DEFINE_MANY\",\n        /**\n     * Definition of prop types for this component.\n     *\n     * @type {object}\n     * @optional\n     */ propTypes: \"DEFINE_MANY\",\n        /**\n     * Definition of context types for this component.\n     *\n     * @type {object}\n     * @optional\n     */ contextTypes: \"DEFINE_MANY\",\n        /**\n     * Definition of context types this component sets for its children.\n     *\n     * @type {object}\n     * @optional\n     */ childContextTypes: \"DEFINE_MANY\",\n        // ==== Definition methods ====\n        /**\n     * Invoked when the component is mounted. Values in the mapping will be set on\n     * `this.props` if that prop is not specified (i.e. using an `in` check).\n     *\n     * This method is invoked before `getInitialState` and therefore cannot rely\n     * on `this.state` or use `this.setState`.\n     *\n     * @return {object}\n     * @optional\n     */ getDefaultProps: \"DEFINE_MANY_MERGED\",\n        /**\n     * Invoked once before the component is mounted. The return value will be used\n     * as the initial value of `this.state`.\n     *\n     *   getInitialState: function() {\n     *     return {\n     *       isOn: false,\n     *       fooBaz: new BazFoo()\n     *     }\n     *   }\n     *\n     * @return {object}\n     * @optional\n     */ getInitialState: \"DEFINE_MANY_MERGED\",\n        /**\n     * @return {object}\n     * @optional\n     */ getChildContext: \"DEFINE_MANY_MERGED\",\n        /**\n     * Uses props from `this.props` and state from `this.state` to render the\n     * structure of the component.\n     *\n     * No guarantees are made about when or how often this method is invoked, so\n     * it must not have side effects.\n     *\n     *   render: function() {\n     *     var name = this.props.name;\n     *     return <div>Hello, {name}!</div>;\n     *   }\n     *\n     * @return {ReactComponent}\n     * @required\n     */ render: \"DEFINE_ONCE\",\n        // ==== Delegate methods ====\n        /**\n     * Invoked when the component is initially created and about to be mounted.\n     * This may have side effects, but any external subscriptions or data created\n     * by this method must be cleaned up in `componentWillUnmount`.\n     *\n     * @optional\n     */ componentWillMount: \"DEFINE_MANY\",\n        /**\n     * Invoked when the component has been mounted and has a DOM representation.\n     * However, there is no guarantee that the DOM node is in the document.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been mounted (initialized and rendered) for the first time.\n     *\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */ componentDidMount: \"DEFINE_MANY\",\n        /**\n     * Invoked before the component receives new props.\n     *\n     * Use this as an opportunity to react to a prop transition by updating the\n     * state using `this.setState`. Current props are accessed via `this.props`.\n     *\n     *   componentWillReceiveProps: function(nextProps, nextContext) {\n     *     this.setState({\n     *       likesIncreasing: nextProps.likeCount > this.props.likeCount\n     *     });\n     *   }\n     *\n     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop\n     * transition may cause a state change, but the opposite is not true. If you\n     * need it, you are probably looking for `componentWillUpdate`.\n     *\n     * @param {object} nextProps\n     * @optional\n     */ componentWillReceiveProps: \"DEFINE_MANY\",\n        /**\n     * Invoked while deciding if the component should be updated as a result of\n     * receiving new props, state and/or context.\n     *\n     * Use this as an opportunity to `return false` when you're certain that the\n     * transition to the new props/state/context will not require a component\n     * update.\n     *\n     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {\n     *     return !equal(nextProps, this.props) ||\n     *       !equal(nextState, this.state) ||\n     *       !equal(nextContext, this.context);\n     *   }\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @return {boolean} True if the component should update.\n     * @optional\n     */ shouldComponentUpdate: \"DEFINE_ONCE\",\n        /**\n     * Invoked when the component is about to update due to a transition from\n     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`\n     * and `nextContext`.\n     *\n     * Use this as an opportunity to perform preparation before an update occurs.\n     *\n     * NOTE: You **cannot** use `this.setState()` in this method.\n     *\n     * @param {object} nextProps\n     * @param {?object} nextState\n     * @param {?object} nextContext\n     * @param {ReactReconcileTransaction} transaction\n     * @optional\n     */ componentWillUpdate: \"DEFINE_MANY\",\n        /**\n     * Invoked when the component's DOM representation has been updated.\n     *\n     * Use this as an opportunity to operate on the DOM when the component has\n     * been updated.\n     *\n     * @param {object} prevProps\n     * @param {?object} prevState\n     * @param {?object} prevContext\n     * @param {DOMElement} rootNode DOM element representing the component.\n     * @optional\n     */ componentDidUpdate: \"DEFINE_MANY\",\n        /**\n     * Invoked when the component is about to be removed from its parent and have\n     * its DOM representation destroyed.\n     *\n     * Use this as an opportunity to deallocate any external resources.\n     *\n     * NOTE: There is no `componentDidUnmount` since your component will have been\n     * destroyed by that point.\n     *\n     * @optional\n     */ componentWillUnmount: \"DEFINE_MANY\",\n        /**\n     * Replacement for (deprecated) `componentWillMount`.\n     *\n     * @optional\n     */ UNSAFE_componentWillMount: \"DEFINE_MANY\",\n        /**\n     * Replacement for (deprecated) `componentWillReceiveProps`.\n     *\n     * @optional\n     */ UNSAFE_componentWillReceiveProps: \"DEFINE_MANY\",\n        /**\n     * Replacement for (deprecated) `componentWillUpdate`.\n     *\n     * @optional\n     */ UNSAFE_componentWillUpdate: \"DEFINE_MANY\",\n        // ==== Advanced methods ====\n        /**\n     * Updates the component's currently mounted DOM representation.\n     *\n     * By default, this implements React's rendering and reconciliation algorithm.\n     * Sophisticated clients may wish to override this.\n     *\n     * @param {ReactReconcileTransaction} transaction\n     * @internal\n     * @overridable\n     */ updateComponent: \"OVERRIDE_BASE\"\n    };\n    /**\n   * Similar to ReactClassInterface but for static methods.\n   */ var ReactClassStaticInterface = {\n        /**\n     * This method is invoked after a component is instantiated and when it\n     * receives new props. Return an object to update state in response to\n     * prop changes. Return null to indicate no change to state.\n     *\n     * If an object is returned, its keys will be merged into the existing state.\n     *\n     * @return {object || null}\n     * @optional\n     */ getDerivedStateFromProps: \"DEFINE_MANY_MERGED\"\n    };\n    /**\n   * Mapping from class specification keys to special processing functions.\n   *\n   * Although these are declared like instance properties in the specification\n   * when defining classes using `React.createClass`, they are actually static\n   * and are accessible on the constructor instead of the prototype. Despite\n   * being static, they must be defined outside of the \"statics\" key under\n   * which all other static methods are defined.\n   */ var RESERVED_SPEC_KEYS = {\n        displayName: function(Constructor, displayName) {\n            Constructor.displayName = displayName;\n        },\n        mixins: function(Constructor, mixins) {\n            if (mixins) {\n                for(var i = 0; i < mixins.length; i++){\n                    mixSpecIntoComponent(Constructor, mixins[i]);\n                }\n            }\n        },\n        childContextTypes: function(Constructor, childContextTypes) {\n            if (true) {\n                validateTypeDef(Constructor, childContextTypes, \"childContext\");\n            }\n            Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);\n        },\n        contextTypes: function(Constructor, contextTypes) {\n            if (true) {\n                validateTypeDef(Constructor, contextTypes, \"context\");\n            }\n            Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);\n        },\n        /**\n     * Special case getDefaultProps which should move into statics but requires\n     * automatic merging.\n     */ getDefaultProps: function(Constructor, getDefaultProps) {\n            if (Constructor.getDefaultProps) {\n                Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);\n            } else {\n                Constructor.getDefaultProps = getDefaultProps;\n            }\n        },\n        propTypes: function(Constructor, propTypes) {\n            if (true) {\n                validateTypeDef(Constructor, propTypes, \"prop\");\n            }\n            Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);\n        },\n        statics: function(Constructor, statics) {\n            mixStaticSpecIntoComponent(Constructor, statics);\n        },\n        autobind: function() {}\n    };\n    function validateTypeDef(Constructor, typeDef, location) {\n        for(var propName in typeDef){\n            if (typeDef.hasOwnProperty(propName)) {\n                // use a warning instead of an _invariant so components\n                // don't show up in prod but only in __DEV__\n                if (true) {\n                    warning(typeof typeDef[propName] === \"function\", \"%s: %s type `%s` is invalid; it must be a function, usually from \" + \"React.PropTypes.\", Constructor.displayName || \"ReactClass\", ReactPropTypeLocationNames[location], propName);\n                }\n            }\n        }\n    }\n    function validateMethodOverride(isAlreadyDefined, name) {\n        var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;\n        // Disallow overriding of base class methods unless explicitly allowed.\n        if (ReactClassMixin.hasOwnProperty(name)) {\n            _invariant(specPolicy === \"OVERRIDE_BASE\", \"ReactClassInterface: You are attempting to override \" + \"`%s` from your class specification. Ensure that your method names \" + \"do not overlap with React methods.\", name);\n        }\n        // Disallow defining methods more than once unless explicitly allowed.\n        if (isAlreadyDefined) {\n            _invariant(specPolicy === \"DEFINE_MANY\" || specPolicy === \"DEFINE_MANY_MERGED\", \"ReactClassInterface: You are attempting to define \" + \"`%s` on your component more than once. This conflict may be due \" + \"to a mixin.\", name);\n        }\n    }\n    /**\n   * Mixin helper which handles policy validation and reserved\n   * specification keys when building React classes.\n   */ function mixSpecIntoComponent(Constructor, spec) {\n        if (!spec) {\n            if (true) {\n                var typeofSpec = typeof spec;\n                var isMixinValid = typeofSpec === \"object\" && spec !== null;\n                if (true) {\n                    warning(isMixinValid, \"%s: You're attempting to include a mixin that is either null \" + \"or not an object. Check the mixins included by the component, \" + \"as well as any mixins they include themselves. \" + \"Expected object but got %s.\", Constructor.displayName || \"ReactClass\", spec === null ? null : typeofSpec);\n                }\n            }\n            return;\n        }\n        _invariant(typeof spec !== \"function\", \"ReactClass: You're attempting to \" + \"use a component class or function as a mixin. Instead, just use a \" + \"regular object.\");\n        _invariant(!isValidElement(spec), \"ReactClass: You're attempting to \" + \"use a component as a mixin. Instead, just use a regular object.\");\n        var proto = Constructor.prototype;\n        var autoBindPairs = proto.__reactAutoBindPairs;\n        // By handling mixins before any other properties, we ensure the same\n        // chaining order is applied to methods with DEFINE_MANY policy, whether\n        // mixins are listed before or after these methods in the spec.\n        if (spec.hasOwnProperty(MIXINS_KEY)) {\n            RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);\n        }\n        for(var name in spec){\n            if (!spec.hasOwnProperty(name)) {\n                continue;\n            }\n            if (name === MIXINS_KEY) {\n                continue;\n            }\n            var property = spec[name];\n            var isAlreadyDefined = proto.hasOwnProperty(name);\n            validateMethodOverride(isAlreadyDefined, name);\n            if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {\n                RESERVED_SPEC_KEYS[name](Constructor, property);\n            } else {\n                // Setup methods on prototype:\n                // The following member methods should not be automatically bound:\n                // 1. Expected ReactClass methods (in the \"interface\").\n                // 2. Overridden methods (that were mixed in).\n                var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);\n                var isFunction = typeof property === \"function\";\n                var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;\n                if (shouldAutoBind) {\n                    autoBindPairs.push(name, property);\n                    proto[name] = property;\n                } else {\n                    if (isAlreadyDefined) {\n                        var specPolicy = ReactClassInterface[name];\n                        // These cases should already be caught by validateMethodOverride.\n                        _invariant(isReactClassMethod && (specPolicy === \"DEFINE_MANY_MERGED\" || specPolicy === \"DEFINE_MANY\"), \"ReactClass: Unexpected spec policy %s for key %s \" + \"when mixing in component specs.\", specPolicy, name);\n                        // For methods which are defined more than once, call the existing\n                        // methods before calling the new property, merging if appropriate.\n                        if (specPolicy === \"DEFINE_MANY_MERGED\") {\n                            proto[name] = createMergedResultFunction(proto[name], property);\n                        } else if (specPolicy === \"DEFINE_MANY\") {\n                            proto[name] = createChainedFunction(proto[name], property);\n                        }\n                    } else {\n                        proto[name] = property;\n                        if (true) {\n                            // Add verbose displayName to the function, which helps when looking\n                            // at profiling tools.\n                            if (typeof property === \"function\" && spec.displayName) {\n                                proto[name].displayName = spec.displayName + \"_\" + name;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    function mixStaticSpecIntoComponent(Constructor, statics) {\n        if (!statics) {\n            return;\n        }\n        for(var name in statics){\n            var property = statics[name];\n            if (!statics.hasOwnProperty(name)) {\n                continue;\n            }\n            var isReserved = name in RESERVED_SPEC_KEYS;\n            _invariant(!isReserved, \"ReactClass: You are attempting to define a reserved \" + 'property, `%s`, that shouldn\\'t be on the \"statics\" key. Define it ' + \"as an instance property instead; it will still be accessible on the \" + \"constructor.\", name);\n            var isAlreadyDefined = name in Constructor;\n            if (isAlreadyDefined) {\n                var specPolicy = ReactClassStaticInterface.hasOwnProperty(name) ? ReactClassStaticInterface[name] : null;\n                _invariant(specPolicy === \"DEFINE_MANY_MERGED\", \"ReactClass: You are attempting to define \" + \"`%s` on your component more than once. This conflict may be \" + \"due to a mixin.\", name);\n                Constructor[name] = createMergedResultFunction(Constructor[name], property);\n                return;\n            }\n            Constructor[name] = property;\n        }\n    }\n    /**\n   * Merge two objects, but throw if both contain the same key.\n   *\n   * @param {object} one The first object, which is mutated.\n   * @param {object} two The second object\n   * @return {object} one after it has been mutated to contain everything in two.\n   */ function mergeIntoWithNoDuplicateKeys(one, two) {\n        _invariant(one && two && typeof one === \"object\" && typeof two === \"object\", \"mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.\");\n        for(var key in two){\n            if (two.hasOwnProperty(key)) {\n                _invariant(one[key] === undefined, \"mergeIntoWithNoDuplicateKeys(): \" + \"Tried to merge two objects with the same key: `%s`. This conflict \" + \"may be due to a mixin; in particular, this may be caused by two \" + \"getInitialState() or getDefaultProps() methods returning objects \" + \"with clashing keys.\", key);\n                one[key] = two[key];\n            }\n        }\n        return one;\n    }\n    /**\n   * Creates a function that invokes two functions and merges their return values.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */ function createMergedResultFunction(one, two) {\n        return function mergedResult() {\n            var a = one.apply(this, arguments);\n            var b = two.apply(this, arguments);\n            if (a == null) {\n                return b;\n            } else if (b == null) {\n                return a;\n            }\n            var c = {};\n            mergeIntoWithNoDuplicateKeys(c, a);\n            mergeIntoWithNoDuplicateKeys(c, b);\n            return c;\n        };\n    }\n    /**\n   * Creates a function that invokes two functions and ignores their return vales.\n   *\n   * @param {function} one Function to invoke first.\n   * @param {function} two Function to invoke second.\n   * @return {function} Function that invokes the two argument functions.\n   * @private\n   */ function createChainedFunction(one, two) {\n        return function chainedFunction() {\n            one.apply(this, arguments);\n            two.apply(this, arguments);\n        };\n    }\n    /**\n   * Binds a method to the component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   * @param {function} method Method to be bound.\n   * @return {function} The bound method.\n   */ function bindAutoBindMethod(component, method) {\n        var boundMethod = method.bind(component);\n        if (true) {\n            boundMethod.__reactBoundContext = component;\n            boundMethod.__reactBoundMethod = method;\n            boundMethod.__reactBoundArguments = null;\n            var componentName = component.constructor.displayName;\n            var _bind = boundMethod.bind;\n            boundMethod.bind = function(newThis) {\n                for(var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                // User is trying to bind() an autobound method; we effectively will\n                // ignore the value of \"this\" that the user is trying to use, so\n                // let's warn.\n                if (newThis !== component && newThis !== null) {\n                    if (true) {\n                        warning(false, \"bind(): React component methods may only be bound to the \" + \"component instance. See %s\", componentName);\n                    }\n                } else if (!args.length) {\n                    if (true) {\n                        warning(false, \"bind(): You are binding a component method to the component. \" + \"React does this for you automatically in a high-performance \" + \"way, so you can safely remove this call. See %s\", componentName);\n                    }\n                    return boundMethod;\n                }\n                var reboundMethod = _bind.apply(boundMethod, arguments);\n                reboundMethod.__reactBoundContext = component;\n                reboundMethod.__reactBoundMethod = method;\n                reboundMethod.__reactBoundArguments = args;\n                return reboundMethod;\n            };\n        }\n        return boundMethod;\n    }\n    /**\n   * Binds all auto-bound methods in a component.\n   *\n   * @param {object} component Component whose method is going to be bound.\n   */ function bindAutoBindMethods(component) {\n        var pairs = component.__reactAutoBindPairs;\n        for(var i = 0; i < pairs.length; i += 2){\n            var autoBindKey = pairs[i];\n            var method = pairs[i + 1];\n            component[autoBindKey] = bindAutoBindMethod(component, method);\n        }\n    }\n    var IsMountedPreMixin = {\n        componentDidMount: function() {\n            this.__isMounted = true;\n        }\n    };\n    var IsMountedPostMixin = {\n        componentWillUnmount: function() {\n            this.__isMounted = false;\n        }\n    };\n    /**\n   * Add more to the ReactClass base class. These are all legacy features and\n   * therefore not already part of the modern ReactComponent.\n   */ var ReactClassMixin = {\n        /**\n     * TODO: This will be deprecated because state should always keep a consistent\n     * type signature and the only use case for this, is to avoid that.\n     */ replaceState: function(newState, callback) {\n            this.updater.enqueueReplaceState(this, newState, callback);\n        },\n        /**\n     * Checks whether or not this composite component is mounted.\n     * @return {boolean} True if mounted, false otherwise.\n     * @protected\n     * @final\n     */ isMounted: function() {\n            if (true) {\n                warning(this.__didWarnIsMounted, \"%s: isMounted is deprecated. Instead, make sure to clean up \" + \"subscriptions and pending requests in componentWillUnmount to \" + \"prevent memory leaks.\", this.constructor && this.constructor.displayName || this.name || \"Component\");\n                this.__didWarnIsMounted = true;\n            }\n            return !!this.__isMounted;\n        }\n    };\n    var ReactClassComponent = function() {};\n    _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);\n    /**\n   * Creates a composite component class given a class specification.\n   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass\n   *\n   * @param {object} spec Class specification (which must define `render`).\n   * @return {function} Component constructor function.\n   * @public\n   */ function createClass(spec) {\n        // To keep our warnings more understandable, we'll use a little hack here to\n        // ensure that Constructor.name !== 'Constructor'. This makes sure we don't\n        // unnecessarily identify a class without displayName as 'Constructor'.\n        var Constructor = identity(function(props, context, updater) {\n            // This constructor gets overridden by mocks. The argument is used\n            // by mocks to assert on what gets mounted.\n            if (true) {\n                warning(this instanceof Constructor, \"Something is calling a React component directly. Use a factory or \" + \"JSX instead. See: https://fb.me/react-legacyfactory\");\n            }\n            // Wire up auto-binding\n            if (this.__reactAutoBindPairs.length) {\n                bindAutoBindMethods(this);\n            }\n            this.props = props;\n            this.context = context;\n            this.refs = emptyObject;\n            this.updater = updater || ReactNoopUpdateQueue;\n            this.state = null;\n            // ReactClasses doesn't have constructors. Instead, they use the\n            // getInitialState and componentWillMount methods for initialization.\n            var initialState = this.getInitialState ? this.getInitialState() : null;\n            if (true) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                if (initialState === undefined && this.getInitialState._isMockFunction) {\n                    // This is probably bad practice. Consider warning here and\n                    // deprecating this convenience.\n                    initialState = null;\n                }\n            }\n            _invariant(typeof initialState === \"object\" && !Array.isArray(initialState), \"%s.getInitialState(): must return an object or null\", Constructor.displayName || \"ReactCompositeComponent\");\n            this.state = initialState;\n        });\n        Constructor.prototype = new ReactClassComponent();\n        Constructor.prototype.constructor = Constructor;\n        Constructor.prototype.__reactAutoBindPairs = [];\n        injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));\n        mixSpecIntoComponent(Constructor, IsMountedPreMixin);\n        mixSpecIntoComponent(Constructor, spec);\n        mixSpecIntoComponent(Constructor, IsMountedPostMixin);\n        // Initialize the defaultProps property after all mixins have been merged.\n        if (Constructor.getDefaultProps) {\n            Constructor.defaultProps = Constructor.getDefaultProps();\n        }\n        if (true) {\n            // This is a tag to indicate that the use of these method names is ok,\n            // since it's used with createClass. If it's not, then it's likely a\n            // mistake so we'll warn you to use the static property, property\n            // initializer or constructor respectively.\n            if (Constructor.getDefaultProps) {\n                Constructor.getDefaultProps.isReactClassApproved = {};\n            }\n            if (Constructor.prototype.getInitialState) {\n                Constructor.prototype.getInitialState.isReactClassApproved = {};\n            }\n        }\n        _invariant(Constructor.prototype.render, \"createClass(...): Class specification must implement a `render` method.\");\n        if (true) {\n            warning(!Constructor.prototype.componentShouldUpdate, \"%s has a method called \" + \"componentShouldUpdate(). Did you mean shouldComponentUpdate()? \" + \"The name is phrased as a question because the function is \" + \"expected to return a value.\", spec.displayName || \"A component\");\n            warning(!Constructor.prototype.componentWillRecieveProps, \"%s has a method called \" + \"componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", spec.displayName || \"A component\");\n            warning(!Constructor.prototype.UNSAFE_componentWillRecieveProps, \"%s has a method called UNSAFE_componentWillRecieveProps(). \" + \"Did you mean UNSAFE_componentWillReceiveProps()?\", spec.displayName || \"A component\");\n        }\n        // Reduce time spent doing lookups by setting these on the prototype.\n        for(var methodName in ReactClassInterface){\n            if (!Constructor.prototype[methodName]) {\n                Constructor.prototype[methodName] = null;\n            }\n        }\n        return Constructor;\n    }\n    return createClass;\n}\nmodule.exports = factory;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2ZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBRUQ7QUFFQSxJQUFJQSxVQUFVQyxtQkFBT0EsQ0FBQztBQUV0QiwwQkFBMEI7QUFFMUIsSUFBSUMsY0FBYyxDQUFDO0FBRW5CLElBQUlDLElBQXlCLEVBQWM7SUFDekNDLE9BQU9DLE1BQU0sQ0FBQ0g7QUFDaEI7QUFFQSxJQUFJSSxpQkFBaUIsU0FBU0EsZUFBZUMsTUFBTSxHQUFHO0FBRXRELElBQUlKLElBQXlCLEVBQWM7SUFDekNHLGlCQUFpQixTQUFTQSxlQUFlQyxNQUFNO1FBQzdDLElBQUlBLFdBQVdDLFdBQVc7WUFDeEIsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO0lBQ0Y7QUFDRjtBQUVBLFNBQVNDLFdBQVdDLFNBQVMsRUFBRUosTUFBTSxFQUFFSyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUNyRFgsZUFBZUM7SUFFZixJQUFJLENBQUNJLFdBQVc7UUFDZCxJQUFJTztRQUNKLElBQUlYLFdBQVdDLFdBQVc7WUFDeEJVLFFBQVEsSUFBSVQsTUFBTSx1RUFBdUU7UUFDM0YsT0FBTztZQUNMLElBQUlVLE9BQU87Z0JBQUNQO2dCQUFHQztnQkFBR0M7Z0JBQUdDO2dCQUFHQztnQkFBR0M7YUFBRTtZQUM3QixJQUFJRyxXQUFXO1lBQ2ZGLFFBQVEsSUFBSVQsTUFBTUYsT0FBT2MsT0FBTyxDQUFDLE9BQU87Z0JBQ3RDLE9BQU9GLElBQUksQ0FBQ0MsV0FBVztZQUN6QjtZQUNBRixNQUFNSSxJQUFJLEdBQUc7UUFDZjtRQUVBSixNQUFNSyxXQUFXLEdBQUcsR0FBRyw0Q0FBNEM7UUFDbkUsTUFBTUw7SUFDUjtBQUNGO0FBRUEsSUFBSU0sVUFBVSxZQUFXO0FBRXpCLElBQUlyQixJQUF5QixFQUFjO0lBQ3pDLElBQUlzQixlQUFlLFNBQVNBLGFBQWFs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Q25DLE1BQU0sRUFDNUI7UUFHRixJQUFJekQsSUFBeUIsRUFBYztZQUN6Q3FCLFFBQ0UsQ0FBQ29ELFlBQVltQixTQUFTLENBQUNxRCxxQkFBcUIsRUFDNUMsNEJBQ0Usb0VBQ0EsK0RBQ0EsK0JBQ0Z6RCxLQUFLaEIsV0FBVyxJQUFJO1lBRXRCbkQsUUFDRSxDQUFDb0QsWUFBWW1CLFNBQVMsQ0FBQ3NELHlCQUF5QixFQUNoRCw0QkFDRSwwRUFDRjFELEtBQUtoQixXQUFXLElBQUk7WUFFdEJuRCxRQUNFLENBQUNvRCxZQUFZbUIsU0FBUyxDQUFDdUQsZ0NBQWdDLEVBQ3ZELGdFQUNFLG9EQUNGM0QsS0FBS2hCLFdBQVcsSUFBSTtRQUV4QjtRQUVBLHFFQUFxRTtRQUNyRSxJQUFLLElBQUk0RSxjQUFjcEcsb0JBQXFCO1lBQzFDLElBQUksQ0FBQ3lCLFlBQVltQixTQUFTLENBQUN3RCxXQUFXLEVBQUU7Z0JBQ3RDM0UsWUFBWW1CLFNBQVMsQ0FBQ3dELFdBQVcsR0FBRztZQUN0QztRQUNGO1FBRUEsT0FBTzNFO0lBQ1Q7SUFFQSxPQUFPOEQ7QUFDVDtBQUVBYyxPQUFPQyxPQUFPLEdBQUczRyIsInNvdXJjZXMiOlsid2VicGFjazovL3BheWxvYWQtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcz9jMjcwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIC0tIElubGluZWQgZnJvbSBmYmpzIC0tXG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9pbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpe307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC8tLSBJbmxpbmVkIGZyb20gZmJqcyAtLVxuXG52YXIgTUlYSU5TX0tFWSA9ICdtaXhpbnMnO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGFub255bW91cyBmdW5jdGlvbnMgd2hpY2ggZG8gbm90XG4vLyBoYXZlIC5uYW1lIHNldCB0byB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgYmVpbmcgYXNzaWduZWQgdG8uXG5mdW5jdGlvbiBpZGVudGl0eShmbikge1xuICByZXR1cm4gZm47XG59XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn0gZWxzZSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG59XG5cbmZ1bmN0aW9uIGZhY3RvcnkoUmVhY3RDb21wb25lbnQsIGlzVmFsaWRFbGVtZW50LCBSZWFjdE5vb3BVcGRhdGVRdWV1ZSkge1xuICAvKipcbiAgICogUG9saWNpZXMgdGhhdCBkZXNjcmliZSBtZXRob2RzIGluIGBSZWFjdENsYXNzSW50ZXJmYWNlYC5cbiAgICovXG5cbiAgdmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbiAgLyoqXG4gICAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gICAqIG9yIGhvc3QgY29tcG9uZW50cy5cbiAgICpcbiAgICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q2xhc3NgLCBwYXNzIGEgc3BlY2lmaWNhdGlvbiBvZlxuICAgKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gICAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICAgKlxuICAgKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIHJldHVybiA8ZGl2PkhlbGxvIFdvcmxkPC9kaXY+O1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gICAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gICAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICAgKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAqXG4gICAqIEBpbnRlcmZhY2UgUmVhY3RDbGFzc0ludGVyZmFjZVxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhciBSZWFjdENsYXNzSW50ZXJmYWNlID0ge1xuICAgIC8qKlxuICAgICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIG1peGluczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgICAqIHRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIGl0cyBwcm90b3R5cGUgKHN0YXRpYyBtZXRob2RzKS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgc3RhdGljczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHByb3BUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbnRleHRUeXBlczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyB0aGlzIGNvbXBvbmVudCBzZXRzIGZvciBpdHMgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLy8gPT09PSBEZWZpbml0aW9uIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAgICogYHRoaXMucHJvcHNgIGlmIHRoYXQgcHJvcCBpcyBub3Qgc3BlY2lmaWVkIChpLmUuIHVzaW5nIGFuIGBpbmAgY2hlY2spLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgICAqIG9uIGB0aGlzLnN0YXRlYCBvciB1c2UgYHRoaXMuc2V0U3RhdGVgLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldERlZmF1bHRQcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAgICpcbiAgICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIHJldHVybiB7XG4gICAgICogICAgICAgaXNPbjogZmFsc2UsXG4gICAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldEluaXRpYWxTdGF0ZTogJ0RFRklORV9NQU5ZX01FUkdFRCcsXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0Q2hpbGRDb250ZXh0OiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIFVzZXMgcHJvcHMgZnJvbSBgdGhpcy5wcm9wc2AgYW5kIHN0YXRlIGZyb20gYHRoaXMuc3RhdGVgIHRvIHJlbmRlciB0aGVcbiAgICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIE5vIGd1YXJhbnRlZXMgYXJlIG1hZGUgYWJvdXQgd2hlbiBvciBob3cgb2Z0ZW4gdGhpcyBtZXRob2QgaXMgaW52b2tlZCwgc29cbiAgICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAgICogQHJlcXVpcmVkXG4gICAgICovXG4gICAgcmVuZGVyOiAnREVGSU5FX09OQ0UnLFxuXG4gICAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICAgKlxuICAgICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgICAqICAgICB9KTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAgICogdXBkYXRlLlxuICAgICAqXG4gICAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGU6ICdERUZJTkVfT05DRScsXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgICAqIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZW1lbnQgZm9yIChkZXByZWNhdGVkKSBgY29tcG9uZW50V2lsbE1vdW50YC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgKGRlcHJlY2F0ZWQpIGBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzYC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZW1lbnQgZm9yIChkZXByZWNhdGVkKSBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKiBAb3ZlcnJpZGFibGVcbiAgICAgKi9cbiAgICB1cGRhdGVDb21wb25lbnQ6ICdPVkVSUklERV9CQVNFJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIFJlYWN0Q2xhc3NJbnRlcmZhY2UgYnV0IGZvciBzdGF0aWMgbWV0aG9kcy5cbiAgICovXG4gIHZhciBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlID0ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYWZ0ZXIgYSBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIGFuZCB3aGVuIGl0XG4gICAgICogcmVjZWl2ZXMgbmV3IHByb3BzLiBSZXR1cm4gYW4gb2JqZWN0IHRvIHVwZGF0ZSBzdGF0ZSBpbiByZXNwb25zZSB0b1xuICAgICAqIHByb3AgY2hhbmdlcy4gUmV0dXJuIG51bGwgdG8gaW5kaWNhdGUgbm8gY2hhbmdlIHRvIHN0YXRlLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0IGlzIHJldHVybmVkLCBpdHMga2V5cyB3aWxsIGJlIG1lcmdlZCBpbnRvIHRoZSBleGlzdGluZyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdCB8fCBudWxsfVxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogJ0RFRklORV9NQU5ZX01FUkdFRCdcbiAgfTtcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAgICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAgICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAgICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICAgKi9cbiAgdmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0sXG4gICAgbWl4aW5zOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgICBpZiAobWl4aW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICBjaGlsZENvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIGNvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLFxuICAgICAgICBjb250ZXh0VHlwZXNcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oXG4gICAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLFxuICAgICAgICAgIGdldERlZmF1bHRQcm9wc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgJ3Byb3AnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gICAgfSxcbiAgICBhdXRvYmluZDogZnVuY3Rpb24oKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIF9pbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICB0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICtcbiAgICAgICAgICAgICAgJ1JlYWN0LlByb3BUeXBlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLFxuICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV1cbiAgICAgIDogbnVsbDtcblxuICAgIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnLFxuICAgICAgICAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgK1xuICAgICAgICAgICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICtcbiAgICAgICAgICAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuICAgICAgICAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgK1xuICAgICAgICAgICd0byBhIG1peGluLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICAgKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGlzTWl4aW5WYWxpZCxcbiAgICAgICAgICAgIFwiJXM6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsIFwiICtcbiAgICAgICAgICAgICAgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArXG4gICAgICAgICAgICAgICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgK1xuICAgICAgICAgICAgICAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJyxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcbiAgICAgICAgICAgIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICB0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJyxcbiAgICAgIFwiUmVhY3RDbGFzczogWW91J3JlIGF0dGVtcHRpbmcgdG8gXCIgK1xuICAgICAgICAndXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgJyArXG4gICAgICAgICdyZWd1bGFyIG9iamVjdC4nXG4gICAgKTtcbiAgICBfaW52YXJpYW50KFxuICAgICAgIWlzVmFsaWRFbGVtZW50KHNwZWMpLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nXG4gICAgKTtcblxuICAgIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gICAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gICAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gICAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gICAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9XG4gICAgICAgICAgaXNGdW5jdGlvbiAmJlxuICAgICAgICAgICFpc1JlYWN0Q2xhc3NNZXRob2QgJiZcbiAgICAgICAgICAhaXNBbHJlYWR5RGVmaW5lZCAmJlxuICAgICAgICAgIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgICAgIGlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICAgICAgIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fFxuICAgICAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyksXG4gICAgICAgICAgICAgICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArXG4gICAgICAgICAgICAgICAgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLFxuICAgICAgICAgICAgICBzcGVjUG9saWN5LFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgaWYgKCFzdGF0aWNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSZXNlcnZlZCA9IG5hbWUgaW4gUkVTRVJWRURfU1BFQ19LRVlTO1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgIWlzUmVzZXJ2ZWQsXG4gICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGEgcmVzZXJ2ZWQgJyArXG4gICAgICAgICAgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICtcbiAgICAgICAgICAnYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSAnICtcbiAgICAgICAgICAnY29uc3RydWN0b3IuJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcblxuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICAgICAgPyBSZWFjdENsYXNzU3RhdGljSW50ZXJmYWNlW25hbWVdXG4gICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZX01FUkdFRCcsXG4gICAgICAgICAgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArXG4gICAgICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArXG4gICAgICAgICAgICAnZHVlIHRvIGEgbWl4aW4uJyxcbiAgICAgICAgICBuYW1lXG4gICAgICAgICk7XG5cbiAgICAgICAgQ29uc3RydWN0b3JbbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3RvcltuYW1lXSwgcHJvcGVydHkpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAgICogQHJldHVybiB7b2JqZWN0fSBvbmUgYWZ0ZXIgaXQgaGFzIGJlZW4gbXV0YXRlZCB0byBjb250YWluIGV2ZXJ5dGhpbmcgaW4gdHdvLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAgIF9pbnZhcmlhbnQoXG4gICAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLidcbiAgICApO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgICAgaWYgKHR3by5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgb25lW2tleV0gPT09IHVuZGVmaW5lZCxcbiAgICAgICAgICAnbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICtcbiAgICAgICAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogYCVzYC4gVGhpcyBjb25mbGljdCAnICtcbiAgICAgICAgICAgICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArXG4gICAgICAgICAgICAnZ2V0SW5pdGlhbFN0YXRlKCkgb3IgZ2V0RGVmYXVsdFByb3BzKCkgbWV0aG9kcyByZXR1cm5pbmcgb2JqZWN0cyAnICtcbiAgICAgICAgICAgICd3aXRoIGNsYXNoaW5nIGtleXMuJyxcbiAgICAgICAgICBrZXlcbiAgICAgICAgKTtcbiAgICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgdmFyIGMgPSB7fTtcbiAgICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYSBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCkge1xuICAgIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMpIHtcbiAgICAgICAgZm9yIChcbiAgICAgICAgICB2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLFxuICAgICAgICAgICAgX2tleSA9IDE7XG4gICAgICAgICAgX2tleSA8IF9sZW47XG4gICAgICAgICAgX2tleSsrXG4gICAgICAgICkge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAgIC8vIGxldCdzIHdhcm4uXG4gICAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAgICAgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJyxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYWxsIGF1dG8tYm91bmQgbWV0aG9kcyBpbiBhIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICAgKi9cbiAgZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIGF1dG9CaW5kS2V5ID0gcGFpcnNbaV07XG4gICAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIElzTW91bnRlZFByZU1peGluID0ge1xuICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgSXNNb3VudGVkUG9zdE1peGluID0ge1xuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBtb3JlIHRvIHRoZSBSZWFjdENsYXNzIGJhc2UgY2xhc3MuIFRoZXNlIGFyZSBhbGwgbGVnYWN5IGZlYXR1cmVzIGFuZFxuICAgKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NNaXhpbiA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICAgKiB0eXBlIHNpZ25hdHVyZSBhbmQgdGhlIG9ubHkgdXNlIGNhc2UgZm9yIHRoaXMsIGlzIHRvIGF2b2lkIHRoYXQuXG4gICAgICovXG4gICAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihuZXdTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKHRoaXMsIG5ld1N0YXRlLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQGZpbmFsXG4gICAgICovXG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQsXG4gICAgICAgICAgJyVzOiBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwICcgK1xuICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gY29tcG9uZW50V2lsbFVubW91bnQgdG8gJyArXG4gICAgICAgICAgICAncHJldmVudCBtZW1vcnkgbGVha3MuJyxcbiAgICAgICAgICAodGhpcy5jb25zdHJ1Y3RvciAmJiB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB8fFxuICAgICAgICAgICAgdGhpcy5uYW1lIHx8XG4gICAgICAgICAgICAnQ29tcG9uZW50J1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9fZGlkV2FybklzTW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gISF0aGlzLl9faXNNb3VudGVkO1xuICAgIH1cbiAgfTtcblxuICB2YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uKCkge307XG4gIF9hc3NpZ24oXG4gICAgUmVhY3RDbGFzc0NvbXBvbmVudC5wcm90b3R5cGUsXG4gICAgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q2xhc3NNaXhpblxuICApO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29tcG9zaXRlIGNvbXBvbmVudCBjbGFzcyBnaXZlbiBhIGNsYXNzIHNwZWNpZmljYXRpb24uXG4gICAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVjbGFzc1xuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNsYXNzKHNwZWMpIHtcbiAgICAvLyBUbyBrZWVwIG91ciB3YXJuaW5ncyBtb3JlIHVuZGVyc3RhbmRhYmxlLCB3ZSdsbCB1c2UgYSBsaXR0bGUgaGFjayBoZXJlIHRvXG4gICAgLy8gZW5zdXJlIHRoYXQgQ29uc3RydWN0b3IubmFtZSAhPT0gJ0NvbnN0cnVjdG9yJy4gVGhpcyBtYWtlcyBzdXJlIHdlIGRvbid0XG4gICAgLy8gdW5uZWNlc3NhcmlseSBpZGVudGlmeSBhIGNsYXNzIHdpdGhvdXQgZGlzcGxheU5hbWUgYXMgJ0NvbnN0cnVjdG9yJy5cbiAgICB2YXIgQ29uc3RydWN0b3IgPSBpZGVudGl0eShmdW5jdGlvbihwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAgICAgLy8gVGhpcyBjb25zdHJ1Y3RvciBnZXRzIG92ZXJyaWRkZW4gYnkgbW9ja3MuIFRoZSBhcmd1bWVudCBpcyB1c2VkXG4gICAgICAvLyBieSBtb2NrcyB0byBhc3NlcnQgb24gd2hhdCBnZXRzIG1vdW50ZWQuXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgdGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLFxuICAgICAgICAgICdTb21ldGhpbmcgaXMgY2FsbGluZyBhIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseS4gVXNlIGEgZmFjdG9yeSBvciAnICtcbiAgICAgICAgICAgICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdpcmUgdXAgYXV0by1iaW5kaW5nXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRQYWlycy5sZW5ndGgpIHtcbiAgICAgICAgYmluZEF1dG9CaW5kTWV0aG9kcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgICAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG5cbiAgICAgIC8vIFJlYWN0Q2xhc3NlcyBkb2Vzbid0IGhhdmUgY29uc3RydWN0b3JzLiBJbnN0ZWFkLCB0aGV5IHVzZSB0aGVcbiAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSBhbmQgY29tcG9uZW50V2lsbE1vdW50IG1ldGhvZHMgZm9yIGluaXRpYWxpemF0aW9uLlxuXG4gICAgICB2YXIgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSksXG4gICAgICAgICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH0pO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENsYXNzQ29tcG9uZW50KCk7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9fcmVhY3RBdXRvQmluZFBhaXJzID0gW107XG5cbiAgICBpbmplY3RlZE1peGlucy5mb3JFYWNoKG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQcmVNaXhpbik7XG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBJc01vdW50ZWRQb3N0TWl4aW4pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyLFxuICAgICAgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJ1xuICAgICk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICtcbiAgICAgICAgICAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgK1xuICAgICAgICAgICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLFxuICAgICAgICBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCdcbiAgICAgICk7XG4gICAgICB3YXJuaW5nKFxuICAgICAgICAhQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsXG4gICAgICAgICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgK1xuICAgICAgICAgICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyxcbiAgICAgICAgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gJyArXG4gICAgICAgICAgJ0RpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsYXNzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG4iXSwibmFtZXMiOlsiX2Fzc2lnbiIsInJlcXVpcmUiLCJlbXB0eU9iamVjdCIsInByb2Nlc3MiLCJPYmplY3QiLCJmcmVlemUiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsInVuZGVmaW5lZCIsIkVycm9yIiwiX2ludmFyaWFudCIsImNvbmRpdGlvbiIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImVycm9yIiwiYXJncyIsImFyZ0luZGV4IiwicmVwbGFjZSIsIm5hbWUiLCJmcmFtZXNUb1BvcCIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiQXJyYXkiLCJfa2V5IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJhcHBseSIsImNvbmNhdCIsIk1JWElOU19LRVkiLCJpZGVudGl0eSIsImZuIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJwcm9wIiwiY29udGV4dCIsImNoaWxkQ29udGV4dCIsImZhY3RvcnkiLCJSZWFjdENvbXBvbmVudCIsImlzVmFsaWRFbGVtZW50IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJpbmplY3RlZE1peGlucyIsIlJlYWN0Q2xhc3NJbnRlcmZhY2UiLCJtaXhpbnMiLCJzdGF0aWNzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJnZXRJbml0aWFsU3RhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJyZW5kZXIiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIlJlYWN0Q2xhc3NTdGF0aWNJbnRlcmZhY2UiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJSRVNFUlZFRF9TUEVDX0tFWVMiLCJkaXNwbGF5TmFtZSIsIkNvbnN0cnVjdG9yIiwiaSIsIm1peFNwZWNJbnRvQ29tcG9uZW50IiwidmFsaWRhdGVUeXBlRGVmIiwiY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24iLCJtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudCIsImF1dG9iaW5kIiwidHlwZURlZiIsImxvY2F0aW9uIiwicHJvcE5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUiLCJpc0FscmVhZHlEZWZpbmVkIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJ0eXBlb2ZTcGVjIiwiaXNNaXhpblZhbGlkIiwicHJvdG8iLCJwcm90b3R5cGUiLCJhdXRvQmluZFBhaXJzIiwiX19yZWFjdEF1dG9CaW5kUGFpcnMiLCJwcm9wZXJ0eSIsImlzUmVhY3RDbGFzc01ldGhvZCIsImlzRnVuY3Rpb24iLCJzaG91bGRBdXRvQmluZCIsInB1c2giLCJjcmVhdGVDaGFpbmVkRnVuY3Rpb24iLCJpc1Jlc2VydmVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsImtleSIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImNvbXBvbmVudCIsIm1ldGhvZCIsImJvdW5kTWV0aG9kIiwiYmluZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJjb21wb25lbnROYW1lIiwiY29uc3RydWN0b3IiLCJfYmluZCIsIm5ld1RoaXMiLCJyZWJvdW5kTWV0aG9kIiwiYmluZEF1dG9CaW5kTWV0aG9kcyIsInBhaXJzIiwiYXV0b0JpbmRLZXkiLCJJc01vdW50ZWRQcmVNaXhpbiIsIl9faXNNb3VudGVkIiwiSXNNb3VudGVkUG9zdE1peGluIiwicmVwbGFjZVN0YXRlIiwibmV3U3RhdGUiLCJjYWxsYmFjayIsInVwZGF0ZXIiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiaXNNb3VudGVkIiwiX19kaWRXYXJuSXNNb3VudGVkIiwiUmVhY3RDbGFzc0NvbXBvbmVudCIsImNyZWF0ZUNsYXNzIiwicHJvcHMiLCJyZWZzIiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJfaXNNb2NrRnVuY3Rpb24iLCJpc0FycmF5IiwiZm9yRWFjaCIsImRlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwibWV0aG9kTmFtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/create-react-class/factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/create-react-class/index.js":
/*!**************************************************!*\
  !*** ./node_modules/create-react-class/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar factory = __webpack_require__(/*! ./factory */ \"(ssr)/./node_modules/create-react-class/factory.js\");\nif (typeof React === \"undefined\") {\n    throw Error(\"create-react-class could not find the React object. If you are using script tags, \" + \"make sure that React is being loaded before create-react-class.\");\n}\n// Hack to grab NoopUpdateQueue from isomorphic React\nvar ReactNoopUpdateQueue = new React.Component().updater;\nmodule.exports = factory(React.Component, React.isValidElement, ReactNoopUpdateQueue);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Q0FNQyxHQUVEO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsVUFBVUQsbUJBQU9BLENBQUM7QUFFdEIsSUFBSSxPQUFPRCxVQUFVLGFBQWE7SUFDaEMsTUFBTUcsTUFDSix1RkFDRTtBQUVOO0FBRUEscURBQXFEO0FBQ3JELElBQUlDLHVCQUF1QixJQUFJSixNQUFNSyxTQUFTLEdBQUdDLE9BQU87QUFFeERDLE9BQU9DLE9BQU8sR0FBR04sUUFDZkYsTUFBTUssU0FBUyxFQUNmTCxNQUFNUyxjQUFjLEVBQ3BCTCIsInNvdXJjZXMiOlsid2VicGFjazovL3BheWxvYWQtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvaW5kZXguanM/YmQ5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yeScpO1xuXG5pZiAodHlwZW9mIFJlYWN0ID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBFcnJvcihcbiAgICAnY3JlYXRlLXJlYWN0LWNsYXNzIGNvdWxkIG5vdCBmaW5kIHRoZSBSZWFjdCBvYmplY3QuIElmIHlvdSBhcmUgdXNpbmcgc2NyaXB0IHRhZ3MsICcgK1xuICAgICAgJ21ha2Ugc3VyZSB0aGF0IFJlYWN0IGlzIGJlaW5nIGxvYWRlZCBiZWZvcmUgY3JlYXRlLXJlYWN0LWNsYXNzLidcbiAgKTtcbn1cblxuLy8gSGFjayB0byBncmFiIE5vb3BVcGRhdGVRdWV1ZSBmcm9tIGlzb21vcnBoaWMgUmVhY3RcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS51cGRhdGVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gIFJlYWN0LkNvbXBvbmVudCxcbiAgUmVhY3QuaXNWYWxpZEVsZW1lbnQsXG4gIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlXG4pO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsImZhY3RvcnkiLCJFcnJvciIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiQ29tcG9uZW50IiwidXBkYXRlciIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1ZhbGlkRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/create-react-class/index.js\n");

/***/ })

};
;