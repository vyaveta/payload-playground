"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/groq-js";
exports.ids = ["vendor-chunks/groq-js"];
exports.modules = {

/***/ "(ssr)/./node_modules/groq-js/dist/1.mjs":
/*!*****************************************!*\
  !*** ./node_modules/groq-js/dist/1.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTime: () => (/* binding */ DateTime),\n/* harmony export */   evaluate: () => (/* binding */ evaluateQuery),\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\nvar __defProp$5 = Object.defineProperty;\nvar __defNormalProp$5 = (obj, key, value)=>key in obj ? __defProp$5(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$5 = (obj, key, value)=>{\n    __defNormalProp$5(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nfunction escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction pathRegExp(pattern) {\n    const re = [];\n    for (const part of pattern.split(\".\")){\n        if (part === \"*\") {\n            re.push(\"[^.]+\");\n        } else if (part === \"**\") {\n            re.push(\".*\");\n        } else {\n            re.push(escapeRegExp(part));\n        }\n    }\n    return new RegExp(\"^\".concat(re.join(\".\"), \"$\"));\n}\nclass Path {\n    constructor(pattern){\n        __publicField$5(this, \"pattern\");\n        __publicField$5(this, \"patternRe\");\n        this.pattern = pattern;\n        this.patternRe = pathRegExp(pattern);\n    }\n    matches(str) {\n        return this.patternRe.test(str);\n    }\n    toJSON() {\n        return this.pattern;\n    }\n}\nvar __defProp$4 = Object.defineProperty;\nvar __defNormalProp$4 = (obj, key, value)=>key in obj ? __defProp$4(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$4 = (obj, key, value)=>{\n    __defNormalProp$4(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StreamValue {\n    constructor(generator){\n        __publicField$4(this, \"type\", \"stream\");\n        __publicField$4(this, \"generator\");\n        __publicField$4(this, \"ticker\");\n        __publicField$4(this, \"isDone\");\n        __publicField$4(this, \"data\");\n        this.generator = generator;\n        this.ticker = null;\n        this.isDone = false;\n        this.data = [];\n    }\n    // eslint-disable-next-line class-methods-use-this\n    isArray() {\n        return true;\n    }\n    async get() {\n        const result = [];\n        for await (const value of this){\n            result.push(await value.get());\n        }\n        return result;\n    }\n    async *[Symbol.asyncIterator]() {\n        let i = 0;\n        while(true){\n            for(; i < this.data.length; i++){\n                yield this.data[i];\n            }\n            if (this.isDone) {\n                return;\n            }\n            await this._nextTick();\n        }\n    }\n    _nextTick() {\n        if (this.ticker) {\n            return this.ticker;\n        }\n        let currentResolver;\n        const setupTicker = ()=>{\n            this.ticker = new Promise((resolve)=>{\n                currentResolver = resolve;\n            });\n        };\n        const tick = ()=>{\n            currentResolver();\n            setupTicker();\n        };\n        const fetch = async ()=>{\n            for await (const value of this.generator()){\n                this.data.push(value);\n                tick();\n            }\n            this.isDone = true;\n            tick();\n        };\n        setupTicker();\n        fetch();\n        return this.ticker;\n    }\n}\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\nfunction parseRFC3339(str) {\n    if (RFC3339_REGEX.test(str)) {\n        return new Date(str);\n    }\n    return null;\n}\nfunction formatRFC3339(d) {\n    const year = addLeadingZero(d.getUTCFullYear(), 4);\n    const month = addLeadingZero(d.getUTCMonth() + 1, 2);\n    const day = addLeadingZero(d.getUTCDate(), 2);\n    const hour = addLeadingZero(d.getUTCHours(), 2);\n    const minute = addLeadingZero(d.getUTCMinutes(), 2);\n    const second = addLeadingZero(d.getUTCSeconds(), 2);\n    let fractionalSecond = \"\";\n    const millis = d.getMilliseconds();\n    if (millis != 0) {\n        fractionalSecond = \".\".concat(addLeadingZero(millis, 3));\n    }\n    return \"\".concat(year, \"-\").concat(month, \"-\").concat(day, \"T\").concat(hour, \":\").concat(minute, \":\").concat(second).concat(fractionalSecond, \"Z\");\n}\nfunction addLeadingZero(num, targetLength) {\n    let str = num.toString();\n    while(str.length < targetLength){\n        str = \"0\".concat(str);\n    }\n    return str;\n}\nvar __defProp$3 = Object.defineProperty;\nvar __defNormalProp$3 = (obj, key, value)=>key in obj ? __defProp$3(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$3 = (obj, key, value)=>{\n    __defNormalProp$3(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass StaticValue {\n    constructor(data, type){\n        __publicField$3(this, \"data\");\n        __publicField$3(this, \"type\");\n        this.data = data;\n        this.type = type;\n    }\n    isArray() {\n        return this.type === \"array\";\n    }\n    // eslint-disable-next-line require-await\n    async get() {\n        return this.data;\n    }\n    [Symbol.asyncIterator]() {\n        if (Array.isArray(this.data)) {\n            return function*(data) {\n                for (const element of data){\n                    yield fromJS(element);\n                }\n            }(this.data);\n        }\n        throw new Error(\"Cannot iterate over: \".concat(this.type));\n    }\n}\nconst NULL_VALUE = new StaticValue(null, \"null\");\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\nclass DateTime {\n    constructor(date){\n        __publicField$3(this, \"date\");\n        this.date = date;\n    }\n    static parseToValue(str) {\n        const date = parseRFC3339(str);\n        if (date) {\n            return new StaticValue(new DateTime(date), \"datetime\");\n        }\n        return NULL_VALUE;\n    }\n    equals(other) {\n        return this.date.getTime() == other.date.getTime();\n    }\n    add(secs) {\n        const copy = new Date(this.date.getTime());\n        copy.setTime(copy.getTime() + secs * 1e3);\n        return new DateTime(copy);\n    }\n    difference(other) {\n        return (this.date.getTime() - other.date.getTime()) / 1e3;\n    }\n    compareTo(other) {\n        return this.date.getTime() - other.date.getTime();\n    }\n    toString() {\n        return formatRFC3339(this.date);\n    }\n    toJSON() {\n        return this.toString();\n    }\n}\nfunction fromNumber(num) {\n    if (Number.isFinite(num)) {\n        return new StaticValue(num, \"number\");\n    }\n    return NULL_VALUE;\n}\nfunction fromString(str) {\n    return new StaticValue(str, \"string\");\n}\nfunction fromDateTime(dt) {\n    return new StaticValue(dt, \"datetime\");\n}\nfunction fromPath(path) {\n    return new StaticValue(path, \"path\");\n}\nfunction isIterator(obj) {\n    return obj && typeof obj.next === \"function\";\n}\nfunction fromJS(val) {\n    if (isIterator(val)) {\n        return new StreamValue(async function*() {\n            for await (const value of val){\n                yield fromJS(value);\n            }\n        });\n    } else if (val === null || val === void 0) {\n        return NULL_VALUE;\n    }\n    return new StaticValue(val, getType(val));\n}\nfunction getType(data) {\n    if (data === null || typeof data === \"undefined\") {\n        return \"null\";\n    }\n    if (Array.isArray(data)) {\n        return \"array\";\n    }\n    if (data instanceof Path) {\n        return \"path\";\n    }\n    if (data instanceof DateTime) {\n        return \"datetime\";\n    }\n    return typeof data;\n}\nfunction isEqual(a, b) {\n    if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\n        return a.data === b.data;\n    }\n    if (a.type === \"datetime\" && b.type === \"datetime\") {\n        return a.data.equals(b.data);\n    }\n    return false;\n}\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\nconst MAX_TERM_LENGTH = 1024;\nfunction matchText(tokens, patterns) {\n    if (tokens.length === 0 || patterns.length === 0) {\n        return false;\n    }\n    return patterns.every((pattern)=>pattern(tokens));\n}\nfunction matchTokenize(text) {\n    return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\n}\nfunction matchAnalyzePattern(text) {\n    const termsRe = matchPatternRegex(text);\n    return termsRe.map((re)=>(tokens)=>tokens.some((token)=>re.test(token)));\n}\nfunction matchPatternRegex(text) {\n    const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\n    return terms.map((term)=>new RegExp(\"^\".concat(term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\"), \"$\"), \"i\"));\n}\nasync function gatherText(value, cb) {\n    if (value.type === \"string\") {\n        cb(value.data);\n        return true;\n    }\n    if (value.isArray()) {\n        let success = true;\n        for await (const part of value){\n            if (part.type === \"string\") {\n                cb(part.data);\n            } else {\n                success = false;\n            }\n        }\n        return success;\n    }\n    return false;\n}\nconst TYPE_ORDER = {\n    datetime: 1,\n    number: 2,\n    string: 3,\n    boolean: 4\n};\nfunction partialCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    if (aType !== bType) {\n        return null;\n    }\n    switch(aType){\n        case \"number\":\n        case \"boolean\":\n            return a - b;\n        case \"string\":\n            if (a < b) return -1;\n            if (a > b) return 1;\n            return 0;\n        case \"datetime\":\n            return a.compareTo(b);\n        default:\n            return null;\n    }\n}\nfunction totalCompare(a, b) {\n    const aType = getType(a);\n    const bType = getType(b);\n    const aTypeOrder = TYPE_ORDER[aType] || 100;\n    const bTypeOrder = TYPE_ORDER[bType] || 100;\n    if (aTypeOrder !== bTypeOrder) {\n        return aTypeOrder - bTypeOrder;\n    }\n    let result = partialCompare(a, b);\n    if (result === null) {\n        result = 0;\n    }\n    return result;\n}\nconst operators = {\n    \"==\": function eq(left, right) {\n        return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"!=\": function neq(left, right) {\n        return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\n    },\n    \">\": function gt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result > 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \">=\": function gte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<\": function lt(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"<=\": function lte(left, right) {\n        if (left.type === \"stream\" || right.type === \"stream\") return NULL_VALUE;\n        const result = partialCompare(left.data, right.data);\n        if (result === null) {\n            return NULL_VALUE;\n        }\n        return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    // eslint-disable-next-line func-name-matching\n    in: async function inop(left, right) {\n        if (right.type === \"path\") {\n            if (left.type !== \"string\") {\n                return NULL_VALUE;\n            }\n            return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\n        }\n        if (right.isArray()) {\n            for await (const b of right){\n                if (isEqual(left, b)) {\n                    return TRUE_VALUE;\n                }\n            }\n            return FALSE_VALUE;\n        }\n        return NULL_VALUE;\n    },\n    match: async function match(left, right) {\n        let tokens = [];\n        let patterns = [];\n        await gatherText(left, (part)=>{\n            tokens = tokens.concat(matchTokenize(part));\n        });\n        const didSucceed = await gatherText(right, (part)=>{\n            patterns = patterns.concat(matchAnalyzePattern(part));\n        });\n        if (!didSucceed) {\n            return FALSE_VALUE;\n        }\n        const matched = matchText(tokens, patterns);\n        return matched ? TRUE_VALUE : FALSE_VALUE;\n    },\n    \"+\": function plus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data + right.data);\n        }\n        if (left.type === \"string\" && right.type === \"string\") {\n            return fromString(left.data + right.data);\n        }\n        if (left.type === \"object\" && right.type === \"object\") {\n            return fromJS({\n                ...left.data,\n                ...right.data\n            });\n        }\n        if (left.type === \"array\" && right.type === \"array\") {\n            return fromJS(left.data.concat(right.data));\n        }\n        if (left.isArray() && right.isArray()) {\n            return new StreamValue(async function*() {\n                for await (const val of left){\n                    yield val;\n                }\n                for await (const val of right){\n                    yield val;\n                }\n            });\n        }\n        return NULL_VALUE;\n    },\n    \"-\": function minus(left, right) {\n        if (left.type === \"datetime\" && right.type === \"number\") {\n            return fromDateTime(left.data.add(-right.data));\n        }\n        if (left.type === \"datetime\" && right.type === \"datetime\") {\n            return fromNumber(left.data.difference(right.data));\n        }\n        if (left.type === \"number\" && right.type === \"number\") {\n            return fromNumber(left.data - right.data);\n        }\n        return NULL_VALUE;\n    },\n    \"*\": numericOperator((a, b)=>a * b),\n    \"/\": numericOperator((a, b)=>a / b),\n    \"%\": numericOperator((a, b)=>a % b),\n    \"**\": numericOperator((a, b)=>Math.pow(a, b))\n};\nfunction numericOperator(impl) {\n    return function(left, right) {\n        if (left.type === \"number\" && right.type === \"number\") {\n            const result = impl(left.data, right.data);\n            return fromNumber(result);\n        }\n        return NULL_VALUE;\n    };\n}\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value)=>key in obj ? __defProp$2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value)=>{\n    __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass Scope {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(params, source, value, context, parent){\n        __publicField$2(this, \"params\");\n        __publicField$2(this, \"source\");\n        __publicField$2(this, \"value\");\n        __publicField$2(this, \"parent\");\n        __publicField$2(this, \"context\");\n        __publicField$2(this, \"isHidden\", false);\n        this.params = params;\n        this.source = source;\n        this.value = value;\n        this.context = context;\n        this.parent = parent;\n    }\n    createNested(value) {\n        if (this.isHidden) {\n            return new Scope(this.params, this.source, value, this.context, this.parent);\n        }\n        return new Scope(this.params, this.source, value, this.context, this);\n    }\n    createHidden(value) {\n        const result = this.createNested(value);\n        result.isHidden = true;\n        return result;\n    }\n}\nfunction evaluate(node, scope) {\n    let execute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : evaluate;\n    const func = EXECUTORS[node.type];\n    return func(node, scope, execute);\n}\nfunction promiselessApply(value, cb) {\n    if (\"then\" in value) {\n        return value.then(cb);\n    }\n    return cb(value);\n}\nconst EXECUTORS = {\n    This (_, scope) {\n        return scope.value;\n    },\n    Selector () {\n        throw new Error(\"Selectors can not be evaluated\");\n    },\n    Everything (_, scope) {\n        return scope.source;\n    },\n    Parameter (_ref, scope) {\n        let { name } = _ref;\n        return fromJS(scope.params[name]);\n    },\n    Context (_ref2, scope) {\n        let { key } = _ref2;\n        if (key === \"before\" || key === \"after\") {\n            const value = scope.context[key];\n            return value || NULL_VALUE;\n        }\n        throw new Error(\"unknown context key: \".concat(key));\n    },\n    Parent (_ref3, scope) {\n        let { n } = _ref3;\n        let current = scope;\n        for(let i = 0; i < n; i++){\n            if (!current.parent) {\n                return NULL_VALUE;\n            }\n            current = current.parent;\n        }\n        return current.value;\n    },\n    OpCall (_ref4, scope, execute) {\n        let { op, left, right } = _ref4;\n        const func = operators[op];\n        if (!func) {\n            throw new Error(\"Unknown operator: \".concat(op));\n        }\n        const leftValue = execute(left, scope);\n        const rightValue = execute(right, scope);\n        if (\"then\" in leftValue || \"then\" in rightValue) {\n            return (async ()=>func(await leftValue, await rightValue))();\n        }\n        return func(leftValue, rightValue);\n    },\n    async Select (_ref5, scope, execute) {\n        let { alternatives, fallback } = _ref5;\n        for (const alt of alternatives){\n            const altCond = await execute(alt.condition, scope);\n            if (altCond.type === \"boolean\" && altCond.data === true) {\n                return execute(alt.value, scope);\n            }\n        }\n        if (fallback) {\n            return execute(fallback, scope);\n        }\n        return NULL_VALUE;\n    },\n    async InRange (_ref6, scope, execute) {\n        let { base, left, right, isInclusive } = _ref6;\n        const value = await execute(base, scope);\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        const leftCmp = partialCompare(await value.get(), await leftValue.get());\n        if (leftCmp === null) {\n            return NULL_VALUE;\n        }\n        const rightCmp = partialCompare(await value.get(), await rightValue.get());\n        if (rightCmp === null) {\n            return NULL_VALUE;\n        }\n        if (isInclusive) {\n            return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\n        }\n        return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\n    },\n    async Filter (_ref7, scope, execute) {\n        let { base, expr } = _ref7;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of baseValue){\n                const newScope = scope.createNested(elem);\n                const exprValue = await execute(expr, newScope);\n                if (exprValue.type === \"boolean\" && exprValue.data === true) {\n                    yield elem;\n                }\n            }\n        });\n    },\n    async Projection (_ref8, scope, execute) {\n        let { base, expr } = _ref8;\n        const baseValue = await execute(base, scope);\n        if (baseValue.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const newScope = scope.createNested(baseValue);\n        return execute(expr, newScope);\n    },\n    FuncCall (_ref9, scope, execute) {\n        let { func, args } = _ref9;\n        return func(args, scope, execute);\n    },\n    async PipeFuncCall (_ref10, scope, execute) {\n        let { func, base, args } = _ref10;\n        const baseValue = await execute(base, scope);\n        return func(baseValue, args, scope, execute);\n    },\n    async AccessAttribute (_ref11, scope, execute) {\n        let { base, name } = _ref11;\n        let value = scope.value;\n        if (base) {\n            value = await execute(base, scope);\n        }\n        if (value.type === \"object\") {\n            if (value.data.hasOwnProperty(name)) {\n                return fromJS(value.data[name]);\n            }\n        }\n        return NULL_VALUE;\n    },\n    async AccessElement (_ref12, scope, execute) {\n        let { base, index } = _ref12;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const data = await baseValue.get();\n        const finalIndex = index < 0 ? index + data.length : index;\n        return fromJS(data[finalIndex]);\n    },\n    async Slice (_ref13, scope, execute) {\n        let { base, left, right, isInclusive } = _ref13;\n        const baseValue = await execute(base, scope);\n        if (!baseValue.isArray()) {\n            return NULL_VALUE;\n        }\n        const array = await baseValue.get();\n        let leftIdx = left;\n        let rightIdx = right;\n        if (leftIdx < 0) {\n            leftIdx = array.length + leftIdx;\n        }\n        if (rightIdx < 0) {\n            rightIdx = array.length + rightIdx;\n        }\n        if (isInclusive) {\n            rightIdx++;\n        }\n        if (leftIdx < 0) {\n            leftIdx = 0;\n        }\n        if (rightIdx < 0) {\n            rightIdx = 0;\n        }\n        return fromJS(array.slice(leftIdx, rightIdx));\n    },\n    async Deref (_ref14, scope, execute) {\n        let { base } = _ref14;\n        const value = await execute(base, scope);\n        if (!scope.source.isArray()) {\n            return NULL_VALUE;\n        }\n        if (value.type !== \"object\") {\n            return NULL_VALUE;\n        }\n        const id = value.data._ref;\n        if (typeof id !== \"string\") {\n            return NULL_VALUE;\n        }\n        if (scope.context.dereference) {\n            return fromJS(await scope.context.dereference({\n                _ref: id\n            }));\n        }\n        for await (const doc of scope.source){\n            if (doc.type === \"object\" && id === doc.data._id) {\n                return doc;\n            }\n        }\n        return NULL_VALUE;\n    },\n    Value (_ref15) {\n        let { value } = _ref15;\n        return fromJS(value);\n    },\n    Group (_ref16, scope, execute) {\n        let { base } = _ref16;\n        return execute(base, scope);\n    },\n    async Object (_ref17, scope, execute) {\n        let { attributes } = _ref17;\n        const result = {};\n        for (const attr of attributes){\n            const attrType = attr.type;\n            switch(attr.type){\n                case \"ObjectAttributeValue\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        result[attr.name] = await value.get();\n                        break;\n                    }\n                case \"ObjectConditionalSplat\":\n                    {\n                        const cond = await execute(attr.condition, scope);\n                        if (cond.type !== \"boolean\" || cond.data === false) {\n                            continue;\n                        }\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                case \"ObjectSplat\":\n                    {\n                        const value = await execute(attr.value, scope);\n                        if (value.type === \"object\") {\n                            Object.assign(result, value.data);\n                        }\n                        break;\n                    }\n                default:\n                    throw new Error(\"Unknown node type: \".concat(attrType));\n            }\n        }\n        return fromJS(result);\n    },\n    Array (_ref18, scope, execute) {\n        let { elements } = _ref18;\n        return new StreamValue(async function*() {\n            for (const element of elements){\n                const value = await execute(element.value, scope);\n                if (element.isSplat) {\n                    if (value.isArray()) {\n                        for await (const v of value){\n                            yield v;\n                        }\n                    }\n                } else {\n                    yield value;\n                }\n            }\n        });\n    },\n    Tuple () {\n        throw new Error(\"tuples can not be evaluated\");\n    },\n    async Or (_ref19, scope, execute) {\n        let { left, right } = _ref19;\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === true) {\n                return TRUE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return FALSE_VALUE;\n    },\n    async And (_ref20, scope, execute) {\n        let { left, right } = _ref20;\n        const leftValue = await execute(left, scope);\n        const rightValue = await execute(right, scope);\n        if (leftValue.type === \"boolean\") {\n            if (leftValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (rightValue.type === \"boolean\") {\n            if (rightValue.data === false) {\n                return FALSE_VALUE;\n            }\n        }\n        if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return TRUE_VALUE;\n    },\n    async Not (_ref21, scope, execute) {\n        let { base } = _ref21;\n        const value = await execute(base, scope);\n        if (value.type !== \"boolean\") {\n            return NULL_VALUE;\n        }\n        return value.data ? FALSE_VALUE : TRUE_VALUE;\n    },\n    Neg (_ref22, scope, execute) {\n        let { base } = _ref22;\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(-value.data);\n        });\n    },\n    Pos (_ref23, scope, execute) {\n        let { base } = _ref23;\n        return promiselessApply(execute(base, scope), (value)=>{\n            if (value.type !== \"number\") {\n                return NULL_VALUE;\n            }\n            return fromNumber(value.data);\n        });\n    },\n    Asc () {\n        return NULL_VALUE;\n    },\n    Desc () {\n        return NULL_VALUE;\n    },\n    async ArrayCoerce (_ref24, scope, execute) {\n        let { base } = _ref24;\n        const value = await execute(base, scope);\n        return value.isArray() ? value : NULL_VALUE;\n    },\n    async Map (_ref25, scope, execute) {\n        let { base, expr } = _ref25;\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                yield await execute(expr, newScope);\n            }\n        });\n    },\n    async FlatMap (_ref26, scope, execute) {\n        let { base, expr } = _ref26;\n        const value = await execute(base, scope);\n        if (!value.isArray()) {\n            return NULL_VALUE;\n        }\n        return new StreamValue(async function*() {\n            for await (const elem of value){\n                const newScope = scope.createHidden(elem);\n                const innerValue = await execute(expr, newScope);\n                if (innerValue.isArray()) {\n                    for await (const inner of innerValue){\n                        yield inner;\n                    }\n                } else {\n                    yield innerValue;\n                }\n            }\n        });\n    }\n};\nfunction evaluateQuery(tree) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const root = fromJS(options.root);\n    const dataset = fromJS(options.dataset);\n    const params = {\n        ...options.params\n    };\n    const scope = new Scope(params, dataset, root, {\n        timestamp: options.timestamp || /* @__PURE__ */ new Date(),\n        identity: options.identity === void 0 ? \"me\" : options.identity,\n        sanity: options.sanity,\n        after: options.after ? fromJS(options.after) : null,\n        before: options.before ? fromJS(options.before) : null,\n        dereference: options.dereference\n    }, null);\n    return evaluate(tree, scope);\n}\nfunction canConstantEvaluate(node) {\n    switch(node.type){\n        case \"Group\":\n            return canConstantEvaluate(node.base);\n        case \"Value\":\n        case \"Parameter\":\n            return true;\n        case \"Pos\":\n        case \"Neg\":\n            return canConstantEvaluate(node.base);\n        case \"OpCall\":\n            switch(node.op){\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"%\":\n                case \"**\":\n                    return canConstantEvaluate(node.left) && canConstantEvaluate(node.right);\n                default:\n                    return false;\n            }\n        default:\n            return false;\n    }\n}\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, {\n    timestamp: /* @__PURE__ */ new Date(0),\n    identity: \"me\",\n    before: null,\n    after: null\n}, null);\nfunction tryConstantEvaluate(node) {\n    if (!canConstantEvaluate(node)) {\n        return null;\n    }\n    return constantEvaluate(node);\n}\nfunction constantEvaluate(node) {\n    const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\n    if (\"then\" in value) {\n        throw new Error(\"BUG: constant evaluate should never return a promise\");\n    }\n    return value;\n}\nasync function portableTextContent(value) {\n    if (value.type === \"object\") {\n        return blockText(value.data);\n    } else if (value.isArray()) {\n        const texts = await arrayText(value);\n        if (texts.length > 0) {\n            return texts.join(\"\\n\\n\");\n        }\n    }\n    return null;\n}\nasync function arrayText(value) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    for await (const block of value){\n        if (block.type === \"object\") {\n            const text = blockText(block.data);\n            if (text !== null) result.push(text);\n        } else if (block.isArray()) {\n            await arrayText(block, result);\n        }\n    }\n    return result;\n}\nfunction blockText(obj) {\n    if (typeof obj._type !== \"string\") return null;\n    const children = obj.children;\n    if (!Array.isArray(children)) return null;\n    let result = \"\";\n    for (const child of children){\n        if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\n            result += child.text;\n        }\n    }\n    return result;\n}\nconst BM25k = 1.2;\nasync function evaluateScore(node, scope, execute) {\n    if (node.type === \"OpCall\" && node.op === \"match\") {\n        return evaluateMatchScore(node.left, node.right, scope, execute);\n    }\n    if (node.type === \"FuncCall\" && node.name === \"boost\") {\n        const innerScore = await evaluateScore(node.args[0], scope, execute);\n        const boost = await execute(node.args[1], scope);\n        if (boost.type === \"number\" && innerScore > 0) {\n            return innerScore + boost.data;\n        }\n        return 0;\n    }\n    switch(node.type){\n        case \"Or\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                return leftScore + rightScore;\n            }\n        case \"And\":\n            {\n                const leftScore = await evaluateScore(node.left, scope, execute);\n                const rightScore = await evaluateScore(node.right, scope, execute);\n                if (leftScore === 0 || rightScore === 0) return 0;\n                return leftScore + rightScore;\n            }\n        default:\n            {\n                const res = await execute(node, scope);\n                return res.type === \"boolean\" && res.data === true ? 1 : 0;\n            }\n    }\n}\nasync function evaluateMatchScore(left, right, scope, execute) {\n    const text = await execute(left, scope);\n    const pattern = await execute(right, scope);\n    let tokens = [];\n    let terms = [];\n    await gatherText(text, (part)=>{\n        tokens = tokens.concat(matchTokenize(part));\n    });\n    const didSucceed = await gatherText(pattern, (part)=>{\n        terms = terms.concat(matchPatternRegex(part));\n    });\n    if (!didSucceed) {\n        return 0;\n    }\n    if (tokens.length === 0 || terms.length === 0) {\n        return 0;\n    }\n    let score = 0;\n    for (const re of terms){\n        const freq = tokens.reduce((c, token)=>c + (re.test(token) ? 1 : 0), 0);\n        score += freq * (BM25k + 1) / (freq + BM25k);\n    }\n    return score;\n}\nfunction hasReference(value, pathSet) {\n    switch(getType(value)){\n        case \"array\":\n            for (const v of value){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n        case \"object\":\n            if (value._ref) {\n                return pathSet.has(value._ref);\n            }\n            for (const v of Object.values(value)){\n                if (hasReference(v, pathSet)) {\n                    return true;\n                }\n            }\n            break;\n    }\n    return false;\n}\nfunction countUTF8(str) {\n    let count2 = 0;\n    for(let i = 0; i < str.length; i++){\n        const code = str.charCodeAt(i);\n        if (code >= 55296 && code <= 56319) {\n            continue;\n        }\n        count2++;\n    }\n    return count2;\n}\nconst _global = {};\n_global.anywhere = async function anywhere() {\n    throw new Error(\"not implemented\");\n};\n_global.anywhere.arity = 1;\n_global.coalesce = async function coalesce(args, scope, execute) {\n    for (const arg of args){\n        const value = await execute(arg, scope);\n        if (value.type !== \"null\") {\n            return value;\n        }\n    }\n    return NULL_VALUE;\n};\n_global.count = async function count(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (!inner.isArray()) {\n        return NULL_VALUE;\n    }\n    let num = 0;\n    for await (const _ of inner){\n        num++;\n    }\n    return fromNumber(num);\n};\n_global.count.arity = 1;\n_global.dateTime = async function dateTime(args, scope, execute) {\n    const val = await execute(args[0], scope);\n    if (val.type === \"datetime\") {\n        return val;\n    }\n    if (val.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return DateTime.parseToValue(val.data);\n};\n_global.dateTime.arity = 1;\n_global.defined = async function defined(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\n};\n_global.defined.arity = 1;\n_global.identity = async function identity(args, scope) {\n    return fromString(scope.context.identity);\n};\n_global.identity.arity = 0;\n_global.length = async function length(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type === \"string\") {\n        return fromNumber(countUTF8(inner.data));\n    }\n    if (inner.isArray()) {\n        let num = 0;\n        for await (const _ of inner){\n            num++;\n        }\n        return fromNumber(num);\n    }\n    return NULL_VALUE;\n};\n_global.length.arity = 1;\n_global.path = async function path(args, scope, execute) {\n    const inner = await execute(args[0], scope);\n    if (inner.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromPath(new Path(inner.data));\n};\n_global.path.arity = 1;\n_global.string = async function string(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    switch(value.type){\n        case \"number\":\n        case \"string\":\n        case \"boolean\":\n        case \"datetime\":\n            return fromString(\"\".concat(value.data));\n        default:\n            return NULL_VALUE;\n    }\n};\n_global.string.arity = 1;\n_global.references = async function references(args, scope, execute) {\n    const pathSet = /* @__PURE__ */ new Set();\n    for (const arg of args){\n        const path2 = await execute(arg, scope);\n        if (path2.type === \"string\") {\n            pathSet.add(path2.data);\n        } else if (path2.isArray()) {\n            for await (const elem of path2){\n                if (elem.type === \"string\") {\n                    pathSet.add(elem.data);\n                }\n            }\n        }\n    }\n    if (pathSet.size === 0) {\n        return FALSE_VALUE;\n    }\n    const scopeValue = await scope.value.get();\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\n};\n_global.references.arity = (c)=>c >= 1;\n_global.round = async function round(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"number\") {\n        return NULL_VALUE;\n    }\n    const num = value.data;\n    let prec = 0;\n    if (args.length === 2) {\n        const precValue = await execute(args[1], scope);\n        if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n            return NULL_VALUE;\n        }\n        prec = precValue.data;\n    }\n    if (prec === 0) {\n        if (num < 0) {\n            return fromNumber(-Math.round(-num));\n        }\n        return fromNumber(Math.round(num));\n    }\n    return fromNumber(Number(num.toFixed(prec)));\n};\n_global.round.arity = (count2)=>count2 >= 1 && count2 <= 2;\n_global.now = async function now(args, scope) {\n    return fromString(scope.context.timestamp.toISOString());\n};\n_global.now.arity = 0;\n_global.boost = async function boost() {\n    throw new Error(\"unexpected boost call\");\n};\n_global.boost.arity = 2;\nconst string2 = {};\nstring2.lower = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toLowerCase());\n};\nstring2.lower.arity = 1;\nstring2.upper = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (value.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return fromString(value.data.toUpperCase());\n};\nstring2.upper.arity = 1;\nstring2.split = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    if (str.data.length === 0) {\n        return fromJS([]);\n    }\n    if (sep.data.length === 0) {\n        return fromJS(Array.from(str.data));\n    }\n    return fromJS(str.data.split(sep.data));\n};\nstring2.split.arity = 2;\n_global.lower = string2.lower;\n_global.upper = string2.upper;\nstring2.startsWith = async function(args, scope, execute) {\n    const str = await execute(args[0], scope);\n    if (str.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    const prefix = await execute(args[1], scope);\n    if (prefix.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE;\n};\nstring2.startsWith.arity = 2;\nconst array = {};\narray.join = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    const sep = await execute(args[1], scope);\n    if (sep.type !== \"string\") {\n        return NULL_VALUE;\n    }\n    let buf = \"\";\n    let needSep = false;\n    for await (const elem of arr){\n        if (needSep) {\n            buf += sep.data;\n        }\n        switch(elem.type){\n            case \"number\":\n            case \"string\":\n            case \"boolean\":\n            case \"datetime\":\n                buf += \"\".concat(elem.data);\n                break;\n            default:\n                return NULL_VALUE;\n        }\n        needSep = true;\n    }\n    return fromJS(buf);\n};\narray.join.arity = 2;\narray.compact = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        for await (const elem of arr){\n            if (elem.type !== \"null\") {\n                yield elem;\n            }\n        }\n    });\n};\narray.compact.arity = 1;\narray.unique = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    if (!value.isArray()) {\n        return NULL_VALUE;\n    }\n    return new StreamValue(async function*() {\n        const added = /* @__PURE__ */ new Set();\n        for await (const iter of value){\n            switch(iter.type){\n                case \"number\":\n                case \"string\":\n                case \"boolean\":\n                case \"datetime\":\n                    if (!added.has(iter.data)) {\n                        added.add(iter.data);\n                        yield iter;\n                    }\n                    break;\n                default:\n                    yield iter;\n            }\n        }\n    });\n};\narray.unique.arity = 1;\nconst pt = {};\npt.text = async function(args, scope, execute) {\n    const value = await execute(args[0], scope);\n    const text = await portableTextContent(value);\n    if (text === null) {\n        return NULL_VALUE;\n    }\n    return fromString(text);\n};\npt.text.arity = 1;\nconst sanity = {};\nsanity.projectId = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.projectId);\n    }\n    return NULL_VALUE;\n};\nsanity.dataset = async function(args, scope) {\n    if (scope.context.sanity) {\n        return fromString(scope.context.sanity.dataset);\n    }\n    return NULL_VALUE;\n};\nconst pipeFunctions = {};\npipeFunctions.order = async function order(base, args, scope, execute) {\n    await true;\n    if (!base.isArray()) {\n        return NULL_VALUE;\n    }\n    const mappers = [];\n    const directions = [];\n    let n = 0;\n    for (let mapper of args){\n        let direction = \"asc\";\n        if (mapper.type === \"Desc\") {\n            direction = \"desc\";\n            mapper = mapper.base;\n        } else if (mapper.type === \"Asc\") {\n            mapper = mapper.base;\n        }\n        mappers.push(mapper);\n        directions.push(direction);\n        n++;\n    }\n    const aux = [];\n    let idx = 0;\n    for await (const value of base){\n        const newScope = scope.createNested(value);\n        const tuple = [\n            await value.get(),\n            idx\n        ];\n        for(let i = 0; i < n; i++){\n            const result = await execute(mappers[i], newScope);\n            tuple.push(await result.get());\n        }\n        aux.push(tuple);\n        idx++;\n    }\n    aux.sort((aTuple, bTuple)=>{\n        for(let i = 0; i < n; i++){\n            let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\n            if (directions[i] === \"desc\") {\n                c = -c;\n            }\n            if (c !== 0) {\n                return c;\n            }\n        }\n        return aTuple[1] - bTuple[1];\n    });\n    return fromJS(aux.map((v)=>v[0]));\n};\npipeFunctions.order.arity = (count2)=>count2 >= 1;\npipeFunctions.score = async function score(base, args, scope, execute) {\n    if (!base.isArray()) return NULL_VALUE;\n    const unknown = [];\n    const scored = [];\n    for await (const value of base){\n        if (value.type !== \"object\") {\n            unknown.push(await value.get());\n            continue;\n        }\n        const newScope = scope.createNested(value);\n        let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\n        for (const arg of args){\n            valueScore += await evaluateScore(arg, newScope, execute);\n        }\n        const newObject = Object.assign({}, value.data, {\n            _score: valueScore\n        });\n        scored.push(newObject);\n    }\n    scored.sort((a, b)=>b._score - a._score);\n    return fromJS(scored);\n};\npipeFunctions.score.arity = (count2)=>count2 >= 1;\nconst delta = {};\ndelta.operation = async function(args, scope) {\n    const hasBefore = scope.context.before !== null;\n    const hasAfter = scope.context.after !== null;\n    if (hasBefore && hasAfter) {\n        return fromString(\"update\");\n    }\n    if (hasAfter) {\n        return fromString(\"create\");\n    }\n    if (hasBefore) {\n        return fromString(\"delete\");\n    }\n    return NULL_VALUE;\n};\ndelta.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedAny.arity = 1;\ndelta.changedAny.mode = \"delta\";\ndelta.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndelta.changedOnly.arity = 1;\ndelta.changedOnly.mode = \"delta\";\nconst diff = {};\ndiff.changedAny = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedAny.arity = 3;\ndiff.changedOnly = ()=>{\n    throw new Error(\"not implemented\");\n};\ndiff.changedOnly.arity = 3;\nconst math = {};\nmath.min = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data < n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.min.arity = 1;\nmath.max = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        if (n === void 0 || elem.data > n) {\n            n = elem.data;\n        }\n    }\n    return fromJS(n);\n};\nmath.max.arity = 1;\nmath.sum = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n    }\n    return fromJS(n);\n};\nmath.sum.arity = 1;\nmath.avg = async function(args, scope, execute) {\n    const arr = await execute(args[0], scope);\n    if (!arr.isArray()) {\n        return NULL_VALUE;\n    }\n    let n = 0;\n    let c = 0;\n    for await (const elem of arr){\n        if (elem.type === \"null\") continue;\n        if (elem.type !== \"number\") {\n            return NULL_VALUE;\n        }\n        n += elem.data;\n        c++;\n    }\n    if (c === 0) {\n        return NULL_VALUE;\n    }\n    return fromJS(n / c);\n};\nmath.avg.arity = 1;\nconst dateTime2 = {};\ndateTime2.now = async function now2(args, scope, execute) {\n    return fromDateTime(new DateTime(scope.context.timestamp));\n};\ndateTime2.now.arity = 0;\nconst namespaces = {\n    global: _global,\n    string: string2,\n    array,\n    pt,\n    delta,\n    diff,\n    sanity,\n    math,\n    dateTime: dateTime2\n};\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value)=>key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value)=>{\n    __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass MarkProcessor {\n    constructor(string, marks, parseOptions){\n        __publicField$1(this, \"string\");\n        __publicField$1(this, \"marks\");\n        __publicField$1(this, \"index\");\n        __publicField$1(this, \"parseOptions\");\n        __publicField$1(this, \"allowBoost\", false);\n        this.string = string;\n        this.marks = marks;\n        this.index = 0;\n        this.parseOptions = parseOptions;\n    }\n    hasMark() {\n        let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.index + pos < this.marks.length;\n    }\n    getMark() {\n        let pos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.marks[this.index + pos];\n    }\n    shift() {\n        this.index += 1;\n    }\n    process(visitor) {\n        const mark = this.marks[this.index];\n        this.shift();\n        const func = visitor[mark.name];\n        if (!func) {\n            throw new Error(\"Unknown handler: \".concat(mark.name));\n        }\n        return func.call(visitor, this, mark);\n    }\n    processString() {\n        this.shift();\n        return this.processStringEnd();\n    }\n    processStringEnd() {\n        const prev = this.marks[this.index - 1];\n        const curr = this.marks[this.index];\n        this.shift();\n        return this.string.slice(prev.position, curr.position);\n    }\n    slice(len) {\n        const pos = this.marks[this.index].position;\n        return this.string.slice(pos, pos + len);\n    }\n}\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\nconst NUM = /^\\d+/;\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\nconst PREC_PAIR = 1;\nconst PREC_OR = 2;\nconst PREC_AND = 3;\nconst PREC_COMP = 4;\nconst PREC_ORDER = 4;\nconst PREC_ADD = 6;\nconst PREC_SUB = 6;\nconst PREC_MUL = 7;\nconst PREC_DIV = 7;\nconst PREC_MOD = 7;\nconst PREC_POW = 8;\nconst PREC_POS = 10;\nconst PREC_NOT = 10;\nconst PREC_NEG = 8;\nfunction parse$1(str) {\n    let pos = 0;\n    pos = skipWS(str, pos);\n    let result = parseExpr(str, pos, 0);\n    if (result.type === \"error\") return result;\n    pos = skipWS(str, result.position);\n    if (pos !== str.length) {\n        if (result.failPosition) {\n            pos = result.failPosition - 1;\n        }\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    delete result.position;\n    delete result.failPosition;\n    return result;\n}\nfunction parseExpr(str, pos, level) {\n    let startPos = pos;\n    let token = str[pos];\n    let marks;\n    switch(token){\n        case \"+\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"pos\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"-\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"neg\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"(\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\n                if (rhs.type === \"error\") return rhs;\n                pos = skipWS(str, rhs.position);\n                switch(str[pos]){\n                    case \",\":\n                        {\n                            marks = [\n                                {\n                                    name: \"tuple\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            pos = skipWS(str, pos + 1);\n                            while(true){\n                                rhs = parseExpr(str, pos, 0);\n                                if (rhs.type === \"error\") return rhs;\n                                pos = skipWS(str, rhs.position);\n                                if (str[pos] !== \",\") break;\n                                pos = skipWS(str, pos + 1);\n                            }\n                            if (str[pos] !== \")\") return {\n                                type: \"error\",\n                                position: pos\n                            };\n                            pos++;\n                            marks.push({\n                                name: \"tuple_end\",\n                                position: pos\n                            });\n                            break;\n                        }\n                    case \")\":\n                        {\n                            pos++;\n                            marks = [\n                                {\n                                    name: \"group\",\n                                    position: startPos\n                                }\n                            ].concat(rhs.marks);\n                            break;\n                        }\n                    default:\n                        return {\n                            type: \"error\",\n                            position: pos\n                        };\n                }\n                break;\n            }\n        case \"!\":\n            {\n                let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\n                if (rhs.type === \"error\") return rhs;\n                marks = [\n                    {\n                        name: \"not\",\n                        position: startPos\n                    }\n                ].concat(rhs.marks);\n                pos = rhs.position;\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"[\":\n            marks = [\n                {\n                    name: \"array\",\n                    position: pos\n                }\n            ];\n            pos = skipWS(str, pos + 1);\n            if (str[pos] !== \"]\") {\n                while(true){\n                    if (str.slice(pos, pos + 3) === \"...\") {\n                        marks.push({\n                            name: \"array_splat\",\n                            position: pos\n                        });\n                        pos = skipWS(str, pos + 3);\n                    }\n                    let res = parseExpr(str, pos, 0);\n                    if (res.type === \"error\") return res;\n                    marks = marks.concat(res.marks);\n                    pos = res.position;\n                    pos = skipWS(str, pos);\n                    if (str[pos] !== \",\") break;\n                    pos = skipWS(str, pos + 1);\n                    if (str[pos] === \"]\") break;\n                }\n            }\n            if (str[pos] === \"]\") {\n                pos++;\n                marks.push({\n                    name: \"array_end\",\n                    position: pos\n                });\n            } else {\n                return {\n                    type: \"error\",\n                    position: pos\n                };\n            }\n            break;\n        case \"'\":\n        case '\"':\n            {\n                let result = parseString(str, pos);\n                if (result.type === \"error\") return result;\n                marks = result.marks;\n                pos = result.position;\n                break;\n            }\n        case \"^\":\n            {\n                pos++;\n                marks = [];\n                while(str[pos] === \".\" && str[pos + 1] === \"^\"){\n                    marks.push({\n                        name: \"dblparent\",\n                        position: startPos\n                    });\n                    pos += 2;\n                }\n                marks.push({\n                    name: \"parent\",\n                    position: startPos\n                });\n                break;\n            }\n        case \"@\":\n            marks = [\n                {\n                    name: \"this\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"*\":\n            marks = [\n                {\n                    name: \"everything\",\n                    position: startPos\n                }\n            ];\n            pos++;\n            break;\n        case \"$\":\n            {\n                let identLen = parseRegex(str, pos + 1, IDENT);\n                if (identLen) {\n                    pos += 1 + identLen;\n                    marks = [\n                        {\n                            name: \"param\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: startPos + 1\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ];\n                }\n                break;\n            }\n        default:\n            {\n                let numLen = parseRegex(str, pos, NUM);\n                if (numLen) {\n                    pos += numLen;\n                    let name = \"integer\";\n                    if (str[pos] === \".\") {\n                        let fracLen = parseRegex(str, pos + 1, NUM);\n                        if (fracLen) {\n                            name = \"float\";\n                            pos += 1 + fracLen;\n                        }\n                    }\n                    if (str[pos] === \"e\" || str[pos] === \"E\") {\n                        name = \"sci\";\n                        pos++;\n                        if (str[pos] === \"+\" || str[pos] === \"-\") {\n                            pos++;\n                        }\n                        let expLen = parseRegex(str, pos, NUM);\n                        if (!expLen) return {\n                            type: \"error\",\n                            position: pos\n                        };\n                        pos += expLen;\n                    }\n                    marks = [\n                        {\n                            name,\n                            position: startPos\n                        },\n                        {\n                            name: name + \"_end\",\n                            position: pos\n                        }\n                    ];\n                    break;\n                }\n                let identLen = parseRegex(str, pos, IDENT);\n                if (identLen) {\n                    pos += identLen;\n                    switch(str[pos]){\n                        case \":\":\n                        case \"(\":\n                            {\n                                let result = parseFuncCall(str, startPos, pos);\n                                if (result.type === \"error\") return result;\n                                marks = result.marks;\n                                pos = result.position;\n                                break;\n                            }\n                        default:\n                            {\n                                marks = [\n                                    {\n                                        name: \"this_attr\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident\",\n                                        position: startPos\n                                    },\n                                    {\n                                        name: \"ident_end\",\n                                        position: pos\n                                    }\n                                ];\n                            }\n                    }\n                    break;\n                }\n            }\n    }\n    if (!marks) {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    let lhsLevel = 12;\n    let trav;\n    loop: while(true){\n        let innerPos = skipWS(str, pos);\n        if (innerPos === str.length) {\n            pos = innerPos;\n            break;\n        }\n        trav = parseTraversal(str, innerPos);\n        if (trav.type === \"success\") {\n            marks.unshift({\n                name: \"traverse\",\n                position: startPos\n            });\n            while(trav.type === \"success\"){\n                marks = marks.concat(trav.marks);\n                pos = trav.position;\n                trav = parseTraversal(str, skipWS(str, pos));\n            }\n            marks.push({\n                name: \"traversal_end\",\n                position: pos\n            });\n            continue;\n        }\n        let token2 = str[innerPos];\n        switch(token2){\n            case \"=\":\n                {\n                    let nextToken = str[innerPos + 1];\n                    switch(nextToken){\n                        case \">\":\n                            {\n                                if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\n                                if (rhs.type === \"error\") return rhs;\n                                marks = marks.concat(rhs.marks);\n                                marks.unshift({\n                                    name: \"pair\",\n                                    position: startPos\n                                });\n                                pos = rhs.position;\n                                lhsLevel = PREC_PAIR;\n                                break;\n                            }\n                        case \"=\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 2\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        default:\n                            break loop;\n                    }\n                    break;\n                }\n            case \"+\":\n                {\n                    if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"add\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_ADD;\n                    break;\n                }\n            case \"-\":\n                {\n                    if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"sub\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_SUB;\n                    break;\n                }\n            case \"*\":\n                {\n                    if (str[innerPos + 1] === \"*\") {\n                        if (level > PREC_POW || lhsLevel <= PREC_POW) break loop;\n                        let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\n                        if (rhs2.type === \"error\") return rhs2;\n                        marks = marks.concat(rhs2.marks);\n                        marks.unshift({\n                            name: \"pow\",\n                            position: startPos\n                        });\n                        pos = rhs2.position;\n                        lhsLevel = PREC_POW;\n                        break;\n                    }\n                    if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mul\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MUL;\n                    break;\n                }\n            case \"/\":\n                {\n                    if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"div\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_DIV;\n                    break;\n                }\n            case \"%\":\n                {\n                    if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"mod\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_MOD;\n                    break;\n                }\n            case \"<\":\n            case \">\":\n                {\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let nextPos = innerPos + 1;\n                    if (str[nextPos] === \"=\") {\n                        nextPos++;\n                    }\n                    let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: nextPos\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"|\":\n                {\n                    if (str[innerPos + 1] === \"|\") {\n                        if (level > PREC_OR || lhsLevel < PREC_OR) break loop;\n                        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\n                        if (rhs.type === \"error\") return rhs;\n                        marks = marks.concat(rhs.marks);\n                        marks.unshift({\n                            name: \"or\",\n                            position: startPos\n                        });\n                        pos = rhs.position;\n                        lhsLevel = PREC_OR;\n                    } else {\n                        if (level > 11 || lhsLevel < 11) break loop;\n                        let identPos = skipWS(str, innerPos + 1);\n                        let identLen = parseRegex(str, identPos, IDENT);\n                        if (!identLen) return {\n                            type: \"error\",\n                            position: identPos\n                        };\n                        pos = identPos + identLen;\n                        if (str[pos] === \"(\" || str[pos] === \":\") {\n                            let result = parseFuncCall(str, identPos, pos);\n                            if (result.type === \"error\") return result;\n                            marks = marks.concat(result.marks);\n                            marks.unshift({\n                                name: \"pipecall\",\n                                position: startPos\n                            });\n                            pos = result.position;\n                            lhsLevel = 11;\n                        }\n                    }\n                    break;\n                }\n            case \"&\":\n                {\n                    if (str[innerPos + 1] != \"&\") break loop;\n                    if (level > PREC_AND || lhsLevel < PREC_AND) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks = marks.concat(rhs.marks);\n                    marks.unshift({\n                        name: \"and\",\n                        position: startPos\n                    });\n                    pos = rhs.position;\n                    lhsLevel = PREC_AND;\n                    break;\n                }\n            case \"!\":\n                {\n                    if (str[innerPos + 1] !== \"=\") break loop;\n                    if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                    let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\n                    if (rhs.type === \"error\") return rhs;\n                    marks.unshift({\n                        name: \"comp\",\n                        position: startPos\n                    });\n                    marks.push({\n                        name: \"op\",\n                        position: innerPos\n                    }, {\n                        name: \"op_end\",\n                        position: innerPos + 2\n                    });\n                    marks = marks.concat(rhs.marks);\n                    pos = rhs.position;\n                    lhsLevel = PREC_COMP;\n                    break;\n                }\n            case \"d\":\n                {\n                    if (str.slice(innerPos, innerPos + 4) !== \"desc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"desc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 4;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            case \"a\":\n                {\n                    if (str.slice(innerPos, innerPos + 3) !== \"asc\") break loop;\n                    if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop;\n                    marks.unshift({\n                        name: \"asc\",\n                        position: startPos\n                    });\n                    pos = innerPos + 3;\n                    lhsLevel = PREC_ORDER;\n                    break;\n                }\n            default:\n                {\n                    let ident = parseRegexStr(str, innerPos, IDENT);\n                    switch(ident){\n                        case \"in\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                pos = skipWS(str, innerPos + 2);\n                                let isGroup = false;\n                                if (str[pos] === \"(\") {\n                                    isGroup = true;\n                                    pos = skipWS(str, pos + 1);\n                                }\n                                let rangePos = pos;\n                                let result = parseExpr(str, pos, PREC_COMP + 1);\n                                if (result.type === \"error\") return result;\n                                pos = skipWS(str, result.position);\n                                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                                    let type = \"inc_range\";\n                                    if (str[pos + 2] === \".\") {\n                                        type = \"exc_range\";\n                                        pos = skipWS(str, pos + 3);\n                                    } else {\n                                        pos = skipWS(str, pos + 2);\n                                    }\n                                    let rhs = parseExpr(str, pos, PREC_COMP + 1);\n                                    if (rhs.type === \"error\") return rhs;\n                                    marks.unshift({\n                                        name: \"in_range\",\n                                        position: startPos\n                                    });\n                                    marks = marks.concat({\n                                        name: type,\n                                        position: rangePos\n                                    }, result.marks, rhs.marks);\n                                    pos = rhs.position;\n                                } else {\n                                    marks.unshift({\n                                        name: \"comp\",\n                                        position: startPos\n                                    });\n                                    marks.push({\n                                        name: \"op\",\n                                        position: innerPos\n                                    }, {\n                                        name: \"op_end\",\n                                        position: innerPos + 2\n                                    });\n                                    marks = marks.concat(result.marks);\n                                }\n                                if (isGroup) {\n                                    pos = skipWS(str, pos);\n                                    if (str[pos] !== \")\") return {\n                                        type: \"error\",\n                                        position: pos\n                                    };\n                                    pos++;\n                                }\n                                lhsLevel = PREC_COMP;\n                                break;\n                            }\n                        case \"match\":\n                            {\n                                if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop;\n                                let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\n                                if (rhs.type === \"error\") return rhs;\n                                marks.unshift({\n                                    name: \"comp\",\n                                    position: startPos\n                                });\n                                marks.push({\n                                    name: \"op\",\n                                    position: innerPos\n                                }, {\n                                    name: \"op_end\",\n                                    position: innerPos + 5\n                                });\n                                marks = marks.concat(rhs.marks);\n                                pos = rhs.position;\n                                lhsLevel = 4;\n                                break;\n                            }\n                        default:\n                            {\n                                break loop;\n                            }\n                    }\n                }\n        }\n    }\n    let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\n    return {\n        type: \"success\",\n        marks,\n        position: pos,\n        failPosition\n    };\n}\nfunction parseTraversal(str, pos) {\n    let startPos = pos;\n    switch(str[pos]){\n        case \".\":\n            {\n                pos = skipWS(str, pos + 1);\n                let identStart = pos;\n                let identLen2 = parseRegex(str, pos, IDENT);\n                if (!identLen2) return {\n                    type: \"error\",\n                    position: pos\n                };\n                pos += identLen2;\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"attr_access\",\n                            position: startPos\n                        },\n                        {\n                            name: \"ident\",\n                            position: identStart\n                        },\n                        {\n                            name: \"ident_end\",\n                            position: pos\n                        }\n                    ],\n                    position: pos\n                };\n            }\n        case \"-\":\n            if (str[pos + 1] !== \">\") return {\n                type: \"error\",\n                position: pos\n            };\n            let marks = [\n                {\n                    name: \"deref\",\n                    position: startPos\n                }\n            ];\n            pos += 2;\n            let identPos = skipWS(str, pos);\n            let identLen = parseRegex(str, identPos, IDENT);\n            if (identLen) {\n                pos = identPos + identLen;\n                marks.push({\n                    name: \"deref_attr\",\n                    position: identPos\n                }, {\n                    name: \"ident\",\n                    position: identPos\n                }, {\n                    name: \"ident_end\",\n                    position: pos\n                });\n            }\n            return {\n                type: \"success\",\n                marks,\n                position: pos\n            };\n        case \"[\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"]\") {\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"array_postfix\",\n                                position: startPos\n                            }\n                        ],\n                        position: pos + 1\n                    };\n                }\n                let rangePos = pos;\n                let result = parseExpr(str, pos, 0);\n                if (result.type === \"error\") return result;\n                pos = skipWS(str, result.position);\n                if (str[pos] === \".\" && str[pos + 1] === \".\") {\n                    let type = \"inc_range\";\n                    if (str[pos + 2] === \".\") {\n                        type = \"exc_range\";\n                        pos += 3;\n                    } else {\n                        pos += 2;\n                    }\n                    pos = skipWS(str, pos);\n                    let rhs = parseExpr(str, pos, 0);\n                    if (rhs.type === \"error\") return rhs;\n                    pos = skipWS(str, rhs.position);\n                    if (str[pos] !== \"]\") return {\n                        type: \"error\",\n                        position: pos\n                    };\n                    return {\n                        type: \"success\",\n                        marks: [\n                            {\n                                name: \"slice\",\n                                position: startPos\n                            },\n                            {\n                                name: type,\n                                position: rangePos\n                            }\n                        ].concat(result.marks, rhs.marks),\n                        position: pos + 1\n                    };\n                }\n                if (str[pos] !== \"]\") return {\n                    type: \"error\",\n                    position: pos\n                };\n                return {\n                    type: \"success\",\n                    marks: [\n                        {\n                            name: \"square_bracket\",\n                            position: startPos\n                        }\n                    ].concat(result.marks),\n                    position: pos + 1\n                };\n            }\n        case \"|\":\n            {\n                pos = skipWS(str, pos + 1);\n                if (str[pos] === \"{\") {\n                    let result = parseObject(str, pos);\n                    if (result.type === \"error\") return result;\n                    result.marks.unshift({\n                        name: \"projection\",\n                        position: startPos\n                    });\n                    return result;\n                }\n                break;\n            }\n        case \"{\":\n            {\n                let result = parseObject(str, pos);\n                if (result.type === \"error\") return result;\n                result.marks.unshift({\n                    name: \"projection\",\n                    position: startPos\n                });\n                return result;\n            }\n    }\n    return {\n        type: \"error\",\n        position: pos\n    };\n}\nfunction parseFuncCall(str, startPos, pos) {\n    let marks = [];\n    marks.push({\n        name: \"func_call\",\n        position: startPos\n    });\n    if (str[pos] === \":\" && str[pos + 1] === \":\") {\n        marks.push({\n            name: \"namespace\",\n            position: startPos\n        });\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 2);\n        let nameLen = parseRegex(str, pos, IDENT);\n        if (!nameLen) return {\n            type: \"error\",\n            position: pos\n        };\n        marks.push({\n            name: \"ident\",\n            position: pos\n        }, {\n            name: \"ident_end\",\n            position: pos + nameLen\n        });\n        pos = skipWS(str, pos + nameLen);\n        if (str[pos] !== \"(\") return {\n            type: \"error\",\n            position: pos\n        };\n        pos++;\n        pos = skipWS(str, pos);\n    } else {\n        marks.push({\n            name: \"ident\",\n            position: startPos\n        }, {\n            name: \"ident_end\",\n            position: pos\n        });\n        pos = skipWS(str, pos + 1);\n    }\n    let lastPos = pos;\n    if (str[pos] !== \")\") {\n        while(true){\n            let result = parseExpr(str, pos, 0);\n            if (result.type === \"error\") return result;\n            marks = marks.concat(result.marks);\n            lastPos = result.position;\n            pos = skipWS(str, result.position);\n            if (str[pos] !== \",\") break;\n            pos = skipWS(str, pos + 1);\n            if (str[pos] === \")\") break;\n        }\n    }\n    if (str[pos] !== \")\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    marks.push({\n        name: \"func_args_end\",\n        position: lastPos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos + 1\n    };\n}\nfunction parseObject(str, pos) {\n    let marks = [\n        {\n            name: \"object\",\n            position: pos\n        }\n    ];\n    pos = skipWS(str, pos + 1);\n    while(str[pos] !== \"}\"){\n        let pairPos = pos;\n        if (str.slice(pos, pos + 3) === \"...\") {\n            pos = skipWS(str, pos + 3);\n            if (str[pos] !== \"}\" && str[pos] !== \",\") {\n                let expr = parseExpr(str, pos, 0);\n                if (expr.type === \"error\") return expr;\n                marks.push({\n                    name: \"object_splat\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks);\n                pos = expr.position;\n            } else {\n                marks.push({\n                    name: \"object_splat_this\",\n                    position: pairPos\n                });\n            }\n        } else {\n            let expr = parseExpr(str, pos, 0);\n            if (expr.type === \"error\") return expr;\n            let nextPos = skipWS(str, expr.position);\n            if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\n                let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\n                if (value.type === \"error\") return value;\n                marks.push({\n                    name: \"object_pair\",\n                    position: pairPos\n                });\n                marks = marks.concat(expr.marks, value.marks);\n                pos = value.position;\n            } else {\n                marks = marks.concat({\n                    name: \"object_expr\",\n                    position: pos\n                }, expr.marks);\n                pos = expr.position;\n            }\n        }\n        pos = skipWS(str, pos);\n        if (str[pos] !== \",\") break;\n        pos = skipWS(str, pos + 1);\n    }\n    if (str[pos] !== \"}\") {\n        return {\n            type: \"error\",\n            position: pos\n        };\n    }\n    pos++;\n    marks.push({\n        name: \"object_end\",\n        position: pos\n    });\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction parseString(str, pos) {\n    let token = str[pos];\n    pos = pos + 1;\n    const marks = [\n        {\n            name: \"str\",\n            position: pos\n        }\n    ];\n    str: for(;; pos++){\n        if (pos > str.length) return {\n            type: \"error\",\n            position: pos\n        };\n        switch(str[pos]){\n            case token:\n                {\n                    marks.push({\n                        name: \"str_end\",\n                        position: pos\n                    });\n                    pos++;\n                    break str;\n                }\n            case \"\\\\\":\n                {\n                    marks.push({\n                        name: \"str_pause\",\n                        position: pos\n                    });\n                    if (str[pos + 1] === \"u\") {\n                        if (str[pos + 2] === \"{\") {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 3\n                            });\n                            pos = str.indexOf(\"}\", pos + 3);\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos\n                            });\n                        } else {\n                            marks.push({\n                                name: \"unicode_hex\",\n                                position: pos + 2\n                            });\n                            marks.push({\n                                name: \"unicode_hex_end\",\n                                position: pos + 6\n                            });\n                            pos += 5;\n                        }\n                    } else {\n                        marks.push({\n                            name: \"single_escape\",\n                            position: pos + 1\n                        });\n                        pos += 1;\n                    }\n                    marks.push({\n                        name: \"str_start\",\n                        position: pos + 1\n                    });\n                }\n        }\n    }\n    return {\n        type: \"success\",\n        marks,\n        position: pos\n    };\n}\nfunction skipWS(str, pos) {\n    return pos + parseRegex(str, pos, WS);\n}\nfunction parseRegex(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0].length : 0;\n}\nfunction parseRegexStr(str, pos, re) {\n    let m = re.exec(str.slice(pos));\n    return m ? m[0] : null;\n}\nfunction join(a, b) {\n    return (base)=>b(a(base));\n}\nfunction map(inner) {\n    return (base)=>({\n            type: \"Map\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction flatMap(inner) {\n    return (base)=>({\n            type: \"FlatMap\",\n            base,\n            expr: inner({\n                type: \"This\"\n            })\n        });\n}\nfunction traverseArray(build, right) {\n    if (!right) {\n        return {\n            type: \"a-a\",\n            build\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(build, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"a-a\",\n                build: join(build, map(right.build))\n            };\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(build, flatMap(right.build))\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traversePlain(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseElement(mapper, right) {\n    if (!right) {\n        return {\n            type: \"a-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n        case \"b-a\":\n            return {\n                type: \"a-a\",\n                build: join(mapper, right.build)\n            };\n        case \"a-b\":\n        case \"b-b\":\n            return {\n                type: \"a-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nfunction traverseProjection(mapper, right) {\n    if (!right) {\n        return {\n            type: \"b-b\",\n            build: mapper\n        };\n    }\n    switch(right.type){\n        case \"a-a\":\n            return {\n                type: \"a-a\",\n                build: join(map(mapper), right.build)\n            };\n        case \"a-b\":\n            return {\n                type: \"a-b\",\n                build: join(map(mapper), right.build)\n            };\n        case \"b-a\":\n            return {\n                type: \"b-a\",\n                build: join(mapper, right.build)\n            };\n        case \"b-b\":\n            return {\n                type: \"b-b\",\n                build: join(mapper, right.build)\n            };\n        default:\n            throw new Error(\"unknown type: \".concat(right.type));\n    }\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nconst ESCAPE_SEQUENCE = {\n    \"'\": \"'\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n    \"/\": \"/\",\n    b: \"\\b\",\n    f: \"\\f\",\n    n: \"\\n\",\n    r: \"\\r\",\n    t: \"\t\"\n};\nfunction expandHex(str) {\n    const charCode = parseInt(str, 16);\n    return String.fromCharCode(charCode);\n}\nclass GroqQueryError extends Error {\n    constructor(){\n        super(...arguments);\n        __publicField(this, \"name\", \"GroqQueryError\");\n    }\n}\nconst EXPR_BUILDER = {\n    group (p) {\n        const inner = p.process(EXPR_BUILDER);\n        return {\n            type: \"Group\",\n            base: inner\n        };\n    },\n    everything () {\n        return {\n            type: \"Everything\"\n        };\n    },\n    this () {\n        return {\n            type: \"This\"\n        };\n    },\n    parent () {\n        return {\n            type: \"Parent\",\n            n: 1\n        };\n    },\n    dblparent (p) {\n        const next = p.process(EXPR_BUILDER);\n        return {\n            type: \"Parent\",\n            n: next.n + 1\n        };\n    },\n    traverse (p) {\n        const base = p.process(EXPR_BUILDER);\n        const traversalList = [];\n        while(p.getMark().name !== \"traversal_end\"){\n            traversalList.push(p.process(TRAVERSE_BUILDER));\n        }\n        p.shift();\n        let traversal = null;\n        for(let i = traversalList.length - 1; i >= 0; i--){\n            traversal = traversalList[i](traversal);\n        }\n        if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\n            traversal = traverseArray((val)=>val, traversal);\n        }\n        if (traversal === null) throw new Error(\"BUG: unexpected empty traversal\");\n        return traversal.build(base);\n    },\n    this_attr (p) {\n        const name = p.processString();\n        if (name === \"null\") {\n            return {\n                type: \"Value\",\n                value: null\n            };\n        }\n        if (name === \"true\") {\n            return {\n                type: \"Value\",\n                value: true\n            };\n        }\n        if (name === \"false\") {\n            return {\n                type: \"Value\",\n                value: false\n            };\n        }\n        return {\n            type: \"AccessAttribute\",\n            name\n        };\n    },\n    neg (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Neg\",\n            base\n        };\n    },\n    pos (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Pos\",\n            base\n        };\n    },\n    add (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"+\",\n            left,\n            right\n        };\n    },\n    sub (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"-\",\n            left,\n            right\n        };\n    },\n    mul (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"*\",\n            left,\n            right\n        };\n    },\n    div (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"/\",\n            left,\n            right\n        };\n    },\n    mod (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"%\",\n            left,\n            right\n        };\n    },\n    pow (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op: \"**\",\n            left,\n            right\n        };\n    },\n    comp (p) {\n        const left = p.process(EXPR_BUILDER);\n        const op = p.processString();\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"OpCall\",\n            op,\n            left,\n            right\n        };\n    },\n    in_range (p) {\n        const base = p.process(EXPR_BUILDER);\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"InRange\",\n            base,\n            left,\n            right,\n            isInclusive\n        };\n    },\n    str (p) {\n        let value = \"\";\n        loop: while(p.hasMark()){\n            const mark = p.getMark();\n            switch(mark.name){\n                case \"str_end\":\n                    value += p.processStringEnd();\n                    break loop;\n                case \"str_pause\":\n                    value += p.processStringEnd();\n                    break;\n                case \"str_start\":\n                    p.shift();\n                    break;\n                case \"single_escape\":\n                    {\n                        const char = p.slice(1);\n                        p.shift();\n                        value += ESCAPE_SEQUENCE[char];\n                        break;\n                    }\n                case \"unicode_hex\":\n                    p.shift();\n                    value += expandHex(p.processStringEnd());\n                    break;\n                default:\n                    throw new Error(\"unexpected mark: \".concat(mark.name));\n            }\n        }\n        return {\n            type: \"Value\",\n            value\n        };\n    },\n    integer (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    float (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    sci (p) {\n        const strValue = p.processStringEnd();\n        return {\n            type: \"Value\",\n            value: Number(strValue)\n        };\n    },\n    object (p) {\n        const attributes = [];\n        while(p.getMark().name !== \"object_end\"){\n            attributes.push(p.process(OBJECT_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Object\",\n            attributes\n        };\n    },\n    array (p) {\n        const elements = [];\n        while(p.getMark().name !== \"array_end\"){\n            let isSplat = false;\n            if (p.getMark().name === \"array_splat\") {\n                isSplat = true;\n                p.shift();\n            }\n            const value = p.process(EXPR_BUILDER);\n            elements.push({\n                type: \"ArrayElement\",\n                value,\n                isSplat\n            });\n        }\n        p.shift();\n        return {\n            type: \"Array\",\n            elements\n        };\n    },\n    tuple (p) {\n        const members = [];\n        while(p.getMark().name !== \"tuple_end\"){\n            members.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        return {\n            type: \"Tuple\",\n            members\n        };\n    },\n    func_call (p) {\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        const name = p.processString();\n        if (namespace === \"global\" && name === \"select\") {\n            const result = {\n                type: \"Select\",\n                alternatives: []\n            };\n            while(p.getMark().name !== \"func_args_end\"){\n                if (p.getMark().name === \"pair\") {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    p.shift();\n                    const condition = p.process(EXPR_BUILDER);\n                    const value = p.process(EXPR_BUILDER);\n                    result.alternatives.push({\n                        type: \"SelectAlternative\",\n                        condition,\n                        value\n                    });\n                } else {\n                    if (result.fallback) throw new GroqQueryError(\"unexpected argument to select()\");\n                    const value = p.process(EXPR_BUILDER);\n                    result.fallback = value;\n                }\n            }\n            p.shift();\n            return result;\n        }\n        const args = [];\n        while(p.getMark().name !== \"func_args_end\"){\n            if (argumentShouldBeSelector(namespace, name, args.length)) {\n                p.process(SELECTOR_BUILDER);\n                args.push({\n                    type: \"Selector\"\n                });\n            } else {\n                args.push(p.process(EXPR_BUILDER));\n            }\n        }\n        p.shift();\n        if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\n            if (p.parseOptions.mode === \"delta\") {\n                return {\n                    type: \"Context\",\n                    key: name\n                };\n            }\n        }\n        if (namespace === \"global\" && name === \"boost\" && !p.allowBoost) throw new GroqQueryError(\"unexpected boost\");\n        const funcs = namespaces[namespace];\n        if (!funcs) {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const func = funcs[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        if (func.arity !== void 0) {\n            validateArity(name, func.arity, args.length);\n        }\n        if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\n            throw new GroqQueryError(\"Undefined function: \".concat(name));\n        }\n        return {\n            type: \"FuncCall\",\n            func,\n            namespace,\n            name,\n            args\n        };\n    },\n    pipecall (p) {\n        const base = p.process(EXPR_BUILDER);\n        p.shift();\n        let namespace = \"global\";\n        if (p.getMark().name === \"namespace\") {\n            p.shift();\n            namespace = p.processString();\n        }\n        if (namespace !== \"global\") {\n            throw new GroqQueryError(\"Undefined namespace: \".concat(namespace));\n        }\n        const name = p.processString();\n        const args = [];\n        const oldAllowBoost = p.allowBoost;\n        if (name === \"score\") {\n            p.allowBoost = true;\n        }\n        for(;;){\n            const markName = p.getMark().name;\n            if (markName === \"func_args_end\") {\n                break;\n            }\n            if (name === \"order\") {\n                if (markName === \"asc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Asc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                } else if (markName === \"desc\") {\n                    p.shift();\n                    args.push({\n                        type: \"Desc\",\n                        base: p.process(EXPR_BUILDER)\n                    });\n                    continue;\n                }\n            }\n            args.push(p.process(EXPR_BUILDER));\n        }\n        p.shift();\n        p.allowBoost = oldAllowBoost;\n        const func = pipeFunctions[name];\n        if (!func) {\n            throw new GroqQueryError(\"Undefined pipe function: \".concat(name));\n        }\n        if (func.arity) {\n            validateArity(name, func.arity, args.length);\n        }\n        return {\n            type: \"PipeFuncCall\",\n            func,\n            base,\n            name,\n            args\n        };\n    },\n    pair (p) {\n        throw new GroqQueryError(\"unexpected =>\");\n    },\n    and (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"And\",\n            left,\n            right\n        };\n    },\n    or (p) {\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        return {\n            type: \"Or\",\n            left,\n            right\n        };\n    },\n    not (p) {\n        const base = p.process(EXPR_BUILDER);\n        return {\n            type: \"Not\",\n            base\n        };\n    },\n    asc (p) {\n        throw new GroqQueryError(\"unexpected asc\");\n    },\n    desc (p) {\n        throw new GroqQueryError(\"unexpected desc\");\n    },\n    param (p) {\n        const name = p.processString();\n        if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n            return {\n                type: \"Value\",\n                value: p.parseOptions.params[name]\n            };\n        }\n        return {\n            type: \"Parameter\",\n            name\n        };\n    }\n};\nconst OBJECT_BUILDER = {\n    object_expr (p) {\n        if (p.getMark().name === \"pair\") {\n            p.shift();\n            const condition = p.process(EXPR_BUILDER);\n            const value2 = p.process(EXPR_BUILDER);\n            return {\n                type: \"ObjectConditionalSplat\",\n                condition,\n                value: value2\n            };\n        }\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: extractPropertyKey(value),\n            value\n        };\n    },\n    object_pair (p) {\n        const name = p.process(EXPR_BUILDER);\n        if (name.type !== \"Value\") throw new Error(\"name must be string\");\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectAttributeValue\",\n            name: name.value,\n            value\n        };\n    },\n    object_splat (p) {\n        const value = p.process(EXPR_BUILDER);\n        return {\n            type: \"ObjectSplat\",\n            value\n        };\n    },\n    object_splat_this () {\n        return {\n            type: \"ObjectSplat\",\n            value: {\n                type: \"This\"\n            }\n        };\n    }\n};\nconst TRAVERSE_BUILDER = {\n    square_bracket (p) {\n        const expr = p.process(EXPR_BUILDER);\n        const value = tryConstantEvaluate(expr);\n        if (value && value.type === \"number\") {\n            return (right)=>traverseElement((base)=>({\n                        type: \"AccessElement\",\n                        base,\n                        index: value.data\n                    }), right);\n        }\n        if (value && value.type === \"string\") {\n            return (right)=>traversePlain((base)=>({\n                        type: \"AccessAttribute\",\n                        base,\n                        name: value.data\n                    }), right);\n        }\n        return (right)=>traverseArray((base)=>({\n                    type: \"Filter\",\n                    base,\n                    expr\n                }), right);\n    },\n    slice (p) {\n        const isInclusive = p.getMark().name === \"inc_range\";\n        p.shift();\n        const left = p.process(EXPR_BUILDER);\n        const right = p.process(EXPR_BUILDER);\n        const leftValue = tryConstantEvaluate(left);\n        const rightValue = tryConstantEvaluate(right);\n        if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\n            throw new GroqQueryError(\"slicing must use constant numbers\");\n        }\n        return (rhs)=>traverseArray((base)=>({\n                    type: \"Slice\",\n                    base,\n                    left: leftValue.data,\n                    right: rightValue.data,\n                    isInclusive\n                }), rhs);\n    },\n    projection (p) {\n        const obj = p.process(EXPR_BUILDER);\n        return (right)=>traverseProjection((base)=>({\n                    type: \"Projection\",\n                    base,\n                    expr: obj\n                }), right);\n    },\n    attr_access (p) {\n        const name = p.processString();\n        return (right)=>traversePlain((base)=>({\n                    type: \"AccessAttribute\",\n                    base,\n                    name\n                }), right);\n    },\n    deref (p) {\n        let attr = null;\n        if (p.getMark().name === \"deref_attr\") {\n            p.shift();\n            attr = p.processString();\n        }\n        const wrap = (base)=>attr ? {\n                type: \"AccessAttribute\",\n                base,\n                name: attr\n            } : base;\n        return (right)=>traversePlain((base)=>wrap({\n                    type: \"Deref\",\n                    base\n                }), right);\n    },\n    array_postfix (p) {\n        return (right)=>traverseArray((base)=>({\n                    type: \"ArrayCoerce\",\n                    base\n                }), right);\n    }\n};\nconst SELECTOR_BUILDER = {\n    group (p) {\n        p.process(SELECTOR_BUILDER);\n        return null;\n    },\n    everything () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    this () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    parent () {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    dblparent (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    traverse (p) {\n        p.process(SELECTOR_BUILDER);\n        while(p.getMark().name !== \"traversal_end\"){\n            p.process(TRAVERSE_BUILDER);\n        }\n        p.shift();\n        return null;\n    },\n    this_attr (p) {\n        p.processString();\n        return null;\n    },\n    neg (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pos (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    add (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sub (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mul (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    div (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    mod (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pow (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    comp (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    in_range (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    str (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    integer (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    float (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    sci (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    object (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    array (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    tuple (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    func_call (p, mark) {\n        const func = EXPR_BUILDER.func_call(p, mark);\n        if (func.name === \"anywhere\" && func.args.length === 1) return null;\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pipecall (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    pair (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    and (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    or (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    not (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    asc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    desc (p) {\n        throw new Error(\"Invalid selector syntax\");\n    },\n    param (p) {\n        throw new Error(\"Invalid selector syntax\");\n    }\n};\nfunction extractPropertyKey(node) {\n    if (node.type === \"AccessAttribute\" && !node.base) {\n        return node.name;\n    }\n    if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\n        return extractPropertyKey(node.base);\n    }\n    throw new GroqQueryError(\"Cannot determine property key for type: \".concat(node.type));\n}\nfunction validateArity(name, arity, count) {\n    if (typeof arity === \"number\") {\n        if (count !== arity) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"(). Expected \").concat(arity, \", got \").concat(count, \".\"));\n        }\n    } else if (arity) {\n        if (!arity(count)) {\n            throw new GroqQueryError(\"Incorrect number of arguments to function \".concat(name, \"().\"));\n        }\n    }\n}\nfunction argumentShouldBeSelector(namespace, functionName, argCount) {\n    const functionsRequiringSelectors = [\n        \"changedAny\",\n        \"changedOnly\"\n    ];\n    return namespace == \"diff\" && argCount == 2 && functionsRequiringSelectors.includes(functionName);\n}\nclass GroqSyntaxError extends Error {\n    constructor(position){\n        super(\"Syntax error in GROQ query at position \".concat(position));\n        __publicField(this, \"position\");\n        __publicField(this, \"name\", \"GroqSyntaxError\");\n        this.position = position;\n    }\n}\nfunction parse(input) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = parse$1(input);\n    if (result.type === \"error\") {\n        throw new GroqSyntaxError(result.position);\n    }\n    const processor = new MarkProcessor(input, result.marks, options);\n    return processor.process(EXPR_BUILDER);\n}\n //# sourceMappingURL=1.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBRTtRQUNwQixLQUFLLENBQUMsMENBQTBDN1ksTUFBTSxDQUFDNlk7UUFDdkRpRSxjQUFjLElBQUksRUFBRTtRQUNwQkEsY0FBYyxJQUFJLEVBQUUsUUFBUTtRQUM1QixJQUFJLENBQUNqRSxRQUFRLEdBQUdBO0lBQ2xCO0FBQ0Y7QUFDQSxTQUFTd0ksTUFBTUMsS0FBSztJQUNsQixJQUFJM1EsVUFBVTFHLFVBQVUxSSxNQUFNLEdBQUcsS0FBSzBJLFNBQVMsQ0FBQyxFQUFFLEtBQUtDLFlBQVlELFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUNuRixNQUFNOUksU0FBUzZZLFFBQVFzSDtJQUN2QixJQUFJbmdCLE9BQU93QyxJQUFJLEtBQUssU0FBUztRQUMzQixNQUFNLElBQUl5ZCxnQkFBZ0JqZ0IsT0FBTzBYLFFBQVE7SUFDM0M7SUFDQSxNQUFNMEksWUFBWSxJQUFJekosY0FBY3dKLE9BQU9uZ0IsT0FBTzRXLEtBQUssRUFBRXBIO0lBQ3pELE9BQU80USxVQUFVbEosT0FBTyxDQUFDb0Y7QUFDM0I7QUFDc0QsQ0FDdEQsOEJBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5bG9hZC1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL2dyb3EtanMvZGlzdC8xLm1qcz85OGMxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AkNSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkNShvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkNSA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDUob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIHBhdGhSZWdFeHAocGF0dGVybikge1xuICBjb25zdCByZSA9IFtdO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGF0dGVybi5zcGxpdChcIi5cIikpIHtcbiAgICBpZiAocGFydCA9PT0gXCIqXCIpIHtcbiAgICAgIHJlLnB1c2goXCJbXi5dK1wiKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiKipcIikge1xuICAgICAgcmUucHVzaChcIi4qXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZS5wdXNoKGVzY2FwZVJlZ0V4cChwYXJ0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdChyZS5qb2luKFwiLlwiKSwgXCIkXCIpKTtcbn1cbmNsYXNzIFBhdGgge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ1KHRoaXMsIFwicGF0dGVyblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDUodGhpcywgXCJwYXR0ZXJuUmVcIik7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdHRlcm5SZSA9IHBhdGhSZWdFeHAocGF0dGVybik7XG4gIH1cbiAgbWF0Y2hlcyhzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuUmUudGVzdChzdHIpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXR0ZXJuO1xuICB9XG59XG52YXIgX19kZWZQcm9wJDQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDQob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQ0KG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFN0cmVhbVZhbHVlIHtcbiAgY29uc3RydWN0b3IoZ2VuZXJhdG9yKSB7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidHlwZVwiLCBcInN0cmVhbVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJnZW5lcmF0b3JcIik7XG4gICAgX19wdWJsaWNGaWVsZCQ0KHRoaXMsIFwidGlja2VyXCIpO1xuICAgIF9fcHVibGljRmllbGQkNCh0aGlzLCBcImlzRG9uZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDQodGhpcywgXCJkYXRhXCIpO1xuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgIHRoaXMudGlja2VyID0gbnVsbDtcbiAgICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGlzQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgZ2V0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcykge1xuICAgICAgcmVzdWx0LnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeWllbGQgdGhpcy5kYXRhW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XG4gICAgfVxuICB9XG4gIF9uZXh0VGljaygpIHtcbiAgICBpZiAodGhpcy50aWNrZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2tlcjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSZXNvbHZlcjtcbiAgICBjb25zdCBzZXR1cFRpY2tlciA9ICgpID0+IHtcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGN1cnJlbnRSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcbiAgICAgIHNldHVwVGlja2VyKCk7XG4gICAgfTtcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgdGhpcy5nZW5lcmF0b3IoKSkge1xuICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNEb25lID0gdHJ1ZTtcbiAgICAgIHRpY2soKTtcbiAgICB9O1xuICAgIHNldHVwVGlja2VyKCk7XG4gICAgZmV0Y2goKTtcbiAgICByZXR1cm4gdGhpcy50aWNrZXI7XG4gIH1cbn1cbmNvbnN0IFJGQzMzMzlfUkVHRVggPSAvXlxcZHs0fS1cXGR7Mn0tXFxkezJ9VFxcZHsyfTpcXGR7Mn06XFxkezJ9KFxcLlxcZCspPyhafChbLStdXFxkezJ9OlxcZHsyfSkpJC87XG5mdW5jdGlvbiBwYXJzZVJGQzMzMzkoc3RyKSB7XG4gIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZm9ybWF0UkZDMzMzOShkKSB7XG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xuICBjb25zdCBtb250aCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTW9udGgoKSArIDEsIDIpO1xuICBjb25zdCBkYXkgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0RhdGUoKSwgMik7XG4gIGNvbnN0IGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpO1xuICBjb25zdCBtaW51dGUgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ01pbnV0ZXMoKSwgMik7XG4gIGNvbnN0IHNlY29uZCA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xuICBjb25zdCBtaWxsaXMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICBpZiAobWlsbGlzICE9IDApIHtcbiAgICBmcmFjdGlvbmFsU2Vjb25kID0gXCIuXCIuY29uY2F0KGFkZExlYWRpbmdaZXJvKG1pbGxpcywgMykpO1xuICB9XG4gIHJldHVybiBcIlwiLmNvbmNhdCh5ZWFyLCBcIi1cIikuY29uY2F0KG1vbnRoLCBcIi1cIikuY29uY2F0KGRheSwgXCJUXCIpLmNvbmNhdChob3VyLCBcIjpcIikuY29uY2F0KG1pbnV0ZSwgXCI6XCIpLmNvbmNhdChzZWNvbmQpLmNvbmNhdChmcmFjdGlvbmFsU2Vjb25kLCBcIlpcIik7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nWmVybyhudW0sIHRhcmdldExlbmd0aCkge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgc3RyID0gXCIwXCIuY29uY2F0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbnZhciBfX2RlZlByb3AkMyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMyhvYmosIGtleSwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICB2YWx1ZVxufSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQkMyA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wJDMob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuY2xhc3MgU3RhdGljVmFsdWUge1xuICBjb25zdHJ1Y3RvcihkYXRhLCB0eXBlKSB7XG4gICAgX19wdWJsaWNGaWVsZCQzKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDModGhpcywgXCJ0eXBlXCIpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBpc0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFwiYXJyYXlcIjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hd2FpdFxuICBhc3luYyBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YSkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgICB5aWVsZCBmcm9tSlMoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5kYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGl0ZXJhdGUgb3ZlcjogXCIuY29uY2F0KHRoaXMudHlwZSkpO1xuICB9XG59XG5jb25zdCBOVUxMX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKG51bGwsIFwibnVsbFwiKTtcbmNvbnN0IFRSVUVfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUodHJ1ZSwgXCJib29sZWFuXCIpO1xuY29uc3QgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsIFwiYm9vbGVhblwiKTtcbmNsYXNzIERhdGVUaW1lIHtcbiAgY29uc3RydWN0b3IoZGF0ZSkge1xuICAgIF9fcHVibGljRmllbGQkMyh0aGlzLCBcImRhdGVcIik7XG4gICAgdGhpcy5kYXRlID0gZGF0ZTtcbiAgfVxuICBzdGF0aWMgcGFyc2VUb1ZhbHVlKHN0cikge1xuICAgIGNvbnN0IGRhdGUgPSBwYXJzZVJGQzMzMzkoc3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShuZXcgRGF0ZVRpbWUoZGF0ZSksIFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIGFkZChzZWNzKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xuICAgIGNvcHkuc2V0VGltZShjb3B5LmdldFRpbWUoKSArIHNlY3MgKiAxZTMpO1xuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoY29weSk7XG4gIH1cbiAgZGlmZmVyZW5jZShvdGhlcikge1xuICAgIHJldHVybiAodGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgfVxuICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlLmdldFRpbWUoKSAtIG90aGVyLmRhdGUuZ2V0VGltZSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBmb3JtYXRSRkMzMzM5KHRoaXMuZGF0ZSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIobnVtKSB7XG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xuICAgIHJldHVybiBuZXcgU3RhdGljVmFsdWUobnVtLCBcIm51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyKSB7XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21EYXRlVGltZShkdCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xufVxuZnVuY3Rpb24gZnJvbVBhdGgocGF0aCkge1xuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKHBhdGgsIFwicGF0aFwiKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIG9iai5uZXh0ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XG4gIGlmIChpc0l0ZXJhdG9yKHZhbCkpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbCkge1xuICAgICAgICB5aWVsZCBmcm9tSlModmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUodmFsLCBnZXRUeXBlKHZhbCkpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsIHx8IHR5cGVvZiBkYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFwibnVsbFwiO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICByZXR1cm4gXCJwYXRoXCI7XG4gIH1cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlVGltZSkge1xuICAgIHJldHVybiBcImRhdGV0aW1lXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBkYXRhO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBhLmRhdGEgPT09IGIuZGF0YTtcbiAgfVxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICByZXR1cm4gYS5kYXRhLmVxdWFscyhiLmRhdGEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IENIQVJTID0gLyhbXiFAIyQlXiYqKCksXFxcXC8/XCI7Ont9fFtcXF0rPD5cXHMtXSkrL2c7XG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcbmNvbnN0IEVER0VfQ0hBUlMgPSAvKFxcYlxcLit8XFwuK1xcYikvZztcbmNvbnN0IE1BWF9URVJNX0xFTkdUSCA9IDEwMjQ7XG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xuICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCB8fCBwYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhdHRlcm5zLmV2ZXJ5KHBhdHRlcm4gPT4gcGF0dGVybih0b2tlbnMpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoVG9rZW5pemUodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKEVER0VfQ0hBUlMsIFwiXCIpLm1hdGNoKENIQVJTKSB8fCBbXTtcbn1cbmZ1bmN0aW9uIG1hdGNoQW5hbHl6ZVBhdHRlcm4odGV4dCkge1xuICBjb25zdCB0ZXJtc1JlID0gbWF0Y2hQYXR0ZXJuUmVnZXgodGV4dCk7XG4gIHJldHVybiB0ZXJtc1JlLm1hcChyZSA9PiB0b2tlbnMgPT4gdG9rZW5zLnNvbWUodG9rZW4gPT4gcmUudGVzdCh0b2tlbikpKTtcbn1cbmZ1bmN0aW9uIG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpIHtcbiAgY29uc3QgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XG4gIHJldHVybiB0ZXJtcy5tYXAodGVybSA9PiBuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh0ZXJtLnNsaWNlKDAsIE1BWF9URVJNX0xFTkdUSCkucmVwbGFjZSgvXFwqL2csIFwiLipcIiksIFwiJFwiKSwgXCJpXCIpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgY2IodmFsdWUuZGF0YSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmlzQXJyYXkoKSkge1xuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IHBhcnQgb2YgdmFsdWUpIHtcbiAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY2IocGFydC5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgVFlQRV9PUkRFUiA9IHtcbiAgZGF0ZXRpbWU6IDEsXG4gIG51bWJlcjogMixcbiAgc3RyaW5nOiAzLFxuICBib29sZWFuOiA0XG59O1xuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XG4gIGNvbnN0IGJUeXBlID0gZ2V0VHlwZShiKTtcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN3aXRjaCAoYVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBhIC0gYjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvdGFsQ29tcGFyZShhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xuICBjb25zdCBhVHlwZU9yZGVyID0gVFlQRV9PUkRFUlthVHlwZV0gfHwgMTAwO1xuICBjb25zdCBiVHlwZU9yZGVyID0gVFlQRV9PUkRFUltiVHlwZV0gfHwgMTAwO1xuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xuICAgIHJldHVybiBhVHlwZU9yZGVyIC0gYlR5cGVPcmRlcjtcbiAgfVxuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGVyYXRvcnMgPSB7XG4gIFwiPT1cIjogZnVuY3Rpb24gZXEobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gaXNFcXVhbChsZWZ0LCByaWdodCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gIH0sXG4gIFwiIT1cIjogZnVuY3Rpb24gbmVxKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xuICB9LFxuICBcIj5cIjogZnVuY3Rpb24gZ3QobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPiAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjxcIjogZnVuY3Rpb24gbHQobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIjw9XCI6IGZ1bmN0aW9uIGx0ZShsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyZWFtXCIgfHwgcmlnaHQudHlwZSA9PT0gXCJzdHJlYW1cIikgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCA8PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lLW1hdGNoaW5nXG4gIGluOiBhc3luYyBmdW5jdGlvbiBpbm9wKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKSB7XG4gICAgICBpZiAobGVmdC50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0LmRhdGEubWF0Y2hlcyhsZWZ0LmRhdGEpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAocmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGIgb2YgcmlnaHQpIHtcbiAgICAgICAgaWYgKGlzRXF1YWwobGVmdCwgYikpIHtcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgbWF0Y2g6IGFzeW5jIGZ1bmN0aW9uIG1hdGNoKGxlZnQsIHJpZ2h0KSB7XG4gICAgbGV0IHRva2VucyA9IFtdO1xuICAgIGxldCBwYXR0ZXJucyA9IFtdO1xuICAgIGF3YWl0IGdhdGhlclRleHQobGVmdCwgcGFydCA9PiB7XG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpZFN1Y2NlZWQgPSBhd2FpdCBnYXRoZXJUZXh0KHJpZ2h0LCBwYXJ0ID0+IHtcbiAgICAgIHBhdHRlcm5zID0gcGF0dGVybnMuY29uY2F0KG1hdGNoQW5hbHl6ZVBhdHRlcm4ocGFydCkpO1xuICAgIH0pO1xuICAgIGlmICghZGlkU3VjY2VlZCkge1xuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xuICAgIHJldHVybiBtYXRjaGVkID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmluZ1wiICYmIHJpZ2h0LnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGxlZnQuZGF0YSArIHJpZ2h0LmRhdGEpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcIm9iamVjdFwiICYmIHJpZ2h0LnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBmcm9tSlMoe1xuICAgICAgICAuLi5sZWZ0LmRhdGEsXG4gICAgICAgIC4uLnJpZ2h0LmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICByZXR1cm4gZnJvbUpTKGxlZnQuZGF0YS5jb25jYXQocmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIGxlZnQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWwgb2YgcmlnaHQpIHtcbiAgICAgICAgICB5aWVsZCB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWUobGVmdC5kYXRhLmFkZCgtcmlnaHQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEuZGlmZmVyZW5jZShyaWdodC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhIC0gcmlnaHQuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9LFxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXG4gIFwiL1wiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgLyBiKSxcbiAgXCIlXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAlIGIpLFxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXG59O1xuZnVuY3Rpb24gbnVtZXJpY09wZXJhdG9yKGltcGwpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xuICAgICAgcmV0dXJuIGZyb21OdW1iZXIocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH07XG59XG52YXIgX19kZWZQcm9wJDIgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wJDIob2JqLCBrZXksIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgdmFsdWVcbn0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkJDIgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcCQyKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIFNjb3BlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJwYXJhbXNcIik7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwic291cmNlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInZhbHVlXCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJjb250ZXh0XCIpO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImlzSGlkZGVuXCIsIGZhbHNlKTtcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBjcmVhdGVOZXN0ZWQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMpO1xuICB9XG4gIGNyZWF0ZUhpZGRlbih2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlTmVzdGVkKHZhbHVlKTtcbiAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vZGUsIHNjb3BlKSB7XG4gIGxldCBleGVjdXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBldmFsdWF0ZTtcbiAgY29uc3QgZnVuYyA9IEVYRUNVVE9SU1tub2RlLnR5cGVdO1xuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XG59XG5mdW5jdGlvbiBwcm9taXNlbGVzc0FwcGx5KHZhbHVlLCBjYikge1xuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUudGhlbihjYik7XG4gIH1cbiAgcmV0dXJuIGNiKHZhbHVlKTtcbn1cbmNvbnN0IEVYRUNVVE9SUyA9IHtcbiAgVGhpcyhfLCBzY29wZSkge1xuICAgIHJldHVybiBzY29wZS52YWx1ZTtcbiAgfSxcbiAgU2VsZWN0b3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VsZWN0b3JzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBFdmVyeXRoaW5nKF8sIHNjb3BlKSB7XG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcbiAgfSxcbiAgUGFyYW1ldGVyKF9yZWYsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnJvbUpTKHNjb3BlLnBhcmFtc1tuYW1lXSk7XG4gIH0sXG4gIENvbnRleHQoX3JlZjIsIHNjb3BlKSB7XG4gICAgbGV0IHtcbiAgICAgIGtleVxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAoa2V5ID09PSBcImJlZm9yZVwiIHx8IGtleSA9PT0gXCJhZnRlclwiKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNjb3BlLmNvbnRleHRba2V5XTtcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGNvbnRleHQga2V5OiBcIi5jb25jYXQoa2V5KSk7XG4gIH0sXG4gIFBhcmVudChfcmVmMywgc2NvcGUpIHtcbiAgICBsZXQge1xuICAgICAgblxuICAgIH0gPSBfcmVmMztcbiAgICBsZXQgY3VycmVudCA9IHNjb3BlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgfSxcbiAgT3BDYWxsKF9yZWY0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmNDtcbiAgICBjb25zdCBmdW5jID0gb3BlcmF0b3JzW29wXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3BlcmF0b3I6IFwiLmNvbmNhdChvcCkpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xuICAgIGlmIChcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSkge1xuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiBmdW5jKGF3YWl0IGxlZnRWYWx1ZSwgYXdhaXQgcmlnaHRWYWx1ZSkpKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gIH0sXG4gIGFzeW5jIFNlbGVjdChfcmVmNSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYWx0ZXJuYXRpdmVzLFxuICAgICAgZmFsbGJhY2tcbiAgICB9ID0gX3JlZjU7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0ZXJuYXRpdmVzKSB7XG4gICAgICBjb25zdCBhbHRDb25kID0gYXdhaXQgZXhlY3V0ZShhbHQuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGV4ZWN1dGUoYWx0LnZhbHVlLCBzY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGUoZmFsbGJhY2ssIHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEluUmFuZ2UoX3JlZjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XG4gICAgY29uc3QgbGVmdENtcCA9IHBhcnRpYWxDb21wYXJlKGF3YWl0IHZhbHVlLmdldCgpLCBhd2FpdCBsZWZ0VmFsdWUuZ2V0KCkpO1xuICAgIGlmIChsZWZ0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgcmlnaHRDbXAgPSBwYXJ0aWFsQ29tcGFyZShhd2FpdCB2YWx1ZS5nZXQoKSwgYXdhaXQgcmlnaHRWYWx1ZS5nZXQoKSk7XG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XG4gICAgICByZXR1cm4gbGVmdENtcCA+PSAwICYmIHJpZ2h0Q21wIDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xuICB9LFxuICBhc3luYyBGaWx0ZXIoX3JlZjcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWY3O1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGV4cHJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xuICAgICAgICBpZiAoZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBhc3luYyBQcm9qZWN0aW9uKF9yZWY4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgZXhwclxuICAgIH0gPSBfcmVmODtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xuICAgIHJldHVybiBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgfSxcbiAgRnVuY0NhbGwoX3JlZjksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGZ1bmMsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWY5O1xuICAgIHJldHVybiBmdW5jKGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgUGlwZUZ1bmNDYWxsKF9yZWYxMCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgZnVuYyxcbiAgICAgIGJhc2UsXG4gICAgICBhcmdzXG4gICAgfSA9IF9yZWYxMDtcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICByZXR1cm4gZnVuYyhiYXNlVmFsdWUsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKTtcbiAgfSxcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKF9yZWYxMSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZSxcbiAgICAgIG5hbWVcbiAgICB9ID0gX3JlZjExO1xuICAgIGxldCB2YWx1ZSA9IHNjb3BlLnZhbHVlO1xuICAgIGlmIChiYXNlKSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KUyh2YWx1ZS5kYXRhW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoX3JlZjEyLCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlLFxuICAgICAgaW5kZXhcbiAgICB9ID0gX3JlZjEyO1xuICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghYmFzZVZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgY29uc3QgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcbiAgICByZXR1cm4gZnJvbUpTKGRhdGFbZmluYWxJbmRleF0pO1xuICB9LFxuICBhc3luYyBTbGljZShfcmVmMTMsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBpc0luY2x1c2l2ZVxuICAgIH0gPSBfcmVmMTM7XG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKCFiYXNlVmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgY29uc3QgYXJyYXkgPSBhd2FpdCBiYXNlVmFsdWUuZ2V0KCk7XG4gICAgbGV0IGxlZnRJZHggPSBsZWZ0O1xuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xuICAgIGlmIChsZWZ0SWR4IDwgMCkge1xuICAgICAgbGVmdElkeCA9IGFycmF5Lmxlbmd0aCArIGxlZnRJZHg7XG4gICAgfVxuICAgIGlmIChyaWdodElkeCA8IDApIHtcbiAgICAgIHJpZ2h0SWR4ID0gYXJyYXkubGVuZ3RoICsgcmlnaHRJZHg7XG4gICAgfVxuICAgIGlmIChpc0luY2x1c2l2ZSkge1xuICAgICAgcmlnaHRJZHgrKztcbiAgICB9XG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XG4gICAgICBsZWZ0SWR4ID0gMDtcbiAgICB9XG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xuICAgICAgcmlnaHRJZHggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbUpTKGFycmF5LnNsaWNlKGxlZnRJZHgsIHJpZ2h0SWR4KSk7XG4gIH0sXG4gIGFzeW5jIERlcmVmKF9yZWYxNCwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMTQ7XG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcbiAgICBpZiAoIXNjb3BlLnNvdXJjZS5pc0FycmF5KCkpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdmFsdWUuZGF0YS5fcmVmO1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY29udGV4dC5kZXJlZmVyZW5jZSkge1xuICAgICAgcmV0dXJuIGZyb21KUyhhd2FpdCBzY29wZS5jb250ZXh0LmRlcmVmZXJlbmNlKHtcbiAgICAgICAgX3JlZjogaWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XG4gICAgICBpZiAoZG9jLnR5cGUgPT09IFwib2JqZWN0XCIgJiYgaWQgPT09IGRvYy5kYXRhLl9pZCkge1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgVmFsdWUoX3JlZjE1KSB7XG4gICAgbGV0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IF9yZWYxNTtcbiAgICByZXR1cm4gZnJvbUpTKHZhbHVlKTtcbiAgfSxcbiAgR3JvdXAoX3JlZjE2LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYxNjtcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gIH0sXG4gIGFzeW5jIE9iamVjdChfcmVmMTcsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gX3JlZjE3O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyVHlwZSA9IGF0dHIudHlwZTtcbiAgICAgIHN3aXRjaCAoYXR0ci50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XG4gICAgICAgICAgICByZXN1bHRbYXR0ci5uYW1lXSA9IGF3YWl0IHZhbHVlLmdldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmQgPSBhd2FpdCBleGVjdXRlKGF0dHIuY29uZGl0aW9uLCBzY29wZSk7XG4gICAgICAgICAgICBpZiAoY29uZC50eXBlICE9PSBcImJvb2xlYW5cIiB8fCBjb25kLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGF0dHIudmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB2YWx1ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIuY29uY2F0KGF0dHJUeXBlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcbiAgfSxcbiAgQXJyYXkoX3JlZjE4LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBfcmVmMTg7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShlbGVtZW50LnZhbHVlLCBzY29wZSk7XG4gICAgICAgIGlmIChlbGVtZW50LmlzU3BsYXQpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgeWllbGQgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgVHVwbGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xuICB9LFxuICBhc3luYyBPcihfcmVmMTksIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMTk7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyaWdodFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIEFuZChfcmVmMjAsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH0gPSBfcmVmMjA7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGlmIChyaWdodFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE5vdChfcmVmMjEsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIxO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XG4gIH0sXG4gIE5lZyhfcmVmMjIsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2VcbiAgICB9ID0gX3JlZjIyO1xuICAgIHJldHVybiBwcm9taXNlbGVzc0FwcGx5KGV4ZWN1dGUoYmFzZSwgc2NvcGUpLCB2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZS5kYXRhKTtcbiAgICB9KTtcbiAgfSxcbiAgUG9zKF9yZWYyMywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgICBsZXQge1xuICAgICAgYmFzZVxuICAgIH0gPSBfcmVmMjM7XG4gICAgcmV0dXJuIHByb21pc2VsZXNzQXBwbHkoZXhlY3V0ZShiYXNlLCBzY29wZSksIHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XG4gICAgfSk7XG4gIH0sXG4gIEFzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgRGVzYygpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfSxcbiAgYXN5bmMgQXJyYXlDb2VyY2UoX3JlZjI0LCBzY29wZSwgZXhlY3V0ZSkge1xuICAgIGxldCB7XG4gICAgICBiYXNlXG4gICAgfSA9IF9yZWYyNDtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIHJldHVybiB2YWx1ZS5pc0FycmF5KCkgPyB2YWx1ZSA6IE5VTExfVkFMVUU7XG4gIH0sXG4gIGFzeW5jIE1hcChfcmVmMjUsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICB5aWVsZCBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgYXN5bmMgRmxhdE1hcChfcmVmMjYsIHNjb3BlLCBleGVjdXRlKSB7XG4gICAgbGV0IHtcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSA9IF9yZWYyNjtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xuICAgIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlSGlkZGVuKGVsZW0pO1xuICAgICAgICBjb25zdCBpbm5lclZhbHVlID0gYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xuICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgaW5uZXIgb2YgaW5uZXJWYWx1ZSkge1xuICAgICAgICAgICAgeWllbGQgaW5uZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIGlubmVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGV2YWx1YXRlUXVlcnkodHJlZSkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcbiAgY29uc3QgZGF0YXNldCA9IGZyb21KUyhvcHRpb25zLmRhdGFzZXQpO1xuICBjb25zdCBwYXJhbXMgPSB7XG4gICAgLi4ub3B0aW9ucy5wYXJhbXNcbiAgfTtcbiAgY29uc3Qgc2NvcGUgPSBuZXcgU2NvcGUocGFyYW1zLCBkYXRhc2V0LCByb290LCB7XG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCB8fCAvKiBAX19QVVJFX18gKi9uZXcgRGF0ZSgpLFxuICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxuICAgIHNhbml0eTogb3B0aW9ucy5zYW5pdHksXG4gICAgYWZ0ZXI6IG9wdGlvbnMuYWZ0ZXIgPyBmcm9tSlMob3B0aW9ucy5hZnRlcikgOiBudWxsLFxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbCxcbiAgICBkZXJlZmVyZW5jZTogb3B0aW9ucy5kZXJlZmVyZW5jZVxuICB9LCBudWxsKTtcbiAgcmV0dXJuIGV2YWx1YXRlKHRyZWUsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiVmFsdWVcIjpcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiUG9zXCI6XG4gICAgY2FzZSBcIk5lZ1wiOlxuICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5iYXNlKTtcbiAgICBjYXNlIFwiT3BDYWxsXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgY2FzZSBcIioqXCI6XG4gICAgICAgICAgcmV0dXJuIGNhbkNvbnN0YW50RXZhbHVhdGUobm9kZS5sZWZ0KSAmJiBjYW5Db25zdGFudEV2YWx1YXRlKG5vZGUucmlnaHQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBEVU1NWV9TQ09QRSA9IG5ldyBTY29wZSh7fSwgTlVMTF9WQUxVRSwgTlVMTF9WQUxVRSwge1xuICB0aW1lc3RhbXA6IC8qIEBfX1BVUkVfXyAqL25ldyBEYXRlKDApLFxuICBpZGVudGl0eTogXCJtZVwiLFxuICBiZWZvcmU6IG51bGwsXG4gIGFmdGVyOiBudWxsXG59LCBudWxsKTtcbmZ1bmN0aW9uIHRyeUNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBpZiAoIWNhbkNvbnN0YW50RXZhbHVhdGUobm9kZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY29uc3RhbnRFdmFsdWF0ZShub2RlKTtcbn1cbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xuICBjb25zdCB2YWx1ZSA9IGV2YWx1YXRlKG5vZGUsIERVTU1ZX1NDT1BFLCBjb25zdGFudEV2YWx1YXRlKTtcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiBjb25zdGFudCBldmFsdWF0ZSBzaG91bGQgbmV2ZXIgcmV0dXJuIGEgcHJvbWlzZVwiKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5hc3luYyBmdW5jdGlvbiBwb3J0YWJsZVRleHRDb250ZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGJsb2NrVGV4dCh2YWx1ZS5kYXRhKTtcbiAgfSBlbHNlIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcbiAgICBjb25zdCB0ZXh0cyA9IGF3YWl0IGFycmF5VGV4dCh2YWx1ZSk7XG4gICAgaWYgKHRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFycmF5VGV4dCh2YWx1ZSkge1xuICBsZXQgcmVzdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgZm9yIGF3YWl0IChjb25zdCBibG9jayBvZiB2YWx1ZSkge1xuICAgIGlmIChibG9jay50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYmxvY2tUZXh0KGJsb2NrLmRhdGEpO1xuICAgICAgaWYgKHRleHQgIT09IG51bGwpIHJlc3VsdC5wdXNoKHRleHQpO1xuICAgIH0gZWxzZSBpZiAoYmxvY2suaXNBcnJheSgpKSB7XG4gICAgICBhd2FpdCBhcnJheVRleHQoYmxvY2ssIHJlc3VsdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBibG9ja1RleHQob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqLl90eXBlICE9PSBcInN0cmluZ1wiKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHJldHVybiBudWxsO1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNoaWxkLl90eXBlID09PSBcInN0cmluZ1wiICYmIGNoaWxkLl90eXBlID09PSBcInNwYW5cIiAmJiB0eXBlb2YgY2hpbGQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBCTTI1ayA9IDEuMjtcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcENhbGxcIiAmJiBub2RlLm9wID09PSBcIm1hdGNoXCIpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVNYXRjaFNjb3JlKG5vZGUubGVmdCwgbm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IFwiRnVuY0NhbGxcIiAmJiBub2RlLm5hbWUgPT09IFwiYm9vc3RcIikge1xuICAgIGNvbnN0IGlubmVyU2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUuYXJnc1swXSwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgIGNvbnN0IGJvb3N0ID0gYXdhaXQgZXhlY3V0ZShub2RlLmFyZ3NbMV0sIHNjb3BlKTtcbiAgICBpZiAoYm9vc3QudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbm5lclNjb3JlID4gMCkge1xuICAgICAgcmV0dXJuIGlubmVyU2NvcmUgKyBib29zdC5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPclwiOlxuICAgICAge1xuICAgICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XG4gICAgICAgIHJldHVybiBsZWZ0U2NvcmUgKyByaWdodFNjb3JlO1xuICAgICAgfVxuICAgIGNhc2UgXCJBbmRcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcbiAgICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xuICAgICAgICBpZiAobGVmdFNjb3JlID09PSAwIHx8IHJpZ2h0U2NvcmUgPT09IDApIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBleGVjdXRlKG5vZGUsIHNjb3BlKTtcbiAgICAgICAgcmV0dXJuIHJlcy50eXBlID09PSBcImJvb2xlYW5cIiAmJiByZXMuZGF0YSA9PT0gdHJ1ZSA/IDEgOiAwO1xuICAgICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZU1hdGNoU2NvcmUobGVmdCwgcmlnaHQsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHRleHQgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcbiAgbGV0IHRva2VucyA9IFtdO1xuICBsZXQgdGVybXMgPSBbXTtcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCBwYXJ0ID0+IHtcbiAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xuICB9KTtcbiAgY29uc3QgZGlkU3VjY2VlZCA9IGF3YWl0IGdhdGhlclRleHQocGF0dGVybiwgcGFydCA9PiB7XG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xuICB9KTtcbiAgaWYgKCFkaWRTdWNjZWVkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHRva2Vucy5sZW5ndGggPT09IDAgfHwgdGVybXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHNjb3JlID0gMDtcbiAgZm9yIChjb25zdCByZSBvZiB0ZXJtcykge1xuICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMucmVkdWNlKChjLCB0b2tlbikgPT4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKSwgMCk7XG4gICAgc2NvcmUgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XG4gIH1cbiAgcmV0dXJuIHNjb3JlO1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XG4gIHN3aXRjaCAoZ2V0VHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmICh2YWx1ZS5fcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXRoU2V0Lmhhcyh2YWx1ZS5fcmVmKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdiBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAoaGFzUmVmZXJlbmNlKHYsIHBhdGhTZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvdW50VVRGOChzdHIpIHtcbiAgbGV0IGNvdW50MiA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID49IDU1Mjk2ICYmIGNvZGUgPD0gNTYzMTkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb3VudDIrKztcbiAgfVxuICByZXR1cm4gY291bnQyO1xufVxuY29uc3QgX2dsb2JhbCA9IHt9O1xuX2dsb2JhbC5hbnl3aGVyZSA9IGFzeW5jIGZ1bmN0aW9uIGFueXdoZXJlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuX2dsb2JhbC5hbnl3aGVyZS5hcml0eSA9IDE7XG5fZ2xvYmFsLmNvYWxlc2NlID0gYXN5bmMgZnVuY3Rpb24gY29hbGVzY2UoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmcsIHNjb3BlKTtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghaW5uZXIuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgbGV0IG51bSA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgIG51bSsrO1xuICB9XG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG59O1xuX2dsb2JhbC5jb3VudC5hcml0eSA9IDE7XG5fZ2xvYmFsLmRhdGVUaW1lID0gYXN5bmMgZnVuY3Rpb24gZGF0ZVRpbWUoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWwudHlwZSA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodmFsLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gRGF0ZVRpbWUucGFyc2VUb1ZhbHVlKHZhbC5kYXRhKTtcbn07XG5fZ2xvYmFsLmRhdGVUaW1lLmFyaXR5ID0gMTtcbl9nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgcmV0dXJuIGlubmVyLnR5cGUgPT09IFwibnVsbFwiID8gRkFMU0VfVkFMVUUgOiBUUlVFX1ZBTFVFO1xufTtcbl9nbG9iYWwuZGVmaW5lZC5hcml0eSA9IDE7XG5fZ2xvYmFsLmlkZW50aXR5ID0gYXN5bmMgZnVuY3Rpb24gaWRlbnRpdHkoYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5pZGVudGl0eSk7XG59O1xuX2dsb2JhbC5pZGVudGl0eS5hcml0eSA9IDA7XG5fZ2xvYmFsLmxlbmd0aCA9IGFzeW5jIGZ1bmN0aW9uIGxlbmd0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKGNvdW50VVRGOChpbm5lci5kYXRhKSk7XG4gIH1cbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xuICAgIGxldCBudW0gPSAwO1xuICAgIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xuICAgICAgbnVtKys7XG4gICAgfVxuICAgIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuX2dsb2JhbC5sZW5ndGguYXJpdHkgPSAxO1xuX2dsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoaW5uZXIudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBmcm9tUGF0aChuZXcgUGF0aChpbm5lci5kYXRhKSk7XG59O1xuX2dsb2JhbC5wYXRoLmFyaXR5ID0gMTtcbl9nbG9iYWwuc3RyaW5nID0gYXN5bmMgZnVuY3Rpb24gc3RyaW5nKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIuY29uY2F0KHZhbHVlLmRhdGEpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbn07XG5fZ2xvYmFsLnN0cmluZy5hcml0eSA9IDE7XG5fZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHBhdGhTZXQgPSAvKiBAX19QVVJFX18gKi9uZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICBjb25zdCBwYXRoMiA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XG4gICAgaWYgKHBhdGgyLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHBhdGhTZXQuYWRkKHBhdGgyLmRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKSB7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgcGF0aDIpIHtcbiAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBhdGhTZXQuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcbiAgfVxuICBjb25zdCBzY29wZVZhbHVlID0gYXdhaXQgc2NvcGUudmFsdWUuZ2V0KCk7XG4gIHJldHVybiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XG59O1xuX2dsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gYyA9PiBjID49IDE7XG5fZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBjb25zdCBudW0gPSB2YWx1ZS5kYXRhO1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByZWNWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xuICB9XG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKC1NYXRoLnJvdW5kKC1udW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKTtcbiAgfVxuICByZXR1cm4gZnJvbU51bWJlcihOdW1iZXIobnVtLnRvRml4ZWQocHJlYykpKTtcbn07XG5fZ2xvYmFsLnJvdW5kLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xuX2dsb2JhbC5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3coYXJncywgc2NvcGUpIHtcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG59O1xuX2dsb2JhbC5ub3cuYXJpdHkgPSAwO1xuX2dsb2JhbC5ib29zdCA9IGFzeW5jIGZ1bmN0aW9uIGJvb3N0KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XG59O1xuX2dsb2JhbC5ib29zdC5hcml0eSA9IDI7XG5jb25zdCBzdHJpbmcyID0ge307XG5zdHJpbmcyLmxvd2VyID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b0xvd2VyQ2FzZSgpKTtcbn07XG5zdHJpbmcyLmxvd2VyLmFyaXR5ID0gMTtcbnN0cmluZzIudXBwZXIgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHZhbHVlLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZS5kYXRhLnRvVXBwZXJDYXNlKCkpO1xufTtcbnN0cmluZzIudXBwZXIuYXJpdHkgPSAxO1xuc3RyaW5nMi5zcGxpdCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3Qgc2VwID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChzZXAudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGlmIChzdHIuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnJvbUpTKFtdKTtcbiAgfVxuICBpZiAoc2VwLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZyb21KUyhBcnJheS5mcm9tKHN0ci5kYXRhKSk7XG4gIH1cbiAgcmV0dXJuIGZyb21KUyhzdHIuZGF0YS5zcGxpdChzZXAuZGF0YSkpO1xufTtcbnN0cmluZzIuc3BsaXQuYXJpdHkgPSAyO1xuX2dsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XG5fZ2xvYmFsLnVwcGVyID0gc3RyaW5nMi51cHBlcjtcbnN0cmluZzIuc3RhcnRzV2l0aCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCBzdHIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcbiAgaWYgKHN0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gYXdhaXQgZXhlY3V0ZShhcmdzWzFdLCBzY29wZSk7XG4gIGlmIChwcmVmaXgudHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIHJldHVybiBzdHIuZGF0YS5zdGFydHNXaXRoKHByZWZpeC5kYXRhKSA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcbn07XG5zdHJpbmcyLnN0YXJ0c1dpdGguYXJpdHkgPSAyO1xuY29uc3QgYXJyYXkgPSB7fTtcbmFycmF5LmpvaW4gPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IHNlcCA9IGF3YWl0IGV4ZWN1dGUoYXJnc1sxXSwgc2NvcGUpO1xuICBpZiAoc2VwLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgYnVmID0gXCJcIjtcbiAgbGV0IG5lZWRTZXAgPSBmYWxzZTtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChuZWVkU2VwKSB7XG4gICAgICBidWYgKz0gc2VwLmRhdGE7XG4gICAgfVxuICAgIHN3aXRjaCAoZWxlbS50eXBlKSB7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgIGJ1ZiArPSBcIlwiLmNvbmNhdChlbGVtLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuZWVkU2VwID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKGJ1Zik7XG59O1xuYXJyYXkuam9pbi5hcml0eSA9IDI7XG5hcnJheS5jb21wYWN0ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudWxsXCIpIHtcbiAgICAgICAgeWllbGQgZWxlbTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LmNvbXBhY3QuYXJpdHkgPSAxO1xuYXJyYXkudW5pcXVlID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghdmFsdWUuaXNBcnJheSgpKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovbmV3IFNldCgpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgaXRlciBvZiB2YWx1ZSkge1xuICAgICAgc3dpdGNoIChpdGVyLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGlmICghYWRkZWQuaGFzKGl0ZXIuZGF0YSkpIHtcbiAgICAgICAgICAgIGFkZGVkLmFkZChpdGVyLmRhdGEpO1xuICAgICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgeWllbGQgaXRlcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcbmFycmF5LnVuaXF1ZS5hcml0eSA9IDE7XG5jb25zdCBwdCA9IHt9O1xucHQudGV4dCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBjb25zdCB0ZXh0ID0gYXdhaXQgcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSk7XG4gIGlmICh0ZXh0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gIH1cbiAgcmV0dXJuIGZyb21TdHJpbmcodGV4dCk7XG59O1xucHQudGV4dC5hcml0eSA9IDE7XG5jb25zdCBzYW5pdHkgPSB7fTtcbnNhbml0eS5wcm9qZWN0SWQgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUpIHtcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkucHJvamVjdElkKTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5zYW5pdHkuZGF0YXNldCA9IGFzeW5jIGZ1bmN0aW9uIChhcmdzLCBzY29wZSkge1xuICBpZiAoc2NvcGUuY29udGV4dC5zYW5pdHkpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5kYXRhc2V0KTtcbiAgfVxuICByZXR1cm4gTlVMTF9WQUxVRTtcbn07XG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XG5waXBlRnVuY3Rpb25zLm9yZGVyID0gYXN5bmMgZnVuY3Rpb24gb3JkZXIoYmFzZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgYXdhaXQgdHJ1ZTtcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcbiAgY29uc3QgZGlyZWN0aW9ucyA9IFtdO1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IFwiYXNjXCI7XG4gICAgaWYgKG1hcHBlci50eXBlID09PSBcIkRlc2NcIikge1xuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlci50eXBlID09PSBcIkFzY1wiKSB7XG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcbiAgICB9XG4gICAgbWFwcGVycy5wdXNoKG1hcHBlcik7XG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG4gICAgbisrO1xuICB9XG4gIGNvbnN0IGF1eCA9IFtdO1xuICBsZXQgaWR4ID0gMDtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xuICAgIGNvbnN0IHR1cGxlID0gW2F3YWl0IHZhbHVlLmdldCgpLCBpZHhdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcbiAgICAgIHR1cGxlLnB1c2goYXdhaXQgcmVzdWx0LmdldCgpKTtcbiAgICB9XG4gICAgYXV4LnB1c2godHVwbGUpO1xuICAgIGlkeCsrO1xuICB9XG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBsZXQgYyA9IHRvdGFsQ29tcGFyZShhVHVwbGVbaSArIDJdLCBiVHVwbGVbaSArIDJdKTtcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xuICAgICAgICBjID0gLWM7XG4gICAgICB9XG4gICAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFUdXBsZVsxXSAtIGJUdXBsZVsxXTtcbiAgfSk7XG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCh2ID0+IHZbMF0pKTtcbn07XG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gY291bnQyID0+IGNvdW50MiA+PSAxO1xucGlwZUZ1bmN0aW9ucy5zY29yZSA9IGFzeW5jIGZ1bmN0aW9uIHNjb3JlKGJhc2UsIGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGlmICghYmFzZS5pc0FycmF5KCkpIHJldHVybiBOVUxMX1ZBTFVFO1xuICBjb25zdCB1bmtub3duID0gW107XG4gIGNvbnN0IHNjb3JlZCA9IFtdO1xuICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGJhc2UpIHtcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdW5rbm93bi5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XG4gICAgbGV0IHZhbHVlU2NvcmUgPSB0eXBlb2YgdmFsdWUuZGF0YS5fc2NvcmUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS5kYXRhLl9zY29yZSA6IDA7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgdmFsdWVTY29yZSArPSBhd2FpdCBldmFsdWF0ZVNjb3JlKGFyZywgbmV3U2NvcGUsIGV4ZWN1dGUpO1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7XG4gICAgICBfc2NvcmU6IHZhbHVlU2NvcmVcbiAgICB9KTtcbiAgICBzY29yZWQucHVzaChuZXdPYmplY3QpO1xuICB9XG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcbiAgcmV0dXJuIGZyb21KUyhzY29yZWQpO1xufTtcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSBjb3VudDIgPT4gY291bnQyID49IDE7XG5jb25zdCBkZWx0YSA9IHt9O1xuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlKSB7XG4gIGNvbnN0IGhhc0JlZm9yZSA9IHNjb3BlLmNvbnRleHQuYmVmb3JlICE9PSBudWxsO1xuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XG4gIGlmIChoYXNCZWZvcmUgJiYgaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcInVwZGF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQWZ0ZXIpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhcImNyZWF0ZVwiKTtcbiAgfVxuICBpZiAoaGFzQmVmb3JlKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWxldGVcIik7XG4gIH1cbiAgcmV0dXJuIE5VTExfVkFMVUU7XG59O1xuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xufTtcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xuZGVsdGEuY2hhbmdlZEFueS5tb2RlID0gXCJkZWx0YVwiO1xuZGVsdGEuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kZWx0YS5jaGFuZ2VkT25seS5hcml0eSA9IDE7XG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xuY29uc3QgZGlmZiA9IHt9O1xuZGlmZi5jaGFuZ2VkQW55ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG59O1xuZGlmZi5jaGFuZ2VkQW55LmFyaXR5ID0gMztcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbn07XG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcbmNvbnN0IG1hdGggPSB7fTtcbm1hdGgubWluID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPCBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWluLmFyaXR5ID0gMTtcbm1hdGgubWF4ID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbjtcbiAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIGFycikge1xuICAgIGlmIChlbGVtLnR5cGUgPT09IFwibnVsbFwiKSBjb250aW51ZTtcbiAgICBpZiAoZWxlbS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgICB9XG4gICAgaWYgKG4gPT09IHZvaWQgMCB8fCBlbGVtLmRhdGEgPiBuKSB7XG4gICAgICBuID0gZWxlbS5kYXRhO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbUpTKG4pO1xufTtcbm1hdGgubWF4LmFyaXR5ID0gMTtcbm1hdGguc3VtID0gYXN5bmMgZnVuY3Rpb24gKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIGNvbnN0IGFyciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xuICBpZiAoIWFyci5pc0FycmF5KCkpIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICBsZXQgbiA9IDA7XG4gIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBhcnIpIHtcbiAgICBpZiAoZWxlbS50eXBlID09PSBcIm51bGxcIikgY29udGludWU7XG4gICAgaWYgKGVsZW0udHlwZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XG4gICAgfVxuICAgIG4gKz0gZWxlbS5kYXRhO1xuICB9XG4gIHJldHVybiBmcm9tSlMobik7XG59O1xubWF0aC5zdW0uYXJpdHkgPSAxO1xubWF0aC5hdmcgPSBhc3luYyBmdW5jdGlvbiAoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcbiAgY29uc3QgYXJyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XG4gIGlmICghYXJyLmlzQXJyYXkoKSkge1xuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICB9XG4gIGxldCBuID0gMDtcbiAgbGV0IGMgPSAwO1xuICBmb3IgYXdhaXQgKGNvbnN0IGVsZW0gb2YgYXJyKSB7XG4gICAgaWYgKGVsZW0udHlwZSA9PT0gXCJudWxsXCIpIGNvbnRpbnVlO1xuICAgIGlmIChlbGVtLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xuICAgIH1cbiAgICBuICs9IGVsZW0uZGF0YTtcbiAgICBjKys7XG4gIH1cbiAgaWYgKGMgPT09IDApIHtcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcbiAgfVxuICByZXR1cm4gZnJvbUpTKG4gLyBjKTtcbn07XG5tYXRoLmF2Zy5hcml0eSA9IDE7XG5jb25zdCBkYXRlVGltZTIgPSB7fTtcbmRhdGVUaW1lMi5ub3cgPSBhc3luYyBmdW5jdGlvbiBub3cyKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XG4gIHJldHVybiBmcm9tRGF0ZVRpbWUobmV3IERhdGVUaW1lKHNjb3BlLmNvbnRleHQudGltZXN0YW1wKSk7XG59O1xuZGF0ZVRpbWUyLm5vdy5hcml0eSA9IDA7XG5jb25zdCBuYW1lc3BhY2VzID0ge1xuICBnbG9iYWw6IF9nbG9iYWwsXG4gIHN0cmluZzogc3RyaW5nMixcbiAgYXJyYXksXG4gIHB0LFxuICBkZWx0YSxcbiAgZGlmZixcbiAgc2FuaXR5LFxuICBtYXRoLFxuICBkYXRlVGltZTogZGF0ZVRpbWUyXG59O1xudmFyIF9fZGVmUHJvcCQxID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcbiAgY29uc3RydWN0b3Ioc3RyaW5nLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwic3RyaW5nXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm1hcmtzXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcInBhcnNlT3B0aW9uc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJhbGxvd0Jvb3N0XCIsIGZhbHNlKTtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XG4gIH1cbiAgaGFzTWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLmluZGV4ICsgcG9zIDwgdGhpcy5tYXJrcy5sZW5ndGg7XG4gIH1cbiAgZ2V0TWFyaygpIHtcbiAgICBsZXQgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHJldHVybiB0aGlzLm1hcmtzW3RoaXMuaW5kZXggKyBwb3NdO1xuICB9XG4gIHNoaWZ0KCkge1xuICAgIHRoaXMuaW5kZXggKz0gMTtcbiAgfVxuICBwcm9jZXNzKHZpc2l0b3IpIHtcbiAgICBjb25zdCBtYXJrID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgY29uc3QgZnVuYyA9IHZpc2l0b3JbbWFyay5uYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gaGFuZGxlcjogXCIuY29uY2F0KG1hcmsubmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5jYWxsKHZpc2l0b3IsIHRoaXMsIG1hcmspO1xuICB9XG4gIHByb2Nlc3NTdHJpbmcoKSB7XG4gICAgdGhpcy5zaGlmdCgpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgfVxuICBwcm9jZXNzU3RyaW5nRW5kKCkge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXggLSAxXTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHByZXYucG9zaXRpb24sIGN1cnIucG9zaXRpb24pO1xuICB9XG4gIHNsaWNlKGxlbikge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubWFya3NbdGhpcy5pbmRleF0ucG9zaXRpb247XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcbiAgfVxufVxuY29uc3QgV1MgPSAvXihbXFx0XFxuXFx2XFxmXFxyIFxcdTAwODVcXHUwMEEwXXwoXFwvXFwvW15cXG5dKlxcbikpKy87XG5jb25zdCBOVU0gPSAvXlxcZCsvO1xuY29uc3QgSURFTlQgPSAvXlthLXpBLVpfXVthLXpBLVpfMC05XSovO1xuY29uc3QgUFJFQ19QQUlSID0gMTtcbmNvbnN0IFBSRUNfT1IgPSAyO1xuY29uc3QgUFJFQ19BTkQgPSAzO1xuY29uc3QgUFJFQ19DT01QID0gNDtcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xuY29uc3QgUFJFQ19BREQgPSA2O1xuY29uc3QgUFJFQ19TVUIgPSA2O1xuY29uc3QgUFJFQ19NVUwgPSA3O1xuY29uc3QgUFJFQ19ESVYgPSA3O1xuY29uc3QgUFJFQ19NT0QgPSA3O1xuY29uc3QgUFJFQ19QT1cgPSA4O1xuY29uc3QgUFJFQ19QT1MgPSAxMDtcbmNvbnN0IFBSRUNfTk9UID0gMTA7XG5jb25zdCBQUkVDX05FRyA9IDg7XG5mdW5jdGlvbiBwYXJzZSQxKHN0cikge1xuICBsZXQgcG9zID0gMDtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdC5mYWlsUG9zaXRpb24pIHtcbiAgICAgIHBvcyA9IHJlc3VsdC5mYWlsUG9zaXRpb24gLSAxO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH07XG4gIH1cbiAgZGVsZXRlIHJlc3VsdC5wb3NpdGlvbjtcbiAgZGVsZXRlIHJlc3VsdC5mYWlsUG9zaXRpb247XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyLCBwb3MsIGxldmVsKSB7XG4gIGxldCBzdGFydFBvcyA9IHBvcztcbiAgbGV0IHRva2VuID0gc3RyW3Bvc107XG4gIGxldCBtYXJrcztcbiAgc3dpdGNoICh0b2tlbikge1xuICAgIGNhc2UgXCIrXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19QT1MpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwicG9zXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCItXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgIG5hbWU6IFwibmVnXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH1dLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCIoXCI6XG4gICAgICB7XG4gICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgMCk7XG4gICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByaHMucG9zaXRpb24pO1xuICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgICAgfV0uY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInR1cGxlX2VuZFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJncm91cFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiIVwiOlxuICAgICAge1xuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfTk9UKTtcbiAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgICBuYW1lOiBcIm5vdFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICB9XS5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwie1wiOlxuICAgICAge1xuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIG1hcmtzID0gW3tcbiAgICAgICAgbmFtZTogXCJhcnJheVwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9XTtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UocG9zLCBwb3MgKyAzKSA9PT0gXCIuLi5cIikge1xuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYXJyYXlfc3BsYXRcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgICAgaWYgKHJlcy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzLm1hcmtzKTtcbiAgICAgICAgICBwb3MgPSByZXMucG9zaXRpb247XG4gICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKSBicmVhaztcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIl1cIikge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJhcnJheV9lbmRcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcbiAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIFwiXlwiOlxuICAgICAge1xuICAgICAgICBwb3MrKztcbiAgICAgICAgbWFya3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcImRibHBhcmVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJwYXJlbnRcIixcbiAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJAXCI6XG4gICAgICBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwidGhpc1wiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH1dO1xuICAgICAgcG9zKys7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiKlwiOlxuICAgICAgbWFya3MgPSBbe1xuICAgICAgICBuYW1lOiBcImV2ZXJ5dGhpbmdcIixcbiAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICB9XTtcbiAgICAgIHBvcysrO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIHtcbiAgICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIHBvcyArIDEsIElERU5UKTtcbiAgICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgICAgcG9zICs9IDEgKyBpZGVudExlbjtcbiAgICAgICAgICBtYXJrcyA9IFt7XG4gICAgICAgICAgICBuYW1lOiBcInBhcmFtXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3MgKyAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcbiAgICAgICAgaWYgKG51bUxlbikge1xuICAgICAgICAgIHBvcyArPSBudW1MZW47XG4gICAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xuICAgICAgICAgICAgaWYgKGZyYWNMZW4pIHtcbiAgICAgICAgICAgICAgbmFtZSA9IFwiZmxvYXRcIjtcbiAgICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xuICAgICAgICAgICAgbmFtZSA9IFwic2NpXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XG4gICAgICAgICAgICBpZiAoIWV4cExlbikgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zICs9IGV4cExlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUgKyBcIl9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XG4gICAgICAgIGlmIChpZGVudExlbikge1xuICAgICAgICAgIHBvcyArPSBpZGVudExlbjtcbiAgICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XG4gICAgICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBbe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJ0aGlzX2F0dHJcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBpZiAoIW1hcmtzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIGxldCBsaHNMZXZlbCA9IDEyO1xuICBsZXQgdHJhdjtcbiAgbG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgIGlmIChpbm5lclBvcyA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgcG9zID0gaW5uZXJQb3M7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdHJhdiA9IHBhcnNlVHJhdmVyc2FsKHN0ciwgaW5uZXJQb3MpO1xuICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgbmFtZTogXCJ0cmF2ZXJzZVwiLFxuICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgIH0pO1xuICAgICAgd2hpbGUgKHRyYXYudHlwZSA9PT0gXCJzdWNjZXNzXCIpIHtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQodHJhdi5tYXJrcyk7XG4gICAgICAgIHBvcyA9IHRyYXYucG9zaXRpb247XG4gICAgICAgIHRyYXYgPSBwYXJzZVRyYXZlcnNhbChzdHIsIHNraXBXUyhzdHIsIHBvcykpO1xuICAgICAgfVxuICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgIG5hbWU6IFwidHJhdmVyc2FsX2VuZFwiLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdG9rZW4yID0gc3RyW2lubmVyUG9zXTtcbiAgICBzd2l0Y2ggKHRva2VuMikge1xuICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcbiAgICAgICAgICBzd2l0Y2ggKG5leHRUb2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfUEFJUiB8fCBsaHNMZXZlbCA8PSBQUkVDX1BBSVIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUEFJUik7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGFpclwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19QQUlSO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvcyArIDJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0FERCB8fCBsaHNMZXZlbCA8IFBSRUNfQUREKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImFkZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1NVQiB8fCBsaHNMZXZlbCA8IFBSRUNfU1VCKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcInN1YlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoc3RyW2lubmVyUG9zICsgMV0gPT09IFwiKlwiKSB7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVykgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCByaHMyID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QT1cpO1xuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzMjtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJoczIubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwicG93XCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3MgPSByaHMyLnBvc2l0aW9uO1xuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BPVztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01VTCB8fCBsaHNMZXZlbCA8IFBSRUNfTVVMKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01VTCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm11bFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NVUw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0RJViB8fCBsaHNMZXZlbCA8IFBSRUNfRElWKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0RJViArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19ESVY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCIlXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01PRCB8fCBsaHNMZXZlbCA8IFBSRUNfTU9EKSBicmVhayBsb29wO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX01PRCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcIm1vZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19NT0Q7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcbiAgICAgICAgICBpZiAoc3RyW25leHRQb3NdID09PSBcIj1cIikge1xuICAgICAgICAgICAgbmV4dFBvcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyksIFBSRUNfQ09NUCArIDEpO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvc1xuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwib3BfZW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogbmV4dFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwifFwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1IpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xuICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwib3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSkgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIGxldCBpZGVudFBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSk7XG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcbiAgICAgICAgICAgIGlmICghaWRlbnRMZW4pIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IGlkZW50UG9zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zID0gaWRlbnRQb3MgKyBpZGVudExlbjtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIoXCIgfHwgc3RyW3Bvc10gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInBpcGVjYWxsXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICAgICAgICAgIGxoc0xldmVsID0gMTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiJlwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQU5EIHx8IGxoc0xldmVsIDwgUFJFQ19BTkQpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfQU5EICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYW5kXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0FORDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHJbaW5uZXJQb3MgKyAxXSAhPT0gXCI9XCIpIGJyZWFrIGxvb3A7XG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19DT01QIHx8IGxoc0xldmVsIDw9IFBSRUNfQ09NUCkgYnJlYWsgbG9vcDtcbiAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByaHM7XG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgICBuYW1lOiBcImNvbXBcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBpbm5lclBvcyArIDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcbiAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiKSBicmVhayBsb29wO1xuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfT1JERVIgfHwgbGhzTGV2ZWwgPCBQUkVDX09SREVSKSBicmVhayBsb29wO1xuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJkZXNjXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDQ7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHN0ci5zbGljZShpbm5lclBvcywgaW5uZXJQb3MgKyAzKSAhPT0gXCJhc2NcIikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SREVSIHx8IGxoc0xldmVsIDwgUFJFQ19PUkRFUikgYnJlYWsgbG9vcDtcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgIG5hbWU6IFwiYXNjXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MgPSBpbm5lclBvcyArIDM7XG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IGlkZW50ID0gcGFyc2VSZWdleFN0cihzdHIsIGlubmVyUG9zLCBJREVOVCk7XG4gICAgICAgICAgc3dpdGNoIChpZGVudCkge1xuICAgICAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XG4gICAgICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB0eXBlID0gXCJpbmNfcmFuZ2VcIjtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XG4gICAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImluX3JhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiByYW5nZVBvc1xuICAgICAgICAgICAgICAgICAgfSwgcmVzdWx0Lm1hcmtzLCByaHMubWFya3MpO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJjb21wXCIsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJvcF9lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgMlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKSBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDUpLCBQUkVDX0NPTVAgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHJocztcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwiY29tcFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wXCIsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogaW5uZXJQb3NcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm9wX2VuZFwiLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IGlubmVyUG9zICsgNVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XG4gICAgICAgICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGxoc0xldmVsID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGZhaWxQb3NpdGlvbiA9ICh0cmF2ID09IG51bGwgPyB2b2lkIDAgOiB0cmF2LnR5cGUpID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zLFxuICAgIGZhaWxQb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VUcmF2ZXJzYWwoc3RyLCBwb3MpIHtcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xuICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgY2FzZSBcIi5cIjpcbiAgICAgIHtcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gICAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xuICAgICAgICBsZXQgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgICAgICBpZiAoIWlkZW50TGVuMikgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgICBwb3MgKz0gaWRlbnRMZW4yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhdHRyX2FjY2Vzc1wiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IGlkZW50U3RhcnRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICAgIH1dLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwiLVwiOlxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgfTtcbiAgICAgIGxldCBtYXJrcyA9IFt7XG4gICAgICAgIG5hbWU6IFwiZGVyZWZcIixcbiAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICB9XTtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBpZGVudFBvcywgSURFTlQpO1xuICAgICAgaWYgKGlkZW50TGVuKSB7XG4gICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwiZGVyZWZfYXR0clwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBpZGVudFBvc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBpZGVudFBvc1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIG1hcmtzLFxuICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICB9O1xuICAgIGNhc2UgXCJbXCI6XG4gICAgICB7XG4gICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgbWFya3M6IFt7XG4gICAgICAgICAgICAgIG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVBvcyA9IHBvcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiICYmIHN0cltwb3MgKyAxXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAyXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcImV4Y19yYW5nZVwiO1xuICAgICAgICAgICAgcG9zICs9IDM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmhzO1xuICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgICBuYW1lOiBcInNsaWNlXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogcmFuZ2VQb3NcbiAgICAgICAgICAgIH1dLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIikgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBvc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIG1hcmtzOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJzcXVhcmVfYnJhY2tldFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgICAgfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXG4gICAgICAgICAgcG9zaXRpb246IHBvcyArIDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBjYXNlIFwifFwiOlxuICAgICAge1xuICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIntcIikge1xuICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgbmFtZTogXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgXCJ7XCI6XG4gICAgICB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU9iamVjdChzdHIsIHBvcyk7XG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7XG4gICAgICAgICAgbmFtZTogXCJwcm9qZWN0aW9uXCIsXG4gICAgICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlcnJvclwiLFxuICAgIHBvc2l0aW9uOiBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnVuY0NhbGwoc3RyLCBzdGFydFBvcywgcG9zKSB7XG4gIGxldCBtYXJrcyA9IFtdO1xuICBtYXJrcy5wdXNoKHtcbiAgICBuYW1lOiBcImZ1bmNfY2FsbFwiLFxuICAgIHBvc2l0aW9uOiBzdGFydFBvc1xuICB9KTtcbiAgaWYgKHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcIm5hbWVzcGFjZVwiLFxuICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgfSk7XG4gICAgbWFya3MucHVzaCh7XG4gICAgICBuYW1lOiBcImlkZW50XCIsXG4gICAgICBwb3NpdGlvbjogc3RhcnRQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiBcImlkZW50X2VuZFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xuICAgIGxldCBuYW1lTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xuICAgIGlmICghbmFtZUxlbikgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICAgIG1hcmtzLnB1c2goe1xuICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgcG9zaXRpb246IHBvc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6IFwiaWRlbnRfZW5kXCIsXG4gICAgICBwb3NpdGlvbjogcG9zICsgbmFtZUxlblxuICAgIH0pO1xuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIG5hbWVMZW4pO1xuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIoXCIpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgICBwb3MrKztcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xuICB9IGVsc2Uge1xuICAgIG1hcmtzLnB1c2goe1xuICAgICAgbmFtZTogXCJpZGVudFwiLFxuICAgICAgcG9zaXRpb246IHN0YXJ0UG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogXCJpZGVudF9lbmRcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9KTtcbiAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgfVxuICBsZXQgbGFzdFBvcyA9IHBvcztcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gcmVzdWx0O1xuICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmVzdWx0Lm1hcmtzKTtcbiAgICAgIGxhc3RQb3MgPSByZXN1bHQucG9zaXRpb247XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIpXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoc3RyW3Bvc10gIT09IFwiKVwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICB9O1xuICB9XG4gIG1hcmtzLnB1c2goe1xuICAgIG5hbWU6IFwiZnVuY19hcmdzX2VuZFwiLFxuICAgIHBvc2l0aW9uOiBsYXN0UG9zXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgIG1hcmtzLFxuICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZU9iamVjdChzdHIsIHBvcykge1xuICBsZXQgbWFya3MgPSBbe1xuICAgIG5hbWU6IFwib2JqZWN0XCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9XTtcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIHdoaWxlIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcbiAgICBsZXQgcGFpclBvcyA9IHBvcztcbiAgICBpZiAoc3RyLnNsaWNlKHBvcywgcG9zICsgMykgPT09IFwiLi4uXCIpIHtcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIn1cIiAmJiBzdHJbcG9zXSAhPT0gXCIsXCIpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpIHJldHVybiBleHByO1xuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9zcGxhdFwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYWlyUG9zXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzKTtcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IFwib2JqZWN0X3NwbGF0X3RoaXNcIixcbiAgICAgICAgICBwb3NpdGlvbjogcGFpclBvc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xuICAgICAgaWYgKGV4cHIudHlwZSA9PT0gXCJlcnJvclwiKSByZXR1cm4gZXhwcjtcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XG4gICAgICBpZiAoZXhwci5tYXJrc1swXS5uYW1lID09PSBcInN0clwiICYmIHN0cltuZXh0UG9zXSA9PT0gXCI6XCIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgbmV4dFBvcyArIDEpLCAwKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIm9iamVjdF9wYWlyXCIsXG4gICAgICAgICAgcG9zaXRpb246IHBhaXJQb3NcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KGV4cHIubWFya3MsIHZhbHVlLm1hcmtzKTtcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7XG4gICAgICAgICAgbmFtZTogXCJvYmplY3RfZXhwclwiLFxuICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgfSwgZXhwci5tYXJrcyk7XG4gICAgICAgIHBvcyA9IGV4cHIucG9zaXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyk7XG4gICAgaWYgKHN0cltwb3NdICE9PSBcIixcIikgYnJlYWs7XG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XG4gIH1cbiAgaWYgKHN0cltwb3NdICE9PSBcIn1cIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgfVxuICBwb3MrKztcbiAgbWFya3MucHVzaCh7XG4gICAgbmFtZTogXCJvYmplY3RfZW5kXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICBtYXJrcyxcbiAgICBwb3NpdGlvbjogcG9zXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIsIHBvcykge1xuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcbiAgcG9zID0gcG9zICsgMTtcbiAgY29uc3QgbWFya3MgPSBbe1xuICAgIG5hbWU6IFwic3RyXCIsXG4gICAgcG9zaXRpb246IHBvc1xuICB9XTtcbiAgc3RyOiBmb3IgKDs7IHBvcysrKSB7XG4gICAgaWYgKHBvcyA+IHN0ci5sZW5ndGgpIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBwb3NpdGlvbjogcG9zXG4gICAgfTtcbiAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XG4gICAgICBjYXNlIHRva2VuOlxuICAgICAgICB7XG4gICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0cl9lbmRcIixcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBicmVhayBzdHI7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX3BhdXNlXCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHN0cltwb3MgKyAxXSA9PT0gXCJ1XCIpIHtcbiAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgM1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpO1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInVuaWNvZGVfaGV4XCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidW5pY29kZV9oZXhfZW5kXCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHBvcyArIDZcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHBvcyArPSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJzaW5nbGVfZXNjYXBlXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3MgKyAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IFwic3RyX3N0YXJ0XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgbWFya3MsXG4gICAgcG9zaXRpb246IHBvc1xuICB9O1xufVxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XG4gIHJldHVybiBwb3MgKyBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBXUyk7XG59XG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xuICByZXR1cm4gbSA/IG1bMF0ubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIHBhcnNlUmVnZXhTdHIoc3RyLCBwb3MsIHJlKSB7XG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBqb2luKGEsIGIpIHtcbiAgcmV0dXJuIGJhc2UgPT4gYihhKGJhc2UpKTtcbn1cbmZ1bmN0aW9uIG1hcChpbm5lcikge1xuICByZXR1cm4gYmFzZSA9PiAoe1xuICAgIHR5cGU6IFwiTWFwXCIsXG4gICAgYmFzZSxcbiAgICBleHByOiBpbm5lcih7XG4gICAgICB0eXBlOiBcIlRoaXNcIlxuICAgIH0pXG4gIH0pO1xufVxuZnVuY3Rpb24gZmxhdE1hcChpbm5lcikge1xuICByZXR1cm4gYmFzZSA9PiAoe1xuICAgIHR5cGU6IFwiRmxhdE1hcFwiLFxuICAgIGJhc2UsXG4gICAgZXhwcjogaW5uZXIoe1xuICAgICAgdHlwZTogXCJUaGlzXCJcbiAgICB9KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYXZlcnNlQXJyYXkoYnVpbGQsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgIGJ1aWxkXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihidWlsZCwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIG1hcChyaWdodC5idWlsZCkpXG4gICAgICB9O1xuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBmbGF0TWFwKHJpZ2h0LmJ1aWxkKSlcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XG4gIGlmICghcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgIGJ1aWxkOiBtYXBwZXJcbiAgICB9O1xuICB9XG4gIHN3aXRjaCAocmlnaHQudHlwZSkge1xuICAgIGNhc2UgXCJhLWFcIjpcbiAgICBjYXNlIFwiYi1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImItYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBjYXNlIFwiYS1iXCI6XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gdHJhdmVyc2VFbGVtZW50KG1hcHBlciwgcmlnaHQpIHtcbiAgaWYgKCFyaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgYnVpbGQ6IG1hcHBlclxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XG4gICAgY2FzZSBcImEtYVwiOlxuICAgIGNhc2UgXCJiLWFcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcHBlciwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICBjYXNlIFwiYi1iXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYlwiLFxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIi5jb25jYXQocmlnaHQudHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVByb2plY3Rpb24obWFwcGVyLCByaWdodCkge1xuICBpZiAoIXJpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYi1iXCIsXG4gICAgICBidWlsZDogbWFwcGVyXG4gICAgfTtcbiAgfVxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcbiAgICBjYXNlIFwiYS1hXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImEtYVwiLFxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXG4gICAgICB9O1xuICAgIGNhc2UgXCJhLWJcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXG4gICAgICAgIGJ1aWxkOiBqb2luKG1hcChtYXBwZXIpLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWFcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgY2FzZSBcImItYlwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJiLWJcIixcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIuY29uY2F0KHJpZ2h0LnR5cGUpKTtcbiAgfVxufVxudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlXG59KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNvbnN0IEVTQ0FQRV9TRVFVRU5DRSA9IHtcbiAgXCInXCI6IFwiJ1wiLFxuICAnXCInOiAnXCInLFxuICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gIFwiL1wiOiBcIi9cIixcbiAgYjogXCJcXGJcIixcbiAgZjogXCJcXGZcIixcbiAgbjogXCJcXG5cIixcbiAgcjogXCJcXHJcIixcbiAgdDogXCJcdFwiXG59O1xuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xuICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KHN0ciwgMTYpO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG59XG5jbGFzcyBHcm9xUXVlcnlFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FRdWVyeUVycm9yXCIpO1xuICB9XG59XG5jb25zdCBFWFBSX0JVSUxERVIgPSB7XG4gIGdyb3VwKHApIHtcbiAgICBjb25zdCBpbm5lciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXG4gICAgICBiYXNlOiBpbm5lclxuICAgIH07XG4gIH0sXG4gIGV2ZXJ5dGhpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRXZlcnl0aGluZ1wiXG4gICAgfTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJUaGlzXCJcbiAgICB9O1xuICB9LFxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiAxXG4gICAgfTtcbiAgfSxcbiAgZGJscGFyZW50KHApIHtcbiAgICBjb25zdCBuZXh0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXG4gICAgICBuOiBuZXh0Lm4gKyAxXG4gICAgfTtcbiAgfSxcbiAgdHJhdmVyc2UocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCB0cmF2ZXJzYWxMaXN0ID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHJhdmVyc2FsX2VuZFwiKSB7XG4gICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0cmF2ZXJzYWxMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0cmF2ZXJzYWwgPSB0cmF2ZXJzYWxMaXN0W2ldKHRyYXZlcnNhbCk7XG4gICAgfVxuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiRXZlcnl0aGluZ1wiIHx8IGJhc2UudHlwZSA9PT0gXCJBcnJheVwiIHx8IGJhc2UudHlwZSA9PT0gXCJQaXBlRnVuY0NhbGxcIikge1xuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2VBcnJheSh2YWwgPT4gdmFsLCB0cmF2ZXJzYWwpO1xuICAgIH1cbiAgICBpZiAodHJhdmVyc2FsID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IHVuZXhwZWN0ZWQgZW1wdHkgdHJhdmVyc2FsXCIpO1xuICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGlmIChuYW1lID09PSBcIm51bGxcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfSxcbiAgbmVnKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTmVnXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgcG9zKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9zXCIsXG4gICAgICBiYXNlXG4gICAgfTtcbiAgfSxcbiAgYWRkKHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIitcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCItXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBtdWwocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKlwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgZGl2KHApIHtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPcENhbGxcIixcbiAgICAgIG9wOiBcIi9cIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcDogXCIlXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBwb3cocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9wQ2FsbFwiLFxuICAgICAgb3A6IFwiKipcIixcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCBvcCA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT3BDYWxsXCIsXG4gICAgICBvcCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodFxuICAgIH07XG4gIH0sXG4gIGluX3JhbmdlKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xuICAgIHAuc2hpZnQoKTtcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJJblJhbmdlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9O1xuICB9LFxuICBzdHIocCkge1xuICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgbG9vcDogd2hpbGUgKHAuaGFzTWFyaygpKSB7XG4gICAgICBjb25zdCBtYXJrID0gcC5nZXRNYXJrKCk7XG4gICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xuICAgICAgICBjYXNlIFwic3RyX2VuZFwiOlxuICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIGNhc2UgXCJzdHJfcGF1c2VcIjpcbiAgICAgICAgICB2YWx1ZSArPSBwLnByb2Nlc3NTdHJpbmdFbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cl9zdGFydFwiOlxuICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpbmdsZV9lc2NhcGVcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gcC5zbGljZSgxKTtcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhbHVlICs9IEVTQ0FQRV9TRVFVRU5DRVtjaGFyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcInVuaWNvZGVfaGV4XCI6XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCBtYXJrOiBcIi5jb25jYXQobWFyay5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgZmxvYXQocCkge1xuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXG4gICAgfTtcbiAgfSxcbiAgc2NpKHApIHtcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxuICAgIH07XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcIm9iamVjdF9lbmRcIikge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKHAucHJvY2VzcyhPQkpFQ1RfQlVJTERFUikpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiT2JqZWN0XCIsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfSxcbiAgYXJyYXkocCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiYXJyYXlfZW5kXCIpIHtcbiAgICAgIGxldCBpc1NwbGF0ID0gZmFsc2U7XG4gICAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJhcnJheV9zcGxhdFwiKSB7XG4gICAgICAgIGlzU3BsYXQgPSB0cnVlO1xuICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiQXJyYXlFbGVtZW50XCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpc1NwbGF0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFycmF5XCIsXG4gICAgICBlbGVtZW50c1xuICAgIH07XG4gIH0sXG4gIHR1cGxlKHApIHtcbiAgICBjb25zdCBtZW1iZXJzID0gW107XG4gICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwidHVwbGVfZW5kXCIpIHtcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJUdXBsZVwiLFxuICAgICAgbWVtYmVyc1xuICAgIH07XG4gIH0sXG4gIGZ1bmNfY2FsbChwKSB7XG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwibmFtZXNwYWNlXCIpIHtcbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFwiU2VsZWN0XCIsXG4gICAgICAgIGFsdGVybmF0aXZlczogW11cbiAgICAgIH07XG4gICAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5mYWxsYmFjaykgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKVwiKTtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgICAgICByZXN1bHQuYWx0ZXJuYXRpdmVzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJTZWxlY3RBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgY29uZGl0aW9uLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKSB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGFyZ3VtZW50IHRvIHNlbGVjdCgpXCIpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgICAgICAgcmVzdWx0LmZhbGxiYWNrID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHAuc2hpZnQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcbiAgICAgIGlmIChhcmd1bWVudFNob3VsZEJlU2VsZWN0b3IobmFtZXNwYWNlLCBuYW1lLCBhcmdzLmxlbmd0aCkpIHtcbiAgICAgICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgICAgICBhcmdzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiU2VsZWN0b3JcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHAuc2hpZnQoKTtcbiAgICBpZiAobmFtZXNwYWNlID09PSBcImdsb2JhbFwiICYmIChuYW1lID09PSBcImJlZm9yZVwiIHx8IG5hbWUgPT09IFwiYWZ0ZXJcIikpIHtcbiAgICAgIGlmIChwLnBhcnNlT3B0aW9ucy5tb2RlID09PSBcImRlbHRhXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkNvbnRleHRcIixcbiAgICAgICAgICBrZXk6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdCkgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcbiAgICBjb25zdCBmdW5jcyA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlXTtcbiAgICBpZiAoIWZ1bmNzKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgbmFtZXNwYWNlOiBcIi5jb25jYXQobmFtZXNwYWNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBmdW5jc1tuYW1lXTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkgIT09IHZvaWQgMCkge1xuICAgICAgdmFsaWRhdGVBcml0eShuYW1lLCBmdW5jLmFyaXR5LCBhcmdzLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmIChmdW5jLm1vZGUgIT09IHZvaWQgMCAmJiBmdW5jLm1vZGUgIT09IHAucGFyc2VPcHRpb25zLm1vZGUpIHtcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcIlVuZGVmaW5lZCBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBuYW1lLFxuICAgICAgYXJnc1xuICAgIH07XG4gIH0sXG4gIHBpcGVjYWxsKHApIHtcbiAgICBjb25zdCBiYXNlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcC5zaGlmdCgpO1xuICAgIGxldCBuYW1lc3BhY2UgPSBcImdsb2JhbFwiO1xuICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBuYW1lc3BhY2UgPSBwLnByb2Nlc3NTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiVW5kZWZpbmVkIG5hbWVzcGFjZTogXCIuY29uY2F0KG5hbWVzcGFjZSkpO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IG9sZEFsbG93Qm9vc3QgPSBwLmFsbG93Qm9vc3Q7XG4gICAgaWYgKG5hbWUgPT09IFwic2NvcmVcIikge1xuICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWFya05hbWUgPSBwLmdldE1hcmsoKS5uYW1lO1xuICAgICAgaWYgKG1hcmtOYW1lID09PSBcImZ1bmNfYXJnc19lbmRcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcIm9yZGVyXCIpIHtcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XG4gICAgICAgICAgcC5zaGlmdCgpO1xuICAgICAgICAgIGFyZ3MucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcIkFzY1wiLFxuICAgICAgICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXJrTmFtZSA9PT0gXCJkZXNjXCIpIHtcbiAgICAgICAgICBwLnNoaWZ0KCk7XG4gICAgICAgICAgYXJncy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiRGVzY1wiLFxuICAgICAgICAgICAgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcbiAgICB9XG4gICAgcC5zaGlmdCgpO1xuICAgIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XG4gICAgY29uc3QgZnVuYyA9IHBpcGVGdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJVbmRlZmluZWQgcGlwZSBmdW5jdGlvbjogXCIuY29uY2F0KG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKGZ1bmMuYXJpdHkpIHtcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQaXBlRnVuY0NhbGxcIixcbiAgICAgIGZ1bmMsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZSxcbiAgICAgIGFyZ3NcbiAgICB9O1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkID0+XCIpO1xuICB9LFxuICBhbmQocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIkFuZFwiLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0XG4gICAgfTtcbiAgfSxcbiAgb3IocCkge1xuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9yXCIsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHRcbiAgICB9O1xuICB9LFxuICBub3QocCkge1xuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJOb3RcIixcbiAgICAgIGJhc2VcbiAgICB9O1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgYXNjXCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJ1bmV4cGVjdGVkIGRlc2NcIik7XG4gIH0sXG4gIHBhcmFtKHApIHtcbiAgICBjb25zdCBuYW1lID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgaWYgKHAucGFyc2VPcHRpb25zLnBhcmFtcyAmJiBwLnBhcnNlT3B0aW9ucy5wYXJhbXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiVmFsdWVcIixcbiAgICAgICAgdmFsdWU6IHAucGFyc2VPcHRpb25zLnBhcmFtc1tuYW1lXVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IE9CSkVDVF9CVUlMREVSID0ge1xuICBvYmplY3RfZXhwcihwKSB7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICAgIGNvbnN0IHZhbHVlMiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogZXh0cmFjdFByb3BlcnR5S2V5KHZhbHVlKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3BhaXIocCkge1xuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICBpZiAobmFtZS50eXBlICE9PSBcIlZhbHVlXCIpIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiLFxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfSxcbiAgb2JqZWN0X3NwbGF0KHApIHtcbiAgICBjb25zdCB2YWx1ZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0sXG4gIG9iamVjdF9zcGxhdF90aGlzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIk9iamVjdFNwbGF0XCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0eXBlOiBcIlRoaXNcIlxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBUUkFWRVJTRV9CVUlMREVSID0ge1xuICBzcXVhcmVfYnJhY2tldChwKSB7XG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShleHByKTtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlRWxlbWVudChiYXNlID0+ICh7XG4gICAgICAgIHR5cGU6IFwiQWNjZXNzRWxlbWVudFwiLFxuICAgICAgICBiYXNlLFxuICAgICAgICBpbmRleDogdmFsdWUuZGF0YVxuICAgICAgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gKHtcbiAgICAgICAgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIixcbiAgICAgICAgYmFzZSxcbiAgICAgICAgbmFtZTogdmFsdWUuZGF0YVxuICAgICAgfSksIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlQXJyYXkoYmFzZSA9PiAoe1xuICAgICAgdHlwZTogXCJGaWx0ZXJcIixcbiAgICAgIGJhc2UsXG4gICAgICBleHByXG4gICAgfSksIHJpZ2h0KTtcbiAgfSxcbiAgc2xpY2UocCkge1xuICAgIGNvbnN0IGlzSW5jbHVzaXZlID0gcC5nZXRNYXJrKCkubmFtZSA9PT0gXCJpbmNfcmFuZ2VcIjtcbiAgICBwLnNoaWZ0KCk7XG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KTtcbiAgICBjb25zdCByaWdodFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShyaWdodCk7XG4gICAgaWYgKCFsZWZ0VmFsdWUgfHwgIXJpZ2h0VmFsdWUgfHwgbGVmdFZhbHVlLnR5cGUgIT09IFwibnVtYmVyXCIgfHwgcmlnaHRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XG4gICAgfVxuICAgIHJldHVybiByaHMgPT4gdHJhdmVyc2VBcnJheShiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIlNsaWNlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbGVmdDogbGVmdFZhbHVlLmRhdGEsXG4gICAgICByaWdodDogcmlnaHRWYWx1ZS5kYXRhLFxuICAgICAgaXNJbmNsdXNpdmVcbiAgICB9KSwgcmhzKTtcbiAgfSxcbiAgcHJvamVjdGlvbihwKSB7XG4gICAgY29uc3Qgb2JqID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XG4gICAgcmV0dXJuIHJpZ2h0ID0+IHRyYXZlcnNlUHJvamVjdGlvbihiYXNlID0+ICh7XG4gICAgICB0eXBlOiBcIlByb2plY3Rpb25cIixcbiAgICAgIGJhc2UsXG4gICAgICBleHByOiBvYmpcbiAgICB9KSwgcmlnaHQpO1xuICB9LFxuICBhdHRyX2FjY2VzcyhwKSB7XG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZVBsYWluKGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsXG4gICAgICBiYXNlLFxuICAgICAgbmFtZVxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGRlcmVmKHApIHtcbiAgICBsZXQgYXR0ciA9IG51bGw7XG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XG4gICAgICBwLnNoaWZ0KCk7XG4gICAgICBhdHRyID0gcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXAgPSBiYXNlID0+IGF0dHIgPyB7XG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxuICAgICAgYmFzZSxcbiAgICAgIG5hbWU6IGF0dHJcbiAgICB9IDogYmFzZTtcbiAgICByZXR1cm4gcmlnaHQgPT4gdHJhdmVyc2VQbGFpbihiYXNlID0+IHdyYXAoe1xuICAgICAgdHlwZTogXCJEZXJlZlwiLFxuICAgICAgYmFzZVxuICAgIH0pLCByaWdodCk7XG4gIH0sXG4gIGFycmF5X3Bvc3RmaXgocCkge1xuICAgIHJldHVybiByaWdodCA9PiB0cmF2ZXJzZUFycmF5KGJhc2UgPT4gKHtcbiAgICAgIHR5cGU6IFwiQXJyYXlDb2VyY2VcIixcbiAgICAgIGJhc2VcbiAgICB9KSwgcmlnaHQpO1xuICB9XG59O1xuY29uc3QgU0VMRUNUT1JfQlVJTERFUiA9IHtcbiAgZ3JvdXAocCkge1xuICAgIHAucHJvY2VzcyhTRUxFQ1RPUl9CVUlMREVSKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgZXZlcnl0aGluZygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdGhpcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkYmxwYXJlbnQocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICB0cmF2ZXJzZShwKSB7XG4gICAgcC5wcm9jZXNzKFNFTEVDVE9SX0JVSUxERVIpO1xuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xuICAgICAgcC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpO1xuICAgIH1cbiAgICBwLnNoaWZ0KCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHRoaXNfYXR0cihwKSB7XG4gICAgcC5wcm9jZXNzU3RyaW5nKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIG5lZyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvcyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFkZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN1YihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG11bChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGRpdihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG1vZChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHBvdyhwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGNvbXAocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBpbl9yYW5nZShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHN0cihwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGludGVnZXIocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmbG9hdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIHNjaShwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIG9iamVjdChwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzZWxlY3RvciBzeW50YXhcIik7XG4gIH0sXG4gIGFycmF5KHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgdHVwbGUocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBmdW5jX2NhbGwocCwgbWFyaykge1xuICAgIGNvbnN0IGZ1bmMgPSBFWFBSX0JVSUxERVIuZnVuY19jYWxsKHAsIG1hcmspO1xuICAgIGlmIChmdW5jLm5hbWUgPT09IFwiYW55d2hlcmVcIiAmJiBmdW5jLmFyZ3MubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGlwZWNhbGwocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBwYWlyKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgYW5kKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgb3IocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBub3QocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBhc2MocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9LFxuICBkZXNjKHApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlbGVjdG9yIHN5bnRheFwiKTtcbiAgfSxcbiAgcGFyYW0ocCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VsZWN0b3Igc3ludGF4XCIpO1xuICB9XG59O1xuZnVuY3Rpb24gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NBdHRyaWJ1dGVcIiAmJiAhbm9kZS5iYXNlKSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkRlcmVmXCIgfHwgbm9kZS50eXBlID09PSBcIk1hcFwiIHx8IG5vZGUudHlwZSA9PT0gXCJQcm9qZWN0aW9uXCIgfHwgbm9kZS50eXBlID09PSBcIlNsaWNlXCIgfHwgbm9kZS50eXBlID09PSBcIkZpbHRlclwiIHx8IG5vZGUudHlwZSA9PT0gXCJBY2Nlc3NFbGVtZW50XCIgfHwgbm9kZS50eXBlID09PSBcIkFycmF5Q29lcmNlXCIpIHtcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XG4gIH1cbiAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwiQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6IFwiLmNvbmNhdChub2RlLnR5cGUpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50KSB7XG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoY291bnQgIT09IGFyaXR5KSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBcIi5jb25jYXQobmFtZSwgXCIoKS4gRXhwZWN0ZWQgXCIpLmNvbmNhdChhcml0eSwgXCIsIGdvdCBcIikuY29uY2F0KGNvdW50LCBcIi5cIikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcml0eSkge1xuICAgIGlmICghYXJpdHkoY291bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiBcIi5jb25jYXQobmFtZSwgXCIoKS5cIikpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yKG5hbWVzcGFjZSwgZnVuY3Rpb25OYW1lLCBhcmdDb3VudCkge1xuICBjb25zdCBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMgPSBbXCJjaGFuZ2VkQW55XCIsIFwiY2hhbmdlZE9ubHlcIl07XG4gIHJldHVybiBuYW1lc3BhY2UgPT0gXCJkaWZmXCIgJiYgYXJnQ291bnQgPT0gMiAmJiBmdW5jdGlvbnNSZXF1aXJpbmdTZWxlY3RvcnMuaW5jbHVkZXMoZnVuY3Rpb25OYW1lKTtcbn1cbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocG9zaXRpb24pIHtcbiAgICBzdXBlcihcIlN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uIFwiLmNvbmNhdChwb3NpdGlvbikpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwb3NpdGlvblwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibmFtZVwiLCBcIkdyb3FTeW50YXhFcnJvclwiKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XG4gIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgdGhyb3cgbmV3IEdyb3FTeW50YXhFcnJvcihyZXN1bHQucG9zaXRpb24pO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NvciA9IG5ldyBNYXJrUHJvY2Vzc29yKGlucHV0LCByZXN1bHQubWFya3MsIG9wdGlvbnMpO1xuICByZXR1cm4gcHJvY2Vzc29yLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcbn1cbmV4cG9ydCB7IERhdGVUaW1lLCBldmFsdWF0ZVF1ZXJ5IGFzIGV2YWx1YXRlLCBwYXJzZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9MS5tanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wJDUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZGVmTm9ybWFsUHJvcCQ1Iiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3B1YmxpY0ZpZWxkJDUiLCJlc2NhcGVSZWdFeHAiLCJzdHJpbmciLCJyZXBsYWNlIiwicGF0aFJlZ0V4cCIsInBhdHRlcm4iLCJyZSIsInBhcnQiLCJzcGxpdCIsInB1c2giLCJSZWdFeHAiLCJjb25jYXQiLCJqb2luIiwiUGF0aCIsImNvbnN0cnVjdG9yIiwicGF0dGVyblJlIiwibWF0Y2hlcyIsInN0ciIsInRlc3QiLCJ0b0pTT04iLCJfX2RlZlByb3AkNCIsIl9fZGVmTm9ybWFsUHJvcCQ0IiwiX19wdWJsaWNGaWVsZCQ0IiwiU3RyZWFtVmFsdWUiLCJnZW5lcmF0b3IiLCJ0aWNrZXIiLCJpc0RvbmUiLCJkYXRhIiwiaXNBcnJheSIsImdldCIsInJlc3VsdCIsIlN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJpIiwibGVuZ3RoIiwiX25leHRUaWNrIiwiY3VycmVudFJlc29sdmVyIiwic2V0dXBUaWNrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpY2siLCJmZXRjaCIsIlJGQzMzMzlfUkVHRVgiLCJwYXJzZVJGQzMzMzkiLCJEYXRlIiwiZm9ybWF0UkZDMzMzOSIsImQiLCJ5ZWFyIiwiYWRkTGVhZGluZ1plcm8iLCJnZXRVVENGdWxsWWVhciIsIm1vbnRoIiwiZ2V0VVRDTW9udGgiLCJkYXkiLCJnZXRVVENEYXRlIiwiaG91ciIsImdldFVUQ0hvdXJzIiwibWludXRlIiwiZ2V0VVRDTWludXRlcyIsInNlY29uZCIsImdldFVUQ1NlY29uZHMiLCJmcmFjdGlvbmFsU2Vjb25kIiwibWlsbGlzIiwiZ2V0TWlsbGlzZWNvbmRzIiwibnVtIiwidGFyZ2V0TGVuZ3RoIiwidG9TdHJpbmciLCJfX2RlZlByb3AkMyIsIl9fZGVmTm9ybWFsUHJvcCQzIiwiX19wdWJsaWNGaWVsZCQzIiwiU3RhdGljVmFsdWUiLCJ0eXBlIiwiQXJyYXkiLCJlbGVtZW50IiwiZnJvbUpTIiwiRXJyb3IiLCJOVUxMX1ZBTFVFIiwiVFJVRV9WQUxVRSIsIkZBTFNFX1ZBTFVFIiwiRGF0ZVRpbWUiLCJkYXRlIiwicGFyc2VUb1ZhbHVlIiwiZXF1YWxzIiwib3RoZXIiLCJnZXRUaW1lIiwiYWRkIiwic2VjcyIsImNvcHkiLCJzZXRUaW1lIiwiZGlmZmVyZW5jZSIsImNvbXBhcmVUbyIsImZyb21OdW1iZXIiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImZyb21TdHJpbmciLCJmcm9tRGF0ZVRpbWUiLCJkdCIsImZyb21QYXRoIiwicGF0aCIsImlzSXRlcmF0b3IiLCJuZXh0IiwidmFsIiwiZ2V0VHlwZSIsImlzRXF1YWwiLCJhIiwiYiIsIkNIQVJTIiwiQ0hBUlNfV0lUSF9XSUxEQ0FSRCIsIkVER0VfQ0hBUlMiLCJNQVhfVEVSTV9MRU5HVEgiLCJtYXRjaFRleHQiLCJ0b2tlbnMiLCJwYXR0ZXJucyIsImV2ZXJ5IiwibWF0Y2hUb2tlbml6ZSIsInRleHQiLCJtYXRjaCIsIm1hdGNoQW5hbHl6ZVBhdHRlcm4iLCJ0ZXJtc1JlIiwibWF0Y2hQYXR0ZXJuUmVnZXgiLCJtYXAiLCJzb21lIiwidG9rZW4iLCJ0ZXJtcyIsInRlcm0iLCJzbGljZSIsImdhdGhlclRleHQiLCJjYiIsInN1Y2Nlc3MiLCJUWVBFX09SREVSIiwiZGF0ZXRpbWUiLCJudW1iZXIiLCJib29sZWFuIiwicGFydGlhbENvbXBhcmUiLCJhVHlwZSIsImJUeXBlIiwidG90YWxDb21wYXJlIiwiYVR5cGVPcmRlciIsImJUeXBlT3JkZXIiLCJvcGVyYXRvcnMiLCJlcSIsImxlZnQiLCJyaWdodCIsIm5lcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJpbiIsImlub3AiLCJkaWRTdWNjZWVkIiwibWF0Y2hlZCIsInBsdXMiLCJtaW51cyIsIm51bWVyaWNPcGVyYXRvciIsIk1hdGgiLCJwb3ciLCJpbXBsIiwiX19kZWZQcm9wJDIiLCJfX2RlZk5vcm1hbFByb3AkMiIsIl9fcHVibGljRmllbGQkMiIsIlNjb3BlIiwicGFyYW1zIiwic291cmNlIiwiY29udGV4dCIsInBhcmVudCIsImNyZWF0ZU5lc3RlZCIsImlzSGlkZGVuIiwiY3JlYXRlSGlkZGVuIiwiZXZhbHVhdGUiLCJub2RlIiwic2NvcGUiLCJleGVjdXRlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiZnVuYyIsIkVYRUNVVE9SUyIsInByb21pc2VsZXNzQXBwbHkiLCJ0aGVuIiwiVGhpcyIsIl8iLCJTZWxlY3RvciIsIkV2ZXJ5dGhpbmciLCJQYXJhbWV0ZXIiLCJfcmVmIiwibmFtZSIsIkNvbnRleHQiLCJfcmVmMiIsIlBhcmVudCIsIl9yZWYzIiwibiIsImN1cnJlbnQiLCJPcENhbGwiLCJfcmVmNCIsIm9wIiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsIlNlbGVjdCIsIl9yZWY1IiwiYWx0ZXJuYXRpdmVzIiwiZmFsbGJhY2siLCJhbHQiLCJhbHRDb25kIiwiY29uZGl0aW9uIiwiSW5SYW5nZSIsIl9yZWY2IiwiYmFzZSIsImlzSW5jbHVzaXZlIiwibGVmdENtcCIsInJpZ2h0Q21wIiwiRmlsdGVyIiwiX3JlZjciLCJleHByIiwiYmFzZVZhbHVlIiwiZWxlbSIsIm5ld1Njb3BlIiwiZXhwclZhbHVlIiwiUHJvamVjdGlvbiIsIl9yZWY4IiwiRnVuY0NhbGwiLCJfcmVmOSIsImFyZ3MiLCJQaXBlRnVuY0NhbGwiLCJfcmVmMTAiLCJBY2Nlc3NBdHRyaWJ1dGUiLCJfcmVmMTEiLCJoYXNPd25Qcm9wZXJ0eSIsIkFjY2Vzc0VsZW1lbnQiLCJfcmVmMTIiLCJpbmRleCIsImZpbmFsSW5kZXgiLCJTbGljZSIsIl9yZWYxMyIsImFycmF5IiwibGVmdElkeCIsInJpZ2h0SWR4IiwiRGVyZWYiLCJfcmVmMTQiLCJpZCIsImRlcmVmZXJlbmNlIiwiZG9jIiwiX2lkIiwiVmFsdWUiLCJfcmVmMTUiLCJHcm91cCIsIl9yZWYxNiIsIl9yZWYxNyIsImF0dHJpYnV0ZXMiLCJhdHRyIiwiYXR0clR5cGUiLCJjb25kIiwiYXNzaWduIiwiX3JlZjE4IiwiZWxlbWVudHMiLCJpc1NwbGF0IiwidiIsIlR1cGxlIiwiT3IiLCJfcmVmMTkiLCJBbmQiLCJfcmVmMjAiLCJOb3QiLCJfcmVmMjEiLCJOZWciLCJfcmVmMjIiLCJQb3MiLCJfcmVmMjMiLCJBc2MiLCJEZXNjIiwiQXJyYXlDb2VyY2UiLCJfcmVmMjQiLCJNYXAiLCJfcmVmMjUiLCJGbGF0TWFwIiwiX3JlZjI2IiwiaW5uZXJWYWx1ZSIsImlubmVyIiwiZXZhbHVhdGVRdWVyeSIsInRyZWUiLCJvcHRpb25zIiwicm9vdCIsImRhdGFzZXQiLCJ0aW1lc3RhbXAiLCJpZGVudGl0eSIsInNhbml0eSIsImFmdGVyIiwiYmVmb3JlIiwiY2FuQ29uc3RhbnRFdmFsdWF0ZSIsIkRVTU1ZX1NDT1BFIiwidHJ5Q29uc3RhbnRFdmFsdWF0ZSIsImNvbnN0YW50RXZhbHVhdGUiLCJwb3J0YWJsZVRleHRDb250ZW50IiwiYmxvY2tUZXh0IiwidGV4dHMiLCJhcnJheVRleHQiLCJibG9jayIsIl90eXBlIiwiY2hpbGRyZW4iLCJjaGlsZCIsIkJNMjVrIiwiZXZhbHVhdGVTY29yZSIsImV2YWx1YXRlTWF0Y2hTY29yZSIsImlubmVyU2NvcmUiLCJib29zdCIsImxlZnRTY29yZSIsInJpZ2h0U2NvcmUiLCJyZXMiLCJzY29yZSIsImZyZXEiLCJyZWR1Y2UiLCJjIiwiaGFzUmVmZXJlbmNlIiwicGF0aFNldCIsImhhcyIsInZhbHVlcyIsImNvdW50VVRGOCIsImNvdW50MiIsImNvZGUiLCJjaGFyQ29kZUF0IiwiX2dsb2JhbCIsImFueXdoZXJlIiwiYXJpdHkiLCJjb2FsZXNjZSIsImFyZyIsImNvdW50IiwiZGF0ZVRpbWUiLCJkZWZpbmVkIiwicmVmZXJlbmNlcyIsIlNldCIsInBhdGgyIiwic2l6ZSIsInNjb3BlVmFsdWUiLCJyb3VuZCIsInByZWMiLCJwcmVjVmFsdWUiLCJpc0ludGVnZXIiLCJ0b0ZpeGVkIiwibm93IiwidG9JU09TdHJpbmciLCJzdHJpbmcyIiwibG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInVwcGVyIiwidG9VcHBlckNhc2UiLCJzZXAiLCJmcm9tIiwic3RhcnRzV2l0aCIsInByZWZpeCIsImFyciIsImJ1ZiIsIm5lZWRTZXAiLCJjb21wYWN0IiwidW5pcXVlIiwiYWRkZWQiLCJpdGVyIiwicHQiLCJwcm9qZWN0SWQiLCJwaXBlRnVuY3Rpb25zIiwib3JkZXIiLCJtYXBwZXJzIiwiZGlyZWN0aW9ucyIsIm1hcHBlciIsImRpcmVjdGlvbiIsImF1eCIsImlkeCIsInR1cGxlIiwic29ydCIsImFUdXBsZSIsImJUdXBsZSIsInVua25vd24iLCJzY29yZWQiLCJ2YWx1ZVNjb3JlIiwiX3Njb3JlIiwibmV3T2JqZWN0IiwiZGVsdGEiLCJvcGVyYXRpb24iLCJoYXNCZWZvcmUiLCJoYXNBZnRlciIsImNoYW5nZWRBbnkiLCJtb2RlIiwiY2hhbmdlZE9ubHkiLCJkaWZmIiwibWF0aCIsIm1pbiIsIm1heCIsInN1bSIsImF2ZyIsImRhdGVUaW1lMiIsIm5vdzIiLCJuYW1lc3BhY2VzIiwiZ2xvYmFsIiwiX19kZWZQcm9wJDEiLCJfX2RlZk5vcm1hbFByb3AkMSIsIl9fcHVibGljRmllbGQkMSIsIk1hcmtQcm9jZXNzb3IiLCJtYXJrcyIsInBhcnNlT3B0aW9ucyIsImhhc01hcmsiLCJwb3MiLCJnZXRNYXJrIiwic2hpZnQiLCJwcm9jZXNzIiwidmlzaXRvciIsIm1hcmsiLCJjYWxsIiwicHJvY2Vzc1N0cmluZyIsInByb2Nlc3NTdHJpbmdFbmQiLCJwcmV2IiwiY3VyciIsInBvc2l0aW9uIiwibGVuIiwiV1MiLCJOVU0iLCJJREVOVCIsIlBSRUNfUEFJUiIsIlBSRUNfT1IiLCJQUkVDX0FORCIsIlBSRUNfQ09NUCIsIlBSRUNfT1JERVIiLCJQUkVDX0FERCIsIlBSRUNfU1VCIiwiUFJFQ19NVUwiLCJQUkVDX0RJViIsIlBSRUNfTU9EIiwiUFJFQ19QT1ciLCJQUkVDX1BPUyIsIlBSRUNfTk9UIiwiUFJFQ19ORUciLCJwYXJzZSQxIiwic2tpcFdTIiwicGFyc2VFeHByIiwiZmFpbFBvc2l0aW9uIiwibGV2ZWwiLCJzdGFydFBvcyIsInJocyIsInBhcnNlT2JqZWN0IiwicGFyc2VTdHJpbmciLCJpZGVudExlbiIsInBhcnNlUmVnZXgiLCJudW1MZW4iLCJmcmFjTGVuIiwiZXhwTGVuIiwicGFyc2VGdW5jQ2FsbCIsImxoc0xldmVsIiwidHJhdiIsImxvb3AiLCJpbm5lclBvcyIsInBhcnNlVHJhdmVyc2FsIiwidW5zaGlmdCIsInRva2VuMiIsIm5leHRUb2tlbiIsInJoczIiLCJuZXh0UG9zIiwiaWRlbnRQb3MiLCJpZGVudCIsInBhcnNlUmVnZXhTdHIiLCJpc0dyb3VwIiwicmFuZ2VQb3MiLCJpZGVudFN0YXJ0IiwiaWRlbnRMZW4yIiwibmFtZUxlbiIsImxhc3RQb3MiLCJwYWlyUG9zIiwiaW5kZXhPZiIsIm0iLCJleGVjIiwiZmxhdE1hcCIsInRyYXZlcnNlQXJyYXkiLCJidWlsZCIsInRyYXZlcnNlUGxhaW4iLCJ0cmF2ZXJzZUVsZW1lbnQiLCJ0cmF2ZXJzZVByb2plY3Rpb24iLCJfX2RlZlByb3AiLCJfX2RlZk5vcm1hbFByb3AiLCJfX3B1YmxpY0ZpZWxkIiwiRVNDQVBFX1NFUVVFTkNFIiwiZiIsInIiLCJ0IiwiZXhwYW5kSGV4IiwiY2hhckNvZGUiLCJwYXJzZUludCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkdyb3FRdWVyeUVycm9yIiwiRVhQUl9CVUlMREVSIiwiZ3JvdXAiLCJwIiwiZXZlcnl0aGluZyIsInRoaXMiLCJkYmxwYXJlbnQiLCJ0cmF2ZXJzZSIsInRyYXZlcnNhbExpc3QiLCJUUkFWRVJTRV9CVUlMREVSIiwidHJhdmVyc2FsIiwidGhpc19hdHRyIiwibmVnIiwic3ViIiwibXVsIiwiZGl2IiwibW9kIiwiY29tcCIsImluX3JhbmdlIiwiY2hhciIsImludGVnZXIiLCJzdHJWYWx1ZSIsImZsb2F0Iiwic2NpIiwib2JqZWN0IiwiT0JKRUNUX0JVSUxERVIiLCJtZW1iZXJzIiwiZnVuY19jYWxsIiwibmFtZXNwYWNlIiwiYXJndW1lbnRTaG91bGRCZVNlbGVjdG9yIiwiU0VMRUNUT1JfQlVJTERFUiIsImFsbG93Qm9vc3QiLCJmdW5jcyIsInZhbGlkYXRlQXJpdHkiLCJwaXBlY2FsbCIsIm9sZEFsbG93Qm9vc3QiLCJtYXJrTmFtZSIsInBhaXIiLCJhbmQiLCJvciIsIm5vdCIsImFzYyIsImRlc2MiLCJwYXJhbSIsIm9iamVjdF9leHByIiwidmFsdWUyIiwiZXh0cmFjdFByb3BlcnR5S2V5Iiwib2JqZWN0X3BhaXIiLCJvYmplY3Rfc3BsYXQiLCJvYmplY3Rfc3BsYXRfdGhpcyIsInNxdWFyZV9icmFja2V0IiwicHJvamVjdGlvbiIsImF0dHJfYWNjZXNzIiwiZGVyZWYiLCJ3cmFwIiwiYXJyYXlfcG9zdGZpeCIsImZ1bmN0aW9uTmFtZSIsImFyZ0NvdW50IiwiZnVuY3Rpb25zUmVxdWlyaW5nU2VsZWN0b3JzIiwiaW5jbHVkZXMiLCJHcm9xU3ludGF4RXJyb3IiLCJwYXJzZSIsImlucHV0IiwicHJvY2Vzc29yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/groq-js/dist/1.mjs\n");

/***/ })

};
;