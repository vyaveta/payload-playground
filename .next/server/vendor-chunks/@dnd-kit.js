"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit";
exports.ids = ["vendor-chunks/@dnd-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HiddenText: () => (/* binding */ HiddenText),\n/* harmony export */   LiveRegion: () => (/* binding */ LiveRegion),\n/* harmony export */   useAnnouncement: () => (/* binding */ useAnnouncement)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst hiddenStyles = {\n    display: \"none\"\n};\nfunction HiddenText(_ref) {\n    let { id, value } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: hiddenStyles\n    }, value);\n}\nconst visuallyHidden = {\n    position: \"fixed\",\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    clipPath: \"inset(100%)\",\n    whiteSpace: \"nowrap\"\n};\nfunction LiveRegion(_ref) {\n    let { id, announcement } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", {\n        id: id,\n        style: visuallyHidden,\n        role: \"status\",\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": true\n    }, announcement);\n}\nfunction useAnnouncement() {\n    const [announcement, setAnnouncement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const announce = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((value)=>{\n        if (value != null) {\n            setAnnouncement(value);\n        }\n    }, []);\n    return {\n        announce,\n        announcement\n    };\n}\n //# sourceMappingURL=accessibility.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvYWNjZXNzaWJpbGl0eS9kaXN0L2FjY2Vzc2liaWxpdHkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXFEO0FBRXJELE1BQU1HLGVBQWU7SUFDbkJDLFNBQVM7QUFDWDtBQUNBLFNBQVNDLFdBQVdDLElBQUk7SUFDdEIsSUFBSSxFQUNGQyxFQUFFLEVBQ0ZDLEtBQUssRUFDTixHQUFHRjtJQUNKLHFCQUFPTiwwREFBbUIsQ0FBQyxPQUFPO1FBQ2hDTyxJQUFJQTtRQUNKRyxPQUFPUDtJQUNULEdBQUdLO0FBQ0w7QUFFQSxNQUFNRyxpQkFBaUI7SUFDckJDLFVBQVU7SUFDVkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFFBQVEsQ0FBQztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkMsWUFBWTtBQUNkO0FBQ0EsU0FBU0MsV0FBV2hCLElBQUk7SUFDdEIsSUFBSSxFQUNGQyxFQUFFLEVBQ0ZnQixZQUFZLEVBQ2IsR0FBR2pCO0lBQ0oscUJBQU9OLDBEQUFtQixDQUFDLE9BQU87UUFDaENPLElBQUlBO1FBQ0pHLE9BQU9DO1FBQ1BhLE1BQU07UUFDTixhQUFhO1FBQ2IsZUFBZTtJQUNqQixHQUFHRDtBQUNMO0FBRUEsU0FBU0U7SUFDUCxNQUFNLENBQUNGLGNBQWNHLGdCQUFnQixHQUFHekIsK0NBQVFBLENBQUM7SUFDakQsTUFBTTBCLFdBQVd6QixrREFBV0EsQ0FBQ00sQ0FBQUE7UUFDM0IsSUFBSUEsU0FBUyxNQUFNO1lBQ2pCa0IsZ0JBQWdCbEI7UUFDbEI7SUFDRixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0xtQjtRQUNBSjtJQUNGO0FBQ0Y7QUFFbUQsQ0FDbkQsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5bG9hZC1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L2FjY2Vzc2liaWxpdHkvZGlzdC9hY2Nlc3NpYmlsaXR5LmVzbS5qcz8zNzYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IGhpZGRlblN0eWxlcyA9IHtcbiAgZGlzcGxheTogJ25vbmUnXG59O1xuZnVuY3Rpb24gSGlkZGVuVGV4dChfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgdmFsdWVcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgc3R5bGU6IGhpZGRlblN0eWxlc1xuICB9LCB2YWx1ZSk7XG59XG5cbmNvbnN0IHZpc3VhbGx5SGlkZGVuID0ge1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgd2lkdGg6IDEsXG4gIGhlaWdodDogMSxcbiAgbWFyZ2luOiAtMSxcbiAgYm9yZGVyOiAwLFxuICBwYWRkaW5nOiAwLFxuICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgY2xpcFBhdGg6ICdpbnNldCgxMDAlKScsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnXG59O1xuZnVuY3Rpb24gTGl2ZVJlZ2lvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgYW5ub3VuY2VtZW50XG4gIH0gPSBfcmVmO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIHN0eWxlOiB2aXN1YWxseUhpZGRlbixcbiAgICByb2xlOiBcInN0YXR1c1wiLFxuICAgIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsXG4gICAgXCJhcmlhLWF0b21pY1wiOiB0cnVlXG4gIH0sIGFubm91bmNlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHVzZUFubm91bmNlbWVudCgpIHtcbiAgY29uc3QgW2Fubm91bmNlbWVudCwgc2V0QW5ub3VuY2VtZW50XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgYW5ub3VuY2UgPSB1c2VDYWxsYmFjayh2YWx1ZSA9PiB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldEFubm91bmNlbWVudCh2YWx1ZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgYW5ub3VuY2UsXG4gICAgYW5ub3VuY2VtZW50XG4gIH07XG59XG5cbmV4cG9ydCB7IEhpZGRlblRleHQsIExpdmVSZWdpb24sIHVzZUFubm91bmNlbWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzaWJpbGl0eS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiaGlkZGVuU3R5bGVzIiwiZGlzcGxheSIsIkhpZGRlblRleHQiLCJfcmVmIiwiaWQiLCJ2YWx1ZSIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInZpc3VhbGx5SGlkZGVuIiwicG9zaXRpb24iLCJ3aWR0aCIsImhlaWdodCIsIm1hcmdpbiIsImJvcmRlciIsInBhZGRpbmciLCJvdmVyZmxvdyIsImNsaXAiLCJjbGlwUGF0aCIsIndoaXRlU3BhY2UiLCJMaXZlUmVnaW9uIiwiYW5ub3VuY2VtZW50Iiwicm9sZSIsInVzZUFubm91bmNlbWVudCIsInNldEFubm91bmNlbWVudCIsImFubm91bmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/@dnd-kit/core/dist/core.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoScrollActivator: () => (/* binding */ AutoScrollActivator),\n/* harmony export */   DndContext: () => (/* binding */ DndContext),\n/* harmony export */   DragOverlay: () => (/* binding */ DragOverlay),\n/* harmony export */   KeyboardCode: () => (/* binding */ KeyboardCode),\n/* harmony export */   KeyboardSensor: () => (/* binding */ KeyboardSensor),\n/* harmony export */   MeasuringFrequency: () => (/* binding */ MeasuringFrequency),\n/* harmony export */   MeasuringStrategy: () => (/* binding */ MeasuringStrategy),\n/* harmony export */   MouseSensor: () => (/* binding */ MouseSensor),\n/* harmony export */   PointerSensor: () => (/* binding */ PointerSensor),\n/* harmony export */   TouchSensor: () => (/* binding */ TouchSensor),\n/* harmony export */   TraversalOrder: () => (/* binding */ TraversalOrder),\n/* harmony export */   applyModifiers: () => (/* binding */ applyModifiers),\n/* harmony export */   closestCenter: () => (/* binding */ closestCenter),\n/* harmony export */   closestCorners: () => (/* binding */ closestCorners),\n/* harmony export */   defaultAnnouncements: () => (/* binding */ defaultAnnouncements),\n/* harmony export */   defaultCoordinates: () => (/* binding */ defaultCoordinates),\n/* harmony export */   defaultDropAnimation: () => (/* binding */ defaultDropAnimationConfiguration),\n/* harmony export */   defaultDropAnimationSideEffects: () => (/* binding */ defaultDropAnimationSideEffects),\n/* harmony export */   defaultScreenReaderInstructions: () => (/* binding */ defaultScreenReaderInstructions),\n/* harmony export */   getClientRect: () => (/* binding */ getClientRect),\n/* harmony export */   getFirstCollision: () => (/* binding */ getFirstCollision),\n/* harmony export */   getScrollableAncestors: () => (/* binding */ getScrollableAncestors),\n/* harmony export */   pointerWithin: () => (/* binding */ pointerWithin),\n/* harmony export */   rectIntersection: () => (/* binding */ rectIntersection),\n/* harmony export */   useDndContext: () => (/* binding */ useDndContext),\n/* harmony export */   useDndMonitor: () => (/* binding */ useDndMonitor),\n/* harmony export */   useDraggable: () => (/* binding */ useDraggable),\n/* harmony export */   useDroppable: () => (/* binding */ useDroppable),\n/* harmony export */   useSensor: () => (/* binding */ useSensor),\n/* harmony export */   useSensors: () => (/* binding */ useSensors)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n/* harmony import */ var _dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @dnd-kit/accessibility */ \"(ssr)/./node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js\");\n\n\n\n\nconst DndMonitorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction useDndMonitor(listener) {\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DndMonitorContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!registerListener) {\n            throw new Error(\"useDndMonitor must be used within a children of <DndContext>\");\n        }\n        const unsubscribe = registerListener(listener);\n        return unsubscribe;\n    }, [\n        listener,\n        registerListener\n    ]);\n}\nfunction useDndMonitorProvider() {\n    const [listeners] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new Set());\n    const registerListener = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener)=>{\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    }, [\n        listeners\n    ]);\n    const dispatch = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((_ref)=>{\n        let { type, event } = _ref;\n        listeners.forEach((listener)=>{\n            var _listener$type;\n            return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);\n        });\n    }, [\n        listeners\n    ]);\n    return [\n        dispatch,\n        registerListener\n    ];\n}\nconst defaultScreenReaderInstructions = {\n    draggable: \"\\n    To pick up a draggable item, press the space bar.\\n    While dragging, use the arrow keys to move the item.\\n    Press space again to drop the item in its new position, or press escape to cancel.\\n  \"\n};\nconst defaultAnnouncements = {\n    onDragStart (_ref) {\n        let { active } = _ref;\n        return \"Picked up draggable item \" + active.id + \".\";\n    },\n    onDragOver (_ref2) {\n        let { active, over } = _ref2;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was moved over droppable area \" + over.id + \".\";\n        }\n        return \"Draggable item \" + active.id + \" is no longer over a droppable area.\";\n    },\n    onDragEnd (_ref3) {\n        let { active, over } = _ref3;\n        if (over) {\n            return \"Draggable item \" + active.id + \" was dropped over droppable area \" + over.id;\n        }\n        return \"Draggable item \" + active.id + \" was dropped.\";\n    },\n    onDragCancel (_ref4) {\n        let { active } = _ref4;\n        return \"Dragging was cancelled. Draggable item \" + active.id + \" was dropped.\";\n    }\n};\nfunction Accessibility(_ref) {\n    let { announcements = defaultAnnouncements, container, hiddenTextDescribedById, screenReaderInstructions = defaultScreenReaderInstructions } = _ref;\n    const { announce, announcement } = (0,_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.useAnnouncement)();\n    const liveRegionId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndLiveRegion\");\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        setMounted(true);\n    }, []);\n    useDndMonitor((0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            onDragStart (_ref2) {\n                let { active } = _ref2;\n                announce(announcements.onDragStart({\n                    active\n                }));\n            },\n            onDragMove (_ref3) {\n                let { active, over } = _ref3;\n                if (announcements.onDragMove) {\n                    announce(announcements.onDragMove({\n                        active,\n                        over\n                    }));\n                }\n            },\n            onDragOver (_ref4) {\n                let { active, over } = _ref4;\n                announce(announcements.onDragOver({\n                    active,\n                    over\n                }));\n            },\n            onDragEnd (_ref5) {\n                let { active, over } = _ref5;\n                announce(announcements.onDragEnd({\n                    active,\n                    over\n                }));\n            },\n            onDragCancel (_ref6) {\n                let { active, over } = _ref6;\n                announce(announcements.onDragCancel({\n                    active,\n                    over\n                }));\n            }\n        }), [\n        announce,\n        announcements\n    ]));\n    if (!mounted) {\n        return null;\n    }\n    const markup = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.HiddenText, {\n        id: hiddenTextDescribedById,\n        value: screenReaderInstructions.draggable\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_dnd_kit_accessibility__WEBPACK_IMPORTED_MODULE_3__.LiveRegion, {\n        id: liveRegionId,\n        announcement: announcement\n    }));\n    return container ? /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(markup, container) : markup;\n}\nvar Action;\n(function(Action) {\n    Action[\"DragStart\"] = \"dragStart\";\n    Action[\"DragMove\"] = \"dragMove\";\n    Action[\"DragEnd\"] = \"dragEnd\";\n    Action[\"DragCancel\"] = \"dragCancel\";\n    Action[\"DragOver\"] = \"dragOver\";\n    Action[\"RegisterDroppable\"] = \"registerDroppable\";\n    Action[\"SetDroppableDisabled\"] = \"setDroppableDisabled\";\n    Action[\"UnregisterDroppable\"] = \"unregisterDroppable\";\n})(Action || (Action = {}));\nfunction noop() {}\nfunction useSensor(sensor, options) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sensor,\n            options: options != null ? options : {}\n        }), [\n        sensor,\n        options\n    ]);\n}\nfunction useSensors() {\n    for(var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++){\n        sensors[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>[\n            ...sensors\n        ].filter((sensor)=>sensor != null), [\n        ...sensors\n    ]);\n}\nconst defaultCoordinates = /*#__PURE__*/ Object.freeze({\n    x: 0,\n    y: 0\n});\n/**\r\n * Returns the distance between two points\r\n */ function distanceBetween(p1, p2) {\n    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n}\nfunction getRelativeTransformOrigin(event, rect) {\n    const eventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event);\n    if (!eventCoordinates) {\n        return \"0 0\";\n    }\n    const transformOrigin = {\n        x: (eventCoordinates.x - rect.left) / rect.width * 100,\n        y: (eventCoordinates.y - rect.top) / rect.height * 100\n    };\n    return transformOrigin.x + \"% \" + transformOrigin.y + \"%\";\n}\n/**\r\n * Sort collisions from smallest to greatest value\r\n */ function sortCollisionsAsc(_ref, _ref2) {\n    let { data: { value: a } } = _ref;\n    let { data: { value: b } } = _ref2;\n    return a - b;\n}\n/**\r\n * Sort collisions from greatest to smallest value\r\n */ function sortCollisionsDesc(_ref3, _ref4) {\n    let { data: { value: a } } = _ref3;\n    let { data: { value: b } } = _ref4;\n    return b - a;\n}\n/**\r\n * Returns the coordinates of the corners of a given rectangle:\r\n * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]\r\n */ function cornersOfRectangle(_ref5) {\n    let { left, top, height, width } = _ref5;\n    return [\n        {\n            x: left,\n            y: top\n        },\n        {\n            x: left + width,\n            y: top\n        },\n        {\n            x: left,\n            y: top + height\n        },\n        {\n            x: left + width,\n            y: top + height\n        }\n    ];\n}\nfunction getFirstCollision(collisions, property) {\n    if (!collisions || collisions.length === 0) {\n        return null;\n    }\n    const [firstCollision] = collisions;\n    return property ? firstCollision[property] : firstCollision;\n}\n/**\r\n * Returns the coordinates of the center of a given ClientRect\r\n */ function centerOfRectangle(rect, left, top) {\n    if (left === void 0) {\n        left = rect.left;\n    }\n    if (top === void 0) {\n        top = rect.top;\n    }\n    return {\n        x: left + rect.width * 0.5,\n        y: top + rect.height * 0.5\n    };\n}\n/**\r\n * Returns the closest rectangles from an array of rectangles to the center of a given\r\n * rectangle.\r\n */ const closestCenter = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: distBetween\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the closest rectangles from an array of rectangles to the corners of\r\n * another rectangle.\r\n */ const closestCorners = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const corners = cornersOfRectangle(collisionRect);\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const rectCorners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner, index)=>{\n                return accumulator + distanceBetween(rectCorners[index], corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\n/**\r\n * Returns the intersecting rectangle area between two rectangles\r\n */ function getIntersectionRatio(entry, target) {\n    const top = Math.max(target.top, entry.top);\n    const left = Math.max(target.left, entry.left);\n    const right = Math.min(target.left + target.width, entry.left + entry.width);\n    const bottom = Math.min(target.top + target.height, entry.top + entry.height);\n    const width = right - left;\n    const height = bottom - top;\n    if (left < right && top < bottom) {\n        const targetArea = target.width * target.height;\n        const entryArea = entry.width * entry.height;\n        const intersectionArea = width * height;\n        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);\n        return Number(intersectionRatio.toFixed(4));\n    } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)\n    return 0;\n}\n/**\r\n * Returns the rectangles that has the greatest intersection area with a given\r\n * rectangle in an array of rectangles.\r\n */ const rectIntersection = (_ref)=>{\n    let { collisionRect, droppableRects, droppableContainers } = _ref;\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect) {\n            const intersectionRatio = getIntersectionRatio(rect, collisionRect);\n            if (intersectionRatio > 0) {\n                collisions.push({\n                    id,\n                    data: {\n                        droppableContainer,\n                        value: intersectionRatio\n                    }\n                });\n            }\n        }\n    }\n    return collisions.sort(sortCollisionsDesc);\n};\n/**\r\n * Check if a given point is contained within a bounding rectangle\r\n */ function isPointWithinRect(point, rect) {\n    const { top, left, bottom, right } = rect;\n    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;\n}\n/**\r\n * Returns the rectangles that the pointer is hovering over\r\n */ const pointerWithin = (_ref)=>{\n    let { droppableContainers, droppableRects, pointerCoordinates } = _ref;\n    if (!pointerCoordinates) {\n        return [];\n    }\n    const collisions = [];\n    for (const droppableContainer of droppableContainers){\n        const { id } = droppableContainer;\n        const rect = droppableRects.get(id);\n        if (rect && isPointWithinRect(pointerCoordinates, rect)) {\n            /* There may be more than a single rectangle intersecting\r\n       * with the pointer coordinates. In order to sort the\r\n       * colliding rectangles, we measure the distance between\r\n       * the pointer and the corners of the intersecting rectangle\r\n       */ const corners = cornersOfRectangle(rect);\n            const distances = corners.reduce((accumulator, corner)=>{\n                return accumulator + distanceBetween(pointerCoordinates, corner);\n            }, 0);\n            const effectiveDistance = Number((distances / 4).toFixed(4));\n            collisions.push({\n                id,\n                data: {\n                    droppableContainer,\n                    value: effectiveDistance\n                }\n            });\n        }\n    }\n    return collisions.sort(sortCollisionsAsc);\n};\nfunction adjustScale(transform, rect1, rect2) {\n    return {\n        ...transform,\n        scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,\n        scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1\n    };\n}\nfunction getRectDelta(rect1, rect2) {\n    return rect1 && rect2 ? {\n        x: rect1.left - rect2.left,\n        y: rect1.top - rect2.top\n    } : defaultCoordinates;\n}\nfunction createRectAdjustmentFn(modifier) {\n    return function adjustClientRect(rect) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((acc, adjustment)=>({\n                ...acc,\n                top: acc.top + modifier * adjustment.y,\n                bottom: acc.bottom + modifier * adjustment.y,\n                left: acc.left + modifier * adjustment.x,\n                right: acc.right + modifier * adjustment.x\n            }), {\n            ...rect\n        });\n    };\n}\nconst getAdjustedRect = /*#__PURE__*/ createRectAdjustmentFn(1);\nfunction parseTransform(transform) {\n    if (transform.startsWith(\"matrix3d(\")) {\n        const transformArray = transform.slice(9, -1).split(/, /);\n        return {\n            x: +transformArray[12],\n            y: +transformArray[13],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[5]\n        };\n    } else if (transform.startsWith(\"matrix(\")) {\n        const transformArray = transform.slice(7, -1).split(/, /);\n        return {\n            x: +transformArray[4],\n            y: +transformArray[5],\n            scaleX: +transformArray[0],\n            scaleY: +transformArray[3]\n        };\n    }\n    return null;\n}\nfunction inverseTransform(rect, transform, transformOrigin) {\n    const parsedTransform = parseTransform(transform);\n    if (!parsedTransform) {\n        return rect;\n    }\n    const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;\n    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);\n    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(\" \") + 1));\n    const w = scaleX ? rect.width / scaleX : rect.width;\n    const h = scaleY ? rect.height / scaleY : rect.height;\n    return {\n        width: w,\n        height: h,\n        top: y,\n        right: x + w,\n        bottom: y + h,\n        left: x\n    };\n}\nconst defaultOptions = {\n    ignoreTransform: false\n};\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n */ function getClientRect(element, options) {\n    if (options === void 0) {\n        options = defaultOptions;\n    }\n    let rect = element.getBoundingClientRect();\n    if (options.ignoreTransform) {\n        const { transform, transformOrigin } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n        if (transform) {\n            rect = inverseTransform(rect, transform, transformOrigin);\n        }\n    }\n    const { top, left, width, height, bottom, right } = rect;\n    return {\n        top,\n        left,\n        width,\n        height,\n        bottom,\n        right\n    };\n}\n/**\r\n * Returns the bounding client rect of an element relative to the viewport.\r\n *\r\n * @remarks\r\n * The ClientRect returned by this method does not take into account transforms\r\n * applied to the element it measures.\r\n *\r\n */ function getTransformAgnosticClientRect(element) {\n    return getClientRect(element, {\n        ignoreTransform: true\n    });\n}\nfunction getWindowClientRect(element) {\n    const width = element.innerWidth;\n    const height = element.innerHeight;\n    return {\n        top: 0,\n        left: 0,\n        right: width,\n        bottom: height,\n        width,\n        height\n    };\n}\nfunction isFixed(node, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n    }\n    return computedStyle.position === \"fixed\";\n}\nfunction isScrollable(element, computedStyle) {\n    if (computedStyle === void 0) {\n        computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(element);\n    }\n    const overflowRegex = /(auto|scroll|overlay)/;\n    const properties = [\n        \"overflow\",\n        \"overflowX\",\n        \"overflowY\"\n    ];\n    return properties.some((property)=>{\n        const value = computedStyle[property];\n        return typeof value === \"string\" ? overflowRegex.test(value) : false;\n    });\n}\nfunction getScrollableAncestors(element, limit) {\n    const scrollParents = [];\n    function findScrollableAncestors(node) {\n        if (limit != null && scrollParents.length >= limit) {\n            return scrollParents;\n        }\n        if (!node) {\n            return scrollParents;\n        }\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {\n            scrollParents.push(node.scrollingElement);\n            return scrollParents;\n        }\n        if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(node) || (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isSVGElement)(node)) {\n            return scrollParents;\n        }\n        if (scrollParents.includes(node)) {\n            return scrollParents;\n        }\n        const computedStyle = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(element).getComputedStyle(node);\n        if (node !== element) {\n            if (isScrollable(node, computedStyle)) {\n                scrollParents.push(node);\n            }\n        }\n        if (isFixed(node, computedStyle)) {\n            return scrollParents;\n        }\n        return findScrollableAncestors(node.parentNode);\n    }\n    if (!element) {\n        return scrollParents;\n    }\n    return findScrollableAncestors(element);\n}\nfunction getFirstScrollableAncestor(node) {\n    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);\n    return firstScrollableAncestor != null ? firstScrollableAncestor : null;\n}\nfunction getScrollableElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element;\n    }\n    if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isNode)(element)) {\n        return null;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isDocument)(element) || element === (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(element).scrollingElement) {\n        return window;\n    }\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(element)) {\n        return element;\n    }\n    return null;\n}\nfunction getScrollXCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollX;\n    }\n    return element.scrollLeft;\n}\nfunction getScrollYCoordinate(element) {\n    if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isWindow)(element)) {\n        return element.scrollY;\n    }\n    return element.scrollTop;\n}\nfunction getScrollCoordinates(element) {\n    return {\n        x: getScrollXCoordinate(element),\n        y: getScrollYCoordinate(element)\n    };\n}\nvar Direction;\n(function(Direction) {\n    Direction[Direction[\"Forward\"] = 1] = \"Forward\";\n    Direction[Direction[\"Backward\"] = -1] = \"Backward\";\n})(Direction || (Direction = {}));\nfunction isDocumentScrollingElement(element) {\n    if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM || !element) {\n        return false;\n    }\n    return element === document.scrollingElement;\n}\nfunction getScrollPosition(scrollingContainer) {\n    const minScroll = {\n        x: 0,\n        y: 0\n    };\n    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {\n        height: window.innerHeight,\n        width: window.innerWidth\n    } : {\n        height: scrollingContainer.clientHeight,\n        width: scrollingContainer.clientWidth\n    };\n    const maxScroll = {\n        x: scrollingContainer.scrollWidth - dimensions.width,\n        y: scrollingContainer.scrollHeight - dimensions.height\n    };\n    const isTop = scrollingContainer.scrollTop <= minScroll.y;\n    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;\n    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;\n    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;\n    return {\n        isTop,\n        isLeft,\n        isBottom,\n        isRight,\n        maxScroll,\n        minScroll\n    };\n}\nconst defaultThreshold = {\n    x: 0.2,\n    y: 0.2\n};\nfunction getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {\n    let { top, left, right, bottom } = _ref;\n    if (acceleration === void 0) {\n        acceleration = 10;\n    }\n    if (thresholdPercentage === void 0) {\n        thresholdPercentage = defaultThreshold;\n    }\n    const { isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollContainer);\n    const direction = {\n        x: 0,\n        y: 0\n    };\n    const speed = {\n        x: 0,\n        y: 0\n    };\n    const threshold = {\n        height: scrollContainerRect.height * thresholdPercentage.y,\n        width: scrollContainerRect.width * thresholdPercentage.x\n    };\n    if (!isTop && top <= scrollContainerRect.top + threshold.height) {\n        // Scroll Up\n        direction.y = Direction.Backward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);\n    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {\n        // Scroll Down\n        direction.y = Direction.Forward;\n        speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);\n    }\n    if (!isRight && right >= scrollContainerRect.right - threshold.width) {\n        // Scroll Right\n        direction.x = Direction.Forward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);\n    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {\n        // Scroll Left\n        direction.x = Direction.Backward;\n        speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);\n    }\n    return {\n        direction,\n        speed\n    };\n}\nfunction getScrollElementRect(element) {\n    if (element === document.scrollingElement) {\n        const { innerWidth, innerHeight } = window;\n        return {\n            top: 0,\n            left: 0,\n            right: innerWidth,\n            bottom: innerHeight,\n            width: innerWidth,\n            height: innerHeight\n        };\n    }\n    const { top, left, right, bottom } = element.getBoundingClientRect();\n    return {\n        top,\n        left,\n        right,\n        bottom,\n        width: element.clientWidth,\n        height: element.clientHeight\n    };\n}\nfunction getScrollOffsets(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, getScrollCoordinates(node));\n    }, defaultCoordinates);\n}\nfunction getScrollXOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollXCoordinate(node);\n    }, 0);\n}\nfunction getScrollYOffset(scrollableAncestors) {\n    return scrollableAncestors.reduce((acc, node)=>{\n        return acc + getScrollYCoordinate(node);\n    }, 0);\n}\nfunction scrollIntoViewIfNeeded(element, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    if (!element) {\n        return;\n    }\n    const { top, left, bottom, right } = measure(element);\n    const firstScrollableAncestor = getFirstScrollableAncestor(element);\n    if (!firstScrollableAncestor) {\n        return;\n    }\n    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {\n        element.scrollIntoView({\n            block: \"center\",\n            inline: \"center\"\n        });\n    }\n}\nconst properties = [\n    [\n        \"x\",\n        [\n            \"left\",\n            \"right\"\n        ],\n        getScrollXOffset\n    ],\n    [\n        \"y\",\n        [\n            \"top\",\n            \"bottom\"\n        ],\n        getScrollYOffset\n    ]\n];\nclass Rect {\n    constructor(rect, element){\n        this.rect = void 0;\n        this.width = void 0;\n        this.height = void 0;\n        this.top = void 0;\n        this.bottom = void 0;\n        this.right = void 0;\n        this.left = void 0;\n        const scrollableAncestors = getScrollableAncestors(element);\n        const scrollOffsets = getScrollOffsets(scrollableAncestors);\n        this.rect = {\n            ...rect\n        };\n        this.width = rect.width;\n        this.height = rect.height;\n        for (const [axis, keys, getScrollOffset] of properties){\n            for (const key of keys){\n                Object.defineProperty(this, key, {\n                    get: ()=>{\n                        const currentOffsets = getScrollOffset(scrollableAncestors);\n                        const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;\n                        return this.rect[key] + scrollOffsetsDeltla;\n                    },\n                    enumerable: true\n                });\n            }\n        }\n        Object.defineProperty(this, \"rect\", {\n            enumerable: false\n        });\n    }\n}\nclass Listeners {\n    constructor(target){\n        this.target = void 0;\n        this.listeners = [];\n        this.removeAll = ()=>{\n            this.listeners.forEach((listener)=>{\n                var _this$target;\n                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);\n            });\n        };\n        this.target = target;\n    }\n    add(eventName, handler, options) {\n        var _this$target2;\n        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);\n        this.listeners.push([\n            eventName,\n            handler,\n            options\n        ]);\n    }\n}\nfunction getEventListenerTarget(target) {\n    // If the `event.target` element is removed from the document events will still be targeted\n    // at it, and hence won't always bubble up to the window or document anymore.\n    // If there is any risk of an element being removed while it is being dragged,\n    // the best practice is to attach the event listeners directly to the target.\n    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\n    const { EventTarget } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target);\n    return target instanceof EventTarget ? target : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n}\nfunction hasExceededDistance(delta, measurement) {\n    const dx = Math.abs(delta.x);\n    const dy = Math.abs(delta.y);\n    if (typeof measurement === \"number\") {\n        return Math.sqrt(dx ** 2 + dy ** 2) > measurement;\n    }\n    if (\"x\" in measurement && \"y\" in measurement) {\n        return dx > measurement.x && dy > measurement.y;\n    }\n    if (\"x\" in measurement) {\n        return dx > measurement.x;\n    }\n    if (\"y\" in measurement) {\n        return dy > measurement.y;\n    }\n    return false;\n}\nvar EventName;\n(function(EventName) {\n    EventName[\"Click\"] = \"click\";\n    EventName[\"DragStart\"] = \"dragstart\";\n    EventName[\"Keydown\"] = \"keydown\";\n    EventName[\"ContextMenu\"] = \"contextmenu\";\n    EventName[\"Resize\"] = \"resize\";\n    EventName[\"SelectionChange\"] = \"selectionchange\";\n    EventName[\"VisibilityChange\"] = \"visibilitychange\";\n})(EventName || (EventName = {}));\nfunction preventDefault(event) {\n    event.preventDefault();\n}\nfunction stopPropagation(event) {\n    event.stopPropagation();\n}\nvar KeyboardCode;\n(function(KeyboardCode) {\n    KeyboardCode[\"Space\"] = \"Space\";\n    KeyboardCode[\"Down\"] = \"ArrowDown\";\n    KeyboardCode[\"Right\"] = \"ArrowRight\";\n    KeyboardCode[\"Left\"] = \"ArrowLeft\";\n    KeyboardCode[\"Up\"] = \"ArrowUp\";\n    KeyboardCode[\"Esc\"] = \"Escape\";\n    KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\nconst defaultKeyboardCodes = {\n    start: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ],\n    cancel: [\n        KeyboardCode.Esc\n    ],\n    end: [\n        KeyboardCode.Space,\n        KeyboardCode.Enter\n    ]\n};\nconst defaultKeyboardCoordinateGetter = (event, _ref)=>{\n    let { currentCoordinates } = _ref;\n    switch(event.code){\n        case KeyboardCode.Right:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x + 25\n            };\n        case KeyboardCode.Left:\n            return {\n                ...currentCoordinates,\n                x: currentCoordinates.x - 25\n            };\n        case KeyboardCode.Down:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y + 25\n            };\n        case KeyboardCode.Up:\n            return {\n                ...currentCoordinates,\n                y: currentCoordinates.y - 25\n            };\n    }\n    return undefined;\n};\nclass KeyboardSensor {\n    constructor(props){\n        this.props = void 0;\n        this.autoScrollEnabled = false;\n        this.referenceCoordinates = void 0;\n        this.listeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        const { event: { target } } = props;\n        this.props = props;\n        this.listeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target));\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.handleKeyDown = this.handleKeyDown.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.attach();\n    }\n    attach() {\n        this.handleStart();\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        setTimeout(()=>this.listeners.add(EventName.Keydown, this.handleKeyDown));\n    }\n    handleStart() {\n        const { activeNode, onStart } = this.props;\n        const node = activeNode.node.current;\n        if (node) {\n            scrollIntoViewIfNeeded(node);\n        }\n        onStart(defaultCoordinates);\n    }\n    handleKeyDown(event) {\n        if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(event)) {\n            const { active, context, options } = this.props;\n            const { keyboardCodes = defaultKeyboardCodes, coordinateGetter = defaultKeyboardCoordinateGetter, scrollBehavior = \"smooth\" } = options;\n            const { code } = event;\n            if (keyboardCodes.end.includes(code)) {\n                this.handleEnd(event);\n                return;\n            }\n            if (keyboardCodes.cancel.includes(code)) {\n                this.handleCancel(event);\n                return;\n            }\n            const { collisionRect } = context.current;\n            const currentCoordinates = collisionRect ? {\n                x: collisionRect.left,\n                y: collisionRect.top\n            } : defaultCoordinates;\n            if (!this.referenceCoordinates) {\n                this.referenceCoordinates = currentCoordinates;\n            }\n            const newCoordinates = coordinateGetter(event, {\n                active,\n                context: context.current,\n                currentCoordinates\n            });\n            if (newCoordinates) {\n                const coordinatesDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, currentCoordinates);\n                const scrollDelta = {\n                    x: 0,\n                    y: 0\n                };\n                const { scrollableAncestors } = context.current;\n                for (const scrollContainer of scrollableAncestors){\n                    const direction = event.code;\n                    const { isTop, isRight, isLeft, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);\n                    const scrollElementRect = getScrollElementRect(scrollContainer);\n                    const clampedCoordinates = {\n                        x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),\n                        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))\n                    };\n                    const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;\n                    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;\n                    if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {\n                        const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.y) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                left: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;\n                        } else {\n                            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;\n                        }\n                        if (scrollDelta.x) {\n                            scrollContainer.scrollBy({\n                                left: -scrollDelta.x,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {\n                        const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;\n                        const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;\n                        if (canScrollToNewCoordinates && !coordinatesDelta.x) {\n                            // We don't need to update coordinates, the scroll adjustment alone will trigger\n                            // logic to auto-detect the new container we are over\n                            scrollContainer.scrollTo({\n                                top: newScrollCoordinates,\n                                behavior: scrollBehavior\n                            });\n                            return;\n                        }\n                        if (canScrollToNewCoordinates) {\n                            scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;\n                        } else {\n                            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;\n                        }\n                        if (scrollDelta.y) {\n                            scrollContainer.scrollBy({\n                                top: -scrollDelta.y,\n                                behavior: scrollBehavior\n                            });\n                        }\n                        break;\n                    }\n                }\n                this.handleMove(event, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(newCoordinates, this.referenceCoordinates), scrollDelta));\n            }\n        }\n    }\n    handleMove(event, coordinates) {\n        const { onMove } = this.props;\n        event.preventDefault();\n        onMove(coordinates);\n    }\n    handleEnd(event) {\n        const { onEnd } = this.props;\n        event.preventDefault();\n        this.detach();\n        onEnd();\n    }\n    handleCancel(event) {\n        const { onCancel } = this.props;\n        event.preventDefault();\n        this.detach();\n        onCancel();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll();\n    }\n}\nKeyboardSensor.activators = [\n    {\n        eventName: \"onKeyDown\",\n        handler: (event, _ref, _ref2)=>{\n            let { keyboardCodes = defaultKeyboardCodes, onActivation } = _ref;\n            let { active } = _ref2;\n            const { code } = event.nativeEvent;\n            if (keyboardCodes.start.includes(code)) {\n                const activator = active.activatorNode.current;\n                if (activator && event.target !== activator) {\n                    return false;\n                }\n                event.preventDefault();\n                onActivation == null ? void 0 : onActivation({\n                    event: event.nativeEvent\n                });\n                return true;\n            }\n            return false;\n        }\n    }\n];\nfunction isDistanceConstraint(constraint) {\n    return Boolean(constraint && \"distance\" in constraint);\n}\nfunction isDelayConstraint(constraint) {\n    return Boolean(constraint && \"delay\" in constraint);\n}\nclass AbstractPointerSensor {\n    constructor(props, events, listenerTarget){\n        var _getEventCoordinates;\n        if (listenerTarget === void 0) {\n            listenerTarget = getEventListenerTarget(props.event.target);\n        }\n        this.props = void 0;\n        this.events = void 0;\n        this.autoScrollEnabled = true;\n        this.document = void 0;\n        this.activated = false;\n        this.initialCoordinates = void 0;\n        this.timeoutId = null;\n        this.listeners = void 0;\n        this.documentListeners = void 0;\n        this.windowListeners = void 0;\n        this.props = props;\n        this.events = events;\n        const { event } = props;\n        const { target } = event;\n        this.props = props;\n        this.events = events;\n        this.document = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(target);\n        this.documentListeners = new Listeners(this.document);\n        this.listeners = new Listeners(listenerTarget);\n        this.windowListeners = new Listeners((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(target));\n        this.initialCoordinates = (_getEventCoordinates = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates : defaultCoordinates;\n        this.handleStart = this.handleStart.bind(this);\n        this.handleMove = this.handleMove.bind(this);\n        this.handleEnd = this.handleEnd.bind(this);\n        this.handleCancel = this.handleCancel.bind(this);\n        this.handleKeydown = this.handleKeydown.bind(this);\n        this.removeTextSelection = this.removeTextSelection.bind(this);\n        this.attach();\n    }\n    attach() {\n        const { events, props: { options: { activationConstraint } } } = this;\n        this.listeners.add(events.move.name, this.handleMove, {\n            passive: false\n        });\n        this.listeners.add(events.end.name, this.handleEnd);\n        this.windowListeners.add(EventName.Resize, this.handleCancel);\n        this.windowListeners.add(EventName.DragStart, preventDefault);\n        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);\n        this.windowListeners.add(EventName.ContextMenu, preventDefault);\n        this.documentListeners.add(EventName.Keydown, this.handleKeydown);\n        if (activationConstraint) {\n            if (isDistanceConstraint(activationConstraint)) {\n                return;\n            }\n            if (isDelayConstraint(activationConstraint)) {\n                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);\n                return;\n            }\n        }\n        this.handleStart();\n    }\n    detach() {\n        this.listeners.removeAll();\n        this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners\n        // This is necessary because we listen for `click` and `selection` events on the document\n        setTimeout(this.documentListeners.removeAll, 50);\n        if (this.timeoutId !== null) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n    handleStart() {\n        const { initialCoordinates } = this;\n        const { onStart } = this.props;\n        if (initialCoordinates) {\n            this.activated = true; // Stop propagation of click events once activation constraints are met\n            this.documentListeners.add(EventName.Click, stopPropagation, {\n                capture: true\n            }); // Remove any text selection from the document\n            this.removeTextSelection(); // Prevent further text selection while dragging\n            this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);\n            onStart(initialCoordinates);\n        }\n    }\n    handleMove(event) {\n        var _getEventCoordinates2;\n        const { activated, initialCoordinates, props } = this;\n        const { onMove, options: { activationConstraint } } = props;\n        if (!initialCoordinates) {\n            return;\n        }\n        const coordinates = (_getEventCoordinates2 = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(event)) != null ? _getEventCoordinates2 : defaultCoordinates;\n        const delta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(initialCoordinates, coordinates);\n        if (!activated && activationConstraint) {\n            // Constraint validation\n            if (isDelayConstraint(activationConstraint)) {\n                if (hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n                return;\n            }\n            if (isDistanceConstraint(activationConstraint)) {\n                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {\n                    return this.handleCancel();\n                }\n                if (hasExceededDistance(delta, activationConstraint.distance)) {\n                    return this.handleStart();\n                }\n                return;\n            }\n        }\n        if (event.cancelable) {\n            event.preventDefault();\n        }\n        onMove(coordinates);\n    }\n    handleEnd() {\n        const { onEnd } = this.props;\n        this.detach();\n        onEnd();\n    }\n    handleCancel() {\n        const { onCancel } = this.props;\n        this.detach();\n        onCancel();\n    }\n    handleKeydown(event) {\n        if (event.code === KeyboardCode.Esc) {\n            this.handleCancel();\n        }\n    }\n    removeTextSelection() {\n        var _this$document$getSel;\n        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();\n    }\n}\nconst events = {\n    move: {\n        name: \"pointermove\"\n    },\n    end: {\n        name: \"pointerup\"\n    }\n};\nclass PointerSensor extends AbstractPointerSensor {\n    constructor(props){\n        const { event } = props; // Pointer events stop firing if the target is unmounted while dragging\n        // Therefore we attach listeners to the owner document instead\n        const listenerTarget = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(event.target);\n        super(props, events, listenerTarget);\n    }\n}\nPointerSensor.activators = [\n    {\n        eventName: \"onPointerDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (!event.isPrimary || event.button !== 0) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$1 = {\n    move: {\n        name: \"mousemove\"\n    },\n    end: {\n        name: \"mouseup\"\n    }\n};\nvar MouseButton;\n(function(MouseButton) {\n    MouseButton[MouseButton[\"RightClick\"] = 2] = \"RightClick\";\n})(MouseButton || (MouseButton = {}));\nclass MouseSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$1, (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getOwnerDocument)(props.event.target));\n    }\n}\nMouseSensor.activators = [\n    {\n        eventName: \"onMouseDown\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            if (event.button === MouseButton.RightClick) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nconst events$2 = {\n    move: {\n        name: \"touchmove\"\n    },\n    end: {\n        name: \"touchend\"\n    }\n};\nclass TouchSensor extends AbstractPointerSensor {\n    constructor(props){\n        super(props, events$2);\n    }\n    static setup() {\n        // Adding a non-capture and non-passive `touchmove` listener in order\n        // to force `event.preventDefault()` calls to work in dynamically added\n        // touchmove event handlers. This is required for iOS Safari.\n        window.addEventListener(events$2.move.name, noop, {\n            capture: false,\n            passive: false\n        });\n        return function teardown() {\n            window.removeEventListener(events$2.move.name, noop);\n        }; // We create a new handler because the teardown function of another sensor\n        // could remove our event listener if we use a referentially equal listener.\n        function noop() {}\n    }\n}\nTouchSensor.activators = [\n    {\n        eventName: \"onTouchStart\",\n        handler: (_ref, _ref2)=>{\n            let { nativeEvent: event } = _ref;\n            let { onActivation } = _ref2;\n            const { touches } = event;\n            if (touches.length > 1) {\n                return false;\n            }\n            onActivation == null ? void 0 : onActivation({\n                event\n            });\n            return true;\n        }\n    }\n];\nvar AutoScrollActivator;\n(function(AutoScrollActivator) {\n    AutoScrollActivator[AutoScrollActivator[\"Pointer\"] = 0] = \"Pointer\";\n    AutoScrollActivator[AutoScrollActivator[\"DraggableRect\"] = 1] = \"DraggableRect\";\n})(AutoScrollActivator || (AutoScrollActivator = {}));\nvar TraversalOrder;\n(function(TraversalOrder) {\n    TraversalOrder[TraversalOrder[\"TreeOrder\"] = 0] = \"TreeOrder\";\n    TraversalOrder[TraversalOrder[\"ReversedTreeOrder\"] = 1] = \"ReversedTreeOrder\";\n})(TraversalOrder || (TraversalOrder = {}));\nfunction useAutoScroller(_ref) {\n    let { acceleration, activator = AutoScrollActivator.Pointer, canScroll, draggingRect, enabled, interval = 5, order = TraversalOrder.TreeOrder, pointerCoordinates, scrollableAncestors, scrollableAncestorRects, delta, threshold } = _ref;\n    const scrollIntent = useScrollIntent({\n        delta,\n        disabled: !enabled\n    });\n    const [setAutoScrollInterval, clearAutoScrollInterval] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useInterval)();\n    const scrollSpeed = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const scrollDirection = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0\n    });\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        switch(activator){\n            case AutoScrollActivator.Pointer:\n                return pointerCoordinates ? {\n                    top: pointerCoordinates.y,\n                    bottom: pointerCoordinates.y,\n                    left: pointerCoordinates.x,\n                    right: pointerCoordinates.x\n                } : null;\n            case AutoScrollActivator.DraggableRect:\n                return draggingRect;\n        }\n    }, [\n        activator,\n        draggingRect,\n        pointerCoordinates\n    ]);\n    const scrollContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const autoScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const scrollContainer = scrollContainerRef.current;\n        if (!scrollContainer) {\n            return;\n        }\n        const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;\n        const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;\n        scrollContainer.scrollBy(scrollLeft, scrollTop);\n    }, []);\n    const sortedScrollableAncestors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>order === TraversalOrder.TreeOrder ? [\n            ...scrollableAncestors\n        ].reverse() : scrollableAncestors, [\n        order,\n        scrollableAncestors\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!enabled || !scrollableAncestors.length || !rect) {\n            clearAutoScrollInterval();\n            return;\n        }\n        for (const scrollContainer of sortedScrollableAncestors){\n            if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {\n                continue;\n            }\n            const index = scrollableAncestors.indexOf(scrollContainer);\n            const scrollContainerRect = scrollableAncestorRects[index];\n            if (!scrollContainerRect) {\n                continue;\n            }\n            const { direction, speed } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);\n            for (const axis of [\n                \"x\",\n                \"y\"\n            ]){\n                if (!scrollIntent[axis][direction[axis]]) {\n                    speed[axis] = 0;\n                    direction[axis] = 0;\n                }\n            }\n            if (speed.x > 0 || speed.y > 0) {\n                clearAutoScrollInterval();\n                scrollContainerRef.current = scrollContainer;\n                setAutoScrollInterval(autoScroll, interval);\n                scrollSpeed.current = speed;\n                scrollDirection.current = direction;\n                return;\n            }\n        }\n        scrollSpeed.current = {\n            x: 0,\n            y: 0\n        };\n        scrollDirection.current = {\n            x: 0,\n            y: 0\n        };\n        clearAutoScrollInterval();\n    }, [\n        acceleration,\n        autoScroll,\n        canScroll,\n        clearAutoScrollInterval,\n        enabled,\n        interval,\n        JSON.stringify(rect),\n        JSON.stringify(scrollIntent),\n        setAutoScrollInterval,\n        scrollableAncestors,\n        sortedScrollableAncestors,\n        scrollableAncestorRects,\n        JSON.stringify(threshold)\n    ]);\n}\nconst defaultScrollIntent = {\n    x: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    },\n    y: {\n        [Direction.Backward]: false,\n        [Direction.Forward]: false\n    }\n};\nfunction useScrollIntent(_ref2) {\n    let { delta, disabled } = _ref2;\n    const previousDelta = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(delta);\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousIntent)=>{\n        if (disabled || !previousDelta || !previousIntent) {\n            // Reset scroll intent tracking when auto-scrolling is disabled\n            return defaultScrollIntent;\n        }\n        const direction = {\n            x: Math.sign(delta.x - previousDelta.x),\n            y: Math.sign(delta.y - previousDelta.y)\n        }; // Keep track of the user intent to scroll in each direction for both axis\n        return {\n            x: {\n                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,\n                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1\n            },\n            y: {\n                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,\n                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1\n            }\n        };\n    }, [\n        disabled,\n        delta,\n        previousDelta\n    ]);\n}\nfunction useCachedNode(draggableNodes, id) {\n    const draggableNode = id !== null ? draggableNodes.get(id) : undefined;\n    const node = draggableNode ? draggableNode.node.current : null;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((cachedNode)=>{\n        var _ref;\n        if (id === null) {\n            return null;\n        } // In some cases, the draggable node can unmount while dragging\n        // This is the case for virtualized lists. In those situations,\n        // we fall back to the last known value for that node.\n        return (_ref = node != null ? node : cachedNode) != null ? _ref : null;\n    }, [\n        node,\n        id\n    ]);\n}\nfunction useCombineActivators(sensors, getSyntheticHandler) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>sensors.reduce((accumulator, sensor)=>{\n            const { sensor: Sensor } = sensor;\n            const sensorActivators = Sensor.activators.map((activator)=>({\n                    eventName: activator.eventName,\n                    handler: getSyntheticHandler(activator.handler, sensor)\n                }));\n            return [\n                ...accumulator,\n                ...sensorActivators\n            ];\n        }, []), [\n        sensors,\n        getSyntheticHandler\n    ]);\n}\nvar MeasuringStrategy;\n(function(MeasuringStrategy) {\n    MeasuringStrategy[MeasuringStrategy[\"Always\"] = 0] = \"Always\";\n    MeasuringStrategy[MeasuringStrategy[\"BeforeDragging\"] = 1] = \"BeforeDragging\";\n    MeasuringStrategy[MeasuringStrategy[\"WhileDragging\"] = 2] = \"WhileDragging\";\n})(MeasuringStrategy || (MeasuringStrategy = {}));\nvar MeasuringFrequency;\n(function(MeasuringFrequency) {\n    MeasuringFrequency[\"Optimized\"] = \"optimized\";\n})(MeasuringFrequency || (MeasuringFrequency = {}));\nconst defaultValue = /*#__PURE__*/ new Map();\nfunction useDroppableMeasuring(containers, _ref) {\n    let { dragging, dependencies, config } = _ref;\n    const [queue, setQueue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { frequency, measure, strategy } = config;\n    const containersRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(containers);\n    const disabled = isDisabled();\n    const disabledRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(disabled);\n    const measureDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(ids) {\n        if (ids === void 0) {\n            ids = [];\n        }\n        if (disabledRef.current) {\n            return;\n        }\n        setQueue((value)=>{\n            if (value === null) {\n                return ids;\n            }\n            return value.concat(ids.filter((id)=>!value.includes(id)));\n        });\n    }, [\n        disabledRef\n    ]);\n    const timeoutId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const droppableRects = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (disabled && !dragging) {\n            return defaultValue;\n        }\n        if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {\n            const map = new Map();\n            for (let container of containers){\n                if (!container) {\n                    continue;\n                }\n                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {\n                    // This container does not need to be re-measured\n                    map.set(container.id, container.rect.current);\n                    continue;\n                }\n                const node = container.node.current;\n                const rect = node ? new Rect(measure(node), node) : null;\n                container.rect.current = rect;\n                if (rect) {\n                    map.set(container.id, rect);\n                }\n            }\n            return map;\n        }\n        return previousValue;\n    }, [\n        containers,\n        queue,\n        dragging,\n        disabled,\n        measure\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        containersRef.current = containers;\n    }, [\n        containers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        measureDroppableContainers();\n    }, [\n        dragging,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (queue && queue.length > 0) {\n            setQueue(null);\n        }\n    }, [\n        JSON.stringify(queue)\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled || typeof frequency !== \"number\" || timeoutId.current !== null) {\n            return;\n        }\n        timeoutId.current = setTimeout(()=>{\n            measureDroppableContainers();\n            timeoutId.current = null;\n        }, frequency);\n    }, [\n        frequency,\n        disabled,\n        measureDroppableContainers,\n        ...dependencies\n    ]);\n    return {\n        droppableRects,\n        measureDroppableContainers,\n        measuringScheduled: queue != null\n    };\n    function isDisabled() {\n        switch(strategy){\n            case MeasuringStrategy.Always:\n                return false;\n            case MeasuringStrategy.BeforeDragging:\n                return dragging;\n            default:\n                return !dragging;\n        }\n    }\n}\nfunction useInitialValue(value, computeFn) {\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!value) {\n            return null;\n        }\n        if (previousValue) {\n            return previousValue;\n        }\n        return typeof computeFn === \"function\" ? computeFn(value) : value;\n    }, [\n        computeFn,\n        value\n    ]);\n}\nfunction useInitialRect(node, measure) {\n    return useInitialValue(node, measure);\n}\n/**\r\n * Returns a new MutationObserver instance.\r\n * If `MutationObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useMutationObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleMutations = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const mutationObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { MutationObserver } = window;\n        return new MutationObserver(handleMutations);\n    }, [\n        handleMutations,\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>mutationObserver == null ? void 0 : mutationObserver.disconnect();\n    }, [\n        mutationObserver\n    ]);\n    return mutationObserver;\n}\n/**\r\n * Returns a new ResizeObserver instance bound to the `onResize` callback.\r\n * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.\r\n */ function useResizeObserver(_ref) {\n    let { callback, disabled } = _ref;\n    const handleResize = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)(callback);\n    const resizeObserver = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (disabled || \"undefined\" === \"undefined\" || 0) {\n            return undefined;\n        }\n        const { ResizeObserver } = window;\n        return new ResizeObserver(handleResize);\n    }, [\n        disabled\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        return ()=>resizeObserver == null ? void 0 : resizeObserver.disconnect();\n    }, [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\nfunction defaultMeasure(element) {\n    return new Rect(getClientRect(element), element);\n}\nfunction useRect(element, measure, fallbackRect) {\n    if (measure === void 0) {\n        measure = defaultMeasure;\n    }\n    const [rect, measureRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, null);\n    const mutationObserver = useMutationObserver({\n        callback (records) {\n            if (!element) {\n                return;\n            }\n            for (const record of records){\n                const { type, target } = record;\n                if (type === \"childList\" && target instanceof HTMLElement && target.contains(element)) {\n                    measureRect();\n                    break;\n                }\n            }\n        }\n    });\n    const resizeObserver = useResizeObserver({\n        callback: measureRect\n    });\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        measureRect();\n        if (element) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(element);\n            mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        }\n    }, [\n        element\n    ]);\n    return rect;\n    function reducer(currentRect) {\n        if (!element) {\n            return null;\n        }\n        if (element.isConnected === false) {\n            var _ref;\n            // Fall back to last rect we measured if the element is\n            // no longer connected to the DOM.\n            return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;\n        }\n        const newRect = measure(element);\n        if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {\n            return currentRect;\n        }\n        return newRect;\n    }\n}\nfunction useRectDelta(rect) {\n    const initialRect = useInitialValue(rect);\n    return getRectDelta(rect, initialRect);\n}\nconst defaultValue$1 = [];\nfunction useScrollableAncestors(node) {\n    const previousNode = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(node);\n    const ancestors = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLazyMemo)((previousValue)=>{\n        if (!node) {\n            return defaultValue$1;\n        }\n        if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {\n            return previousValue;\n        }\n        return getScrollableAncestors(node);\n    }, [\n        node\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousNode.current = node;\n    }, [\n        node\n    ]);\n    return ancestors;\n}\nfunction useScrollOffsets(elements) {\n    const [scrollCoordinates, setScrollCoordinates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const prevElements = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(elements); // To-do: Throttle the handleScroll callback\n    const handleScroll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event)=>{\n        const scrollingElement = getScrollableElement(event.target);\n        if (!scrollingElement) {\n            return;\n        }\n        setScrollCoordinates((scrollCoordinates)=>{\n            if (!scrollCoordinates) {\n                return null;\n            }\n            scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));\n            return new Map(scrollCoordinates);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const previousElements = prevElements.current;\n        if (elements !== previousElements) {\n            cleanup(previousElements);\n            const entries = elements.map((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                if (scrollableElement) {\n                    scrollableElement.addEventListener(\"scroll\", handleScroll, {\n                        passive: true\n                    });\n                    return [\n                        scrollableElement,\n                        getScrollCoordinates(scrollableElement)\n                    ];\n                }\n                return null;\n            }).filter((entry)=>entry != null);\n            setScrollCoordinates(entries.length ? new Map(entries) : null);\n            prevElements.current = elements;\n        }\n        return ()=>{\n            cleanup(elements);\n            cleanup(previousElements);\n        };\n        function cleanup(elements) {\n            elements.forEach((element)=>{\n                const scrollableElement = getScrollableElement(element);\n                scrollableElement == null ? void 0 : scrollableElement.removeEventListener(\"scroll\", handleScroll);\n            });\n        }\n    }, [\n        handleScroll,\n        elements\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (elements.length) {\n            return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates)=>(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);\n        }\n        return defaultCoordinates;\n    }, [\n        elements,\n        scrollCoordinates\n    ]);\n}\nfunction useScrollOffsetsDelta(scrollOffsets, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [];\n    }\n    const initialScrollOffsets = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        initialScrollOffsets.current = null;\n    }, dependencies);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const hasScrollOffsets = scrollOffsets !== defaultCoordinates;\n        if (hasScrollOffsets && !initialScrollOffsets.current) {\n            initialScrollOffsets.current = scrollOffsets;\n        }\n        if (!hasScrollOffsets && initialScrollOffsets.current) {\n            initialScrollOffsets.current = null;\n        }\n    }, [\n        scrollOffsets\n    ]);\n    return initialScrollOffsets.current ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;\n}\nfunction useSensorSetup(sensors) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.canUseDOM) {\n            return;\n        }\n        const teardownFns = sensors.map((_ref)=>{\n            let { sensor } = _ref;\n            return sensor.setup == null ? void 0 : sensor.setup();\n        });\n        return ()=>{\n            for (const teardown of teardownFns){\n                teardown == null ? void 0 : teardown();\n            }\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    sensors.map((_ref2)=>{\n        let { sensor } = _ref2;\n        return sensor;\n    }));\n}\nfunction useSyntheticListeners(listeners, id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        return listeners.reduce((acc, _ref)=>{\n            let { eventName, handler } = _ref;\n            acc[eventName] = (event)=>{\n                handler(event, id);\n            };\n            return acc;\n        }, {});\n    }, [\n        listeners,\n        id\n    ]);\n}\nfunction useWindowRect(element) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>element ? getWindowClientRect(element) : null, [\n        element\n    ]);\n}\nconst defaultValue$2 = [];\nfunction useRects(elements, measure) {\n    if (measure === void 0) {\n        measure = getClientRect;\n    }\n    const [firstElement] = elements;\n    const windowRect = useWindowRect(firstElement ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(firstElement) : null);\n    const [rects, measureRects] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, defaultValue$2);\n    const resizeObserver = useResizeObserver({\n        callback: measureRects\n    });\n    if (elements.length > 0 && rects === defaultValue$2) {\n        measureRects();\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (elements.length) {\n            elements.forEach((element)=>resizeObserver == null ? void 0 : resizeObserver.observe(element));\n        } else {\n            resizeObserver == null ? void 0 : resizeObserver.disconnect();\n            measureRects();\n        }\n    }, [\n        elements\n    ]);\n    return rects;\n    function reducer() {\n        if (!elements.length) {\n            return defaultValue$2;\n        }\n        return elements.map((element)=>isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));\n    }\n}\nfunction getMeasurableNode(node) {\n    if (!node) {\n        return null;\n    }\n    if (node.children.length > 1) {\n        return node;\n    }\n    const firstChild = node.children[0];\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(firstChild) ? firstChild : node;\n}\nfunction useDragOverlayMeasuring(_ref) {\n    let { measure } = _ref;\n    const [rect, setRect] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((entries)=>{\n        for (const { target } of entries){\n            if ((0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(target)) {\n                setRect((rect)=>{\n                    const newRect = measure(target);\n                    return rect ? {\n                        ...rect,\n                        width: newRect.width,\n                        height: newRect.height\n                    } : newRect;\n                });\n                break;\n            }\n        }\n    }, [\n        measure\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        const node = getMeasurableNode(element);\n        resizeObserver == null ? void 0 : resizeObserver.disconnect();\n        if (node) {\n            resizeObserver == null ? void 0 : resizeObserver.observe(node);\n        }\n        setRect(node ? measure(node) : null);\n    }, [\n        measure,\n        resizeObserver\n    ]);\n    const [nodeRef, setRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            nodeRef,\n            rect,\n            setRef\n        }), [\n        rect,\n        nodeRef,\n        setRef\n    ]);\n}\nconst defaultSensors = [\n    {\n        sensor: PointerSensor,\n        options: {}\n    },\n    {\n        sensor: KeyboardSensor,\n        options: {}\n    }\n];\nconst defaultData = {\n    current: {}\n};\nconst defaultMeasuringConfiguration = {\n    draggable: {\n        measure: getTransformAgnosticClientRect\n    },\n    droppable: {\n        measure: getTransformAgnosticClientRect,\n        strategy: MeasuringStrategy.WhileDragging,\n        frequency: MeasuringFrequency.Optimized\n    },\n    dragOverlay: {\n        measure: getClientRect\n    }\n};\nclass DroppableContainersMap extends Map {\n    get(id) {\n        var _super$get;\n        return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;\n    }\n    toArray() {\n        return Array.from(this.values());\n    }\n    getEnabled() {\n        return this.toArray().filter((_ref)=>{\n            let { disabled } = _ref;\n            return !disabled;\n        });\n    }\n    getNodeFor(id) {\n        var _this$get$node$curren, _this$get;\n        return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;\n    }\n}\nconst defaultPublicContext = {\n    activatorEvent: null,\n    active: null,\n    activeNode: null,\n    activeNodeRect: null,\n    collisions: null,\n    containerNodeRect: null,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    droppableRects: /*#__PURE__*/ new Map(),\n    droppableContainers: /*#__PURE__*/ new DroppableContainersMap(),\n    over: null,\n    dragOverlay: {\n        nodeRef: {\n            current: null\n        },\n        rect: null,\n        setRef: noop\n    },\n    scrollableAncestors: [],\n    scrollableAncestorRects: [],\n    measuringConfiguration: defaultMeasuringConfiguration,\n    measureDroppableContainers: noop,\n    windowRect: null,\n    measuringScheduled: false\n};\nconst defaultInternalContext = {\n    activatorEvent: null,\n    activators: [],\n    active: null,\n    activeNodeRect: null,\n    ariaDescribedById: {\n        draggable: \"\"\n    },\n    dispatch: noop,\n    draggableNodes: /*#__PURE__*/ new Map(),\n    over: null,\n    measureDroppableContainers: noop\n};\nconst InternalContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultInternalContext);\nconst PublicContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(defaultPublicContext);\nfunction getInitialState() {\n    return {\n        draggable: {\n            active: null,\n            initialCoordinates: {\n                x: 0,\n                y: 0\n            },\n            nodes: new Map(),\n            translate: {\n                x: 0,\n                y: 0\n            }\n        },\n        droppable: {\n            containers: new DroppableContainersMap()\n        }\n    };\n}\nfunction reducer(state, action) {\n    switch(action.type){\n        case Action.DragStart:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    initialCoordinates: action.initialCoordinates,\n                    active: action.active\n                }\n            };\n        case Action.DragMove:\n            if (!state.draggable.active) {\n                return state;\n            }\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    translate: {\n                        x: action.coordinates.x - state.draggable.initialCoordinates.x,\n                        y: action.coordinates.y - state.draggable.initialCoordinates.y\n                    }\n                }\n            };\n        case Action.DragEnd:\n        case Action.DragCancel:\n            return {\n                ...state,\n                draggable: {\n                    ...state.draggable,\n                    active: null,\n                    initialCoordinates: {\n                        x: 0,\n                        y: 0\n                    },\n                    translate: {\n                        x: 0,\n                        y: 0\n                    }\n                }\n            };\n        case Action.RegisterDroppable:\n            {\n                const { element } = action;\n                const { id } = element;\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, element);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.SetDroppableDisabled:\n            {\n                const { id, key, disabled } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.set(id, {\n                    ...element,\n                    disabled\n                });\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        case Action.UnregisterDroppable:\n            {\n                const { id, key } = action;\n                const element = state.droppable.containers.get(id);\n                if (!element || key !== element.key) {\n                    return state;\n                }\n                const containers = new DroppableContainersMap(state.droppable.containers);\n                containers.delete(id);\n                return {\n                    ...state,\n                    droppable: {\n                        ...state.droppable,\n                        containers\n                    }\n                };\n            }\n        default:\n            {\n                return state;\n            }\n    }\n}\nfunction RestoreFocus(_ref) {\n    let { disabled } = _ref;\n    const { active, activatorEvent, draggableNodes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previousActivatorEvent = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(activatorEvent);\n    const previousActiveId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled) {\n            return;\n        }\n        if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {\n            if (!(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(previousActivatorEvent)) {\n                return;\n            }\n            if (document.activeElement === previousActivatorEvent.target) {\n                // No need to restore focus\n                return;\n            }\n            const draggableNode = draggableNodes.get(previousActiveId);\n            if (!draggableNode) {\n                return;\n            }\n            const { activatorNode, node } = draggableNode;\n            if (!activatorNode.current && !node.current) {\n                return;\n            }\n            requestAnimationFrame(()=>{\n                for (const element of [\n                    activatorNode.current,\n                    node.current\n                ]){\n                    if (!element) {\n                        continue;\n                    }\n                    const focusableNode = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.findFirstFocusableNode)(element);\n                    if (focusableNode) {\n                        focusableNode.focus();\n                        break;\n                    }\n                }\n            });\n        }\n    }, [\n        activatorEvent,\n        disabled,\n        draggableNodes,\n        previousActiveId,\n        previousActivatorEvent\n    ]);\n    return null;\n}\nfunction applyModifiers(modifiers, _ref) {\n    let { transform, ...args } = _ref;\n    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier)=>{\n        return modifier({\n            transform: accumulator,\n            ...args\n        });\n    }, transform) : transform;\n}\nfunction useMeasuringConfiguration(config) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            draggable: {\n                ...defaultMeasuringConfiguration.draggable,\n                ...config == null ? void 0 : config.draggable\n            },\n            droppable: {\n                ...defaultMeasuringConfiguration.droppable,\n                ...config == null ? void 0 : config.droppable\n            },\n            dragOverlay: {\n                ...defaultMeasuringConfiguration.dragOverlay,\n                ...config == null ? void 0 : config.dragOverlay\n            }\n        }), [\n        config == null ? void 0 : config.draggable,\n        config == null ? void 0 : config.droppable,\n        config == null ? void 0 : config.dragOverlay\n    ]);\n}\nfunction useLayoutShiftScrollCompensation(_ref) {\n    let { activeNode, measure, initialRect, config = true } = _ref;\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const { x, y } = typeof config === \"boolean\" ? {\n        x: config,\n        y: config\n    } : config;\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        const disabled = !x && !y;\n        if (disabled || !activeNode) {\n            initialized.current = false;\n            return;\n        }\n        if (initialized.current || !initialRect) {\n            // Return early if layout shift scroll compensation was already attempted\n            // or if there is no initialRect to compare to.\n            return;\n        } // Get the most up to date node ref for the active draggable\n        const node = activeNode == null ? void 0 : activeNode.node.current;\n        if (!node || node.isConnected === false) {\n            // Return early if there is no attached node ref or if the node is\n            // disconnected from the document.\n            return;\n        }\n        const rect = measure(node);\n        const rectDelta = getRectDelta(rect, initialRect);\n        if (!x) {\n            rectDelta.x = 0;\n        }\n        if (!y) {\n            rectDelta.y = 0;\n        } // Only perform layout shift scroll compensation once\n        initialized.current = true;\n        if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {\n            const firstScrollableAncestor = getFirstScrollableAncestor(node);\n            if (firstScrollableAncestor) {\n                firstScrollableAncestor.scrollBy({\n                    top: rectDelta.y,\n                    left: rectDelta.x\n                });\n            }\n        }\n    }, [\n        activeNode,\n        x,\n        y,\n        initialRect,\n        measure\n    ]);\n}\nconst ActiveDraggableContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    ...defaultCoordinates,\n    scaleX: 1,\n    scaleY: 1\n});\nvar Status;\n(function(Status) {\n    Status[Status[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    Status[Status[\"Initializing\"] = 1] = \"Initializing\";\n    Status[Status[\"Initialized\"] = 2] = \"Initialized\";\n})(Status || (Status = {}));\nconst DndContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(function DndContext(_ref) {\n    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;\n    let { id, accessibility, autoScroll = true, children, sensors = defaultSensors, collisionDetection = rectIntersection, measuring, modifiers, ...props } = _ref;\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(reducer, undefined, getInitialState);\n    const [state, dispatch] = store;\n    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(Status.Uninitialized);\n    const isInitialized = status === Status.Initialized;\n    const { draggable: { active: activeId, nodes: draggableNodes, translate }, droppable: { containers: droppableContainers } } = state;\n    const node = activeId ? draggableNodes.get(activeId) : null;\n    const activeRects = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        initial: null,\n        translated: null\n    });\n    const active = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        var _node$data;\n        return activeId != null ? {\n            id: activeId,\n            // It's possible for the active node to unmount while dragging\n            data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,\n            rect: activeRects\n        } : null;\n    }, [\n        activeId,\n        node\n    ]);\n    const activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [activeSensor, setActiveSensor] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [activatorEvent, setActivatorEvent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const latestProps = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(props, Object.values(props));\n    const draggableDescribedById = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(\"DndDescribedBy\", id);\n    const enabledDroppableContainers = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>droppableContainers.getEnabled(), [\n        droppableContainers\n    ]);\n    const measuringConfiguration = useMeasuringConfiguration(measuring);\n    const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(enabledDroppableContainers, {\n        dragging: isInitialized,\n        dependencies: [\n            translate.x,\n            translate.y\n        ],\n        config: measuringConfiguration.droppable\n    });\n    const activeNode = useCachedNode(draggableNodes, activeId);\n    const activationCoordinates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>activatorEvent ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getEventCoordinates)(activatorEvent) : null, [\n        activatorEvent\n    ]);\n    const autoScrollOptions = getAutoScrollerOptions();\n    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);\n    useLayoutShiftScrollCompensation({\n        activeNode: activeId ? draggableNodes.get(activeId) : null,\n        config: autoScrollOptions.layoutShiftCompensation,\n        initialRect: initialActiveNodeRect,\n        measure: measuringConfiguration.draggable.measure\n    });\n    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);\n    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);\n    const sensorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activatorEvent: null,\n        active: null,\n        activeNode,\n        collisionRect: null,\n        collisions: null,\n        droppableRects,\n        draggableNodes,\n        draggingNode: null,\n        draggingNodeRect: null,\n        droppableContainers,\n        over: null,\n        scrollableAncestors: [],\n        scrollAdjustedTranslate: null\n    });\n    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);\n    const dragOverlay = useDragOverlayMeasuring({\n        measure: measuringConfiguration.dragOverlay.measure\n    }); // Use the rect of the drag overlay if it is mounted\n    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;\n    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;\n    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node\n    // is only relevant when there is no drag overlay\n    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node\n    const windowRect = useWindowRect(draggingNode ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(draggingNode) : null); // Get scrollable ancestors of the dragging node\n    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);\n    const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers\n    const modifiedTranslate = applyModifiers(modifiers, {\n        transform: {\n            x: translate.x - nodeRectDelta.x,\n            y: translate.y - nodeRectDelta.y,\n            scaleX: 1,\n            scaleY: 1\n        },\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect,\n        over: sensorContext.current.over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        windowRect\n    });\n    const pointerCoordinates = activationCoordinates ? (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(activationCoordinates, translate) : null;\n    const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated\n    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured\n    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [\n        activeNodeRect\n    ]);\n    const scrollAdjustedTranslate = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, scrollAdjustment);\n    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;\n    const collisions = active && collisionRect ? collisionDetection({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers: enabledDroppableContainers,\n        pointerCoordinates\n    }) : null;\n    const overId = getFirstCollision(collisions, \"id\");\n    const [over, setOver] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // When there is no drag overlay used, we need to account for the\n    // window scroll delta\n    const appliedTranslate = usesDragOverlay ? modifiedTranslate : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.add)(modifiedTranslate, activeNodeScrollDelta);\n    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);\n    const instantiateSensor = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, _ref2)=>{\n        let { sensor: Sensor, options } = _ref2;\n        if (activeRef.current == null) {\n            return;\n        }\n        const activeNode = draggableNodes.get(activeRef.current);\n        if (!activeNode) {\n            return;\n        }\n        const activatorEvent = event.nativeEvent;\n        const sensorInstance = new Sensor({\n            active: activeRef.current,\n            activeNode,\n            event: activatorEvent,\n            options,\n            // Sensors need to be instantiated with refs for arguments that change over time\n            // otherwise they are frozen in time with the stale arguments\n            context: sensorContext,\n            onStart (initialCoordinates) {\n                const id = activeRef.current;\n                if (id == null) {\n                    return;\n                }\n                const draggableNode = draggableNodes.get(id);\n                if (!draggableNode) {\n                    return;\n                }\n                const { onDragStart } = latestProps.current;\n                const event = {\n                    active: {\n                        id,\n                        data: draggableNode.data,\n                        rect: activeRects\n                    }\n                };\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    onDragStart == null ? void 0 : onDragStart(event);\n                    setStatus(Status.Initializing);\n                    dispatch({\n                        type: Action.DragStart,\n                        initialCoordinates,\n                        active: id\n                    });\n                    dispatchMonitorEvent({\n                        type: \"onDragStart\",\n                        event\n                    });\n                });\n            },\n            onMove (coordinates) {\n                dispatch({\n                    type: Action.DragMove,\n                    coordinates\n                });\n            },\n            onEnd: createHandler(Action.DragEnd),\n            onCancel: createHandler(Action.DragCancel)\n        });\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setActiveSensor(sensorInstance);\n            setActivatorEvent(event.nativeEvent);\n        });\n        function createHandler(type) {\n            return async function handler() {\n                const { active, collisions, over, scrollAdjustedTranslate } = sensorContext.current;\n                let event = null;\n                if (active && scrollAdjustedTranslate) {\n                    const { cancelDrop } = latestProps.current;\n                    event = {\n                        activatorEvent,\n                        active: active,\n                        collisions,\n                        delta: scrollAdjustedTranslate,\n                        over\n                    };\n                    if (type === Action.DragEnd && typeof cancelDrop === \"function\") {\n                        const shouldCancel = await Promise.resolve(cancelDrop(event));\n                        if (shouldCancel) {\n                            type = Action.DragCancel;\n                        }\n                    }\n                }\n                activeRef.current = null;\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n                    dispatch({\n                        type\n                    });\n                    setStatus(Status.Uninitialized);\n                    setOver(null);\n                    setActiveSensor(null);\n                    setActivatorEvent(null);\n                    const eventName = type === Action.DragEnd ? \"onDragEnd\" : \"onDragCancel\";\n                    if (event) {\n                        const handler = latestProps.current[eventName];\n                        handler == null ? void 0 : handler(event);\n                        dispatchMonitorEvent({\n                            type: eventName,\n                            event\n                        });\n                    }\n                });\n            };\n        }\n    }, [\n        draggableNodes\n    ]);\n    const bindActivatorToSensorInstantiator = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handler, sensor)=>{\n        return (event, active)=>{\n            const nativeEvent = event.nativeEvent;\n            const activeDraggableNode = draggableNodes.get(active);\n            if (activeRef.current !== null || // No active draggable\n            !activeDraggableNode || // Event has already been captured\n            nativeEvent.dndKit || nativeEvent.defaultPrevented) {\n                return;\n            }\n            const activationContext = {\n                active: activeDraggableNode\n            };\n            const shouldActivate = handler(event, sensor.options, activationContext);\n            if (shouldActivate === true) {\n                nativeEvent.dndKit = {\n                    capturedBy: sensor.sensor\n                };\n                activeRef.current = active;\n                instantiateSensor(event, sensor);\n            }\n        };\n    }, [\n        draggableNodes,\n        instantiateSensor\n    ]);\n    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);\n    useSensorSetup(sensors);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (activeNodeRect && status === Status.Initializing) {\n            setStatus(Status.Initialized);\n        }\n    }, [\n        activeNodeRect,\n        status\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { onDragMove } = latestProps.current;\n        const { active, activatorEvent, collisions, over } = sensorContext.current;\n        if (!active || !activatorEvent) {\n            return;\n        }\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            onDragMove == null ? void 0 : onDragMove(event);\n            dispatchMonitorEvent({\n                type: \"onDragMove\",\n                event\n            });\n        });\n    }, [\n        scrollAdjustedTranslate.x,\n        scrollAdjustedTranslate.y\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const { active, activatorEvent, collisions, droppableContainers, scrollAdjustedTranslate } = sensorContext.current;\n        if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {\n            return;\n        }\n        const { onDragOver } = latestProps.current;\n        const overContainer = droppableContainers.get(overId);\n        const over = overContainer && overContainer.rect.current ? {\n            id: overContainer.id,\n            rect: overContainer.rect.current,\n            data: overContainer.data,\n            disabled: overContainer.disabled\n        } : null;\n        const event = {\n            active,\n            activatorEvent,\n            collisions,\n            delta: {\n                x: scrollAdjustedTranslate.x,\n                y: scrollAdjustedTranslate.y\n            },\n            over\n        };\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.unstable_batchedUpdates)(()=>{\n            setOver(over);\n            onDragOver == null ? void 0 : onDragOver(event);\n            dispatchMonitorEvent({\n                type: \"onDragOver\",\n                event\n            });\n        });\n    }, [\n        overId\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        sensorContext.current = {\n            activatorEvent,\n            active,\n            activeNode,\n            collisionRect,\n            collisions,\n            droppableRects,\n            draggableNodes,\n            draggingNode,\n            draggingNodeRect,\n            droppableContainers,\n            over,\n            scrollableAncestors,\n            scrollAdjustedTranslate\n        };\n        activeRects.current = {\n            initial: draggingNodeRect,\n            translated: collisionRect\n        };\n    }, [\n        active,\n        activeNode,\n        collisions,\n        collisionRect,\n        draggableNodes,\n        draggingNode,\n        draggingNodeRect,\n        droppableRects,\n        droppableContainers,\n        over,\n        scrollableAncestors,\n        scrollAdjustedTranslate\n    ]);\n    useAutoScroller({\n        ...autoScrollOptions,\n        delta: translate,\n        draggingRect: collisionRect,\n        pointerCoordinates,\n        scrollableAncestors,\n        scrollableAncestorRects\n    });\n    const publicContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            active,\n            activeNode,\n            activeNodeRect,\n            activatorEvent,\n            collisions,\n            containerNodeRect,\n            dragOverlay,\n            draggableNodes,\n            droppableContainers,\n            droppableRects,\n            over,\n            measureDroppableContainers,\n            scrollableAncestors,\n            scrollableAncestorRects,\n            measuringConfiguration,\n            measuringScheduled,\n            windowRect\n        };\n        return context;\n    }, [\n        active,\n        activeNode,\n        activeNodeRect,\n        activatorEvent,\n        collisions,\n        containerNodeRect,\n        dragOverlay,\n        draggableNodes,\n        droppableContainers,\n        droppableRects,\n        over,\n        measureDroppableContainers,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        measuringConfiguration,\n        measuringScheduled,\n        windowRect\n    ]);\n    const internalContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const context = {\n            activatorEvent,\n            activators,\n            active,\n            activeNodeRect,\n            ariaDescribedById: {\n                draggable: draggableDescribedById\n            },\n            dispatch,\n            draggableNodes,\n            over,\n            measureDroppableContainers\n        };\n        return context;\n    }, [\n        activatorEvent,\n        activators,\n        active,\n        activeNodeRect,\n        dispatch,\n        draggableDescribedById,\n        draggableNodes,\n        over,\n        measureDroppableContainers\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(DndMonitorContext.Provider, {\n        value: registerMonitorListener\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: internalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PublicContext.Provider, {\n        value: publicContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: transform\n    }, children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RestoreFocus, {\n        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Accessibility, {\n        ...accessibility,\n        hiddenTextDescribedById: draggableDescribedById\n    }));\n    function getAutoScrollerOptions() {\n        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;\n        const autoScrollGloballyDisabled = typeof autoScroll === \"object\" ? autoScroll.enabled === false : autoScroll === false;\n        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;\n        if (typeof autoScroll === \"object\") {\n            return {\n                ...autoScroll,\n                enabled\n            };\n        }\n        return {\n            enabled\n        };\n    }\n});\nconst NullContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst defaultRole = \"button\";\nconst ID_PREFIX = \"Droppable\";\nfunction useDraggable(_ref) {\n    let { id, data, disabled = false, attributes } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX);\n    const { activators, activatorEvent, active, activeNodeRect, ariaDescribedById, draggableNodes, over } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const { role = defaultRole, roleDescription = \"draggable\", tabIndex = 0 } = attributes != null ? attributes : {};\n    const isDragging = (active == null ? void 0 : active.id) === id;\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(isDragging ? ActiveDraggableContext : NullContext);\n    const [node, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const [activatorNode, setActivatorNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)();\n    const listeners = useSyntheticListeners(activators, id);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        draggableNodes.set(id, {\n            id,\n            key,\n            node,\n            activatorNode,\n            data: dataRef\n        });\n        return ()=>{\n            const node = draggableNodes.get(id);\n            if (node && node.key === key) {\n                draggableNodes.delete(id);\n            }\n        };\n    }, [\n        draggableNodes,\n        id\n    ]);\n    const memoizedAttributes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            role,\n            tabIndex,\n            \"aria-disabled\": disabled,\n            \"aria-pressed\": isDragging && role === defaultRole ? true : undefined,\n            \"aria-roledescription\": roleDescription,\n            \"aria-describedby\": ariaDescribedById.draggable\n        }), [\n        disabled,\n        role,\n        tabIndex,\n        isDragging,\n        roleDescription,\n        ariaDescribedById.draggable\n    ]);\n    return {\n        active,\n        activatorEvent,\n        activeNodeRect,\n        attributes: memoizedAttributes,\n        isDragging,\n        listeners: disabled ? undefined : listeners,\n        node,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        transform\n    };\n}\nfunction useDndContext() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PublicContext);\n}\nconst ID_PREFIX$1 = \"Droppable\";\nconst defaultResizeObserverConfig = {\n    timeout: 25\n};\nfunction useDroppable(_ref) {\n    let { data, disabled = false, id, resizeObserverConfig } = _ref;\n    const key = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX$1);\n    const { active, dispatch, over, measureDroppableContainers } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(InternalContext);\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        disabled\n    });\n    const resizeObserverConnected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const rect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const callbackId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout } = {\n        ...defaultResizeObserverConfig,\n        ...resizeObserverConfig\n    };\n    const ids = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(updateMeasurementsFor != null ? updateMeasurementsFor : id);\n    const handleResize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (!resizeObserverConnected.current) {\n            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,\n            // assuming the element is rendered and displayed.\n            resizeObserverConnected.current = true;\n            return;\n        }\n        if (callbackId.current != null) {\n            clearTimeout(callbackId.current);\n        }\n        callbackId.current = setTimeout(()=>{\n            measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [\n                ids.current\n            ]);\n            callbackId.current = null;\n        }, resizeObserverTimeout);\n    }, [\n        resizeObserverTimeout\n    ]);\n    const resizeObserver = useResizeObserver({\n        callback: handleResize,\n        disabled: resizeObserverDisabled || !active\n    });\n    const handleNodeChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newElement, previousElement)=>{\n        if (!resizeObserver) {\n            return;\n        }\n        if (previousElement) {\n            resizeObserver.unobserve(previousElement);\n            resizeObserverConnected.current = false;\n        }\n        if (newElement) {\n            resizeObserver.observe(newElement);\n        }\n    }, [\n        resizeObserver\n    ]);\n    const [nodeRef, setNodeRef] = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useNodeRef)(handleNodeChange);\n    const dataRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useLatestValue)(data);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (!resizeObserver || !nodeRef.current) {\n            return;\n        }\n        resizeObserver.disconnect();\n        resizeObserverConnected.current = false;\n        resizeObserver.observe(nodeRef.current);\n    }, [\n        nodeRef,\n        resizeObserver\n    ]);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        dispatch({\n            type: Action.RegisterDroppable,\n            element: {\n                id,\n                key,\n                disabled,\n                node: nodeRef,\n                rect,\n                data: dataRef\n            }\n        });\n        return ()=>dispatch({\n                type: Action.UnregisterDroppable,\n                key,\n                id\n            });\n    }, [\n        id\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (disabled !== previous.current.disabled) {\n            dispatch({\n                type: Action.SetDroppableDisabled,\n                id,\n                key,\n                disabled\n            });\n            previous.current.disabled = disabled;\n        }\n    }, [\n        id,\n        key,\n        disabled,\n        dispatch\n    ]);\n    return {\n        active,\n        rect,\n        isOver: (over == null ? void 0 : over.id) === id,\n        node: nodeRef,\n        over,\n        setNodeRef\n    };\n}\nfunction AnimationManager(_ref) {\n    let { animation, children } = _ref;\n    const [clonedChildren, setClonedChildren] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousChildren = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.usePrevious)(children);\n    if (!children && !clonedChildren && previousChildren) {\n        setClonedChildren(previousChildren);\n    }\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!element) {\n            return;\n        }\n        const key = clonedChildren == null ? void 0 : clonedChildren.key;\n        const id = clonedChildren == null ? void 0 : clonedChildren.props.id;\n        if (key == null || id == null) {\n            setClonedChildren(null);\n            return;\n        }\n        Promise.resolve(animation(id, element)).then(()=>{\n            setClonedChildren(null);\n        });\n    }, [\n        animation,\n        clonedChildren,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children, clonedChildren ? /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(clonedChildren, {\n        ref: setElement\n    }) : null);\n}\nconst defaultTransform = {\n    x: 0,\n    y: 0,\n    scaleX: 1,\n    scaleY: 1\n};\nfunction NullifiedContextProvider(_ref) {\n    let { children } = _ref;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(InternalContext.Provider, {\n        value: defaultInternalContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(ActiveDraggableContext.Provider, {\n        value: defaultTransform\n    }, children));\n}\nconst baseStyles = {\n    position: \"fixed\",\n    touchAction: \"none\"\n};\nconst defaultTransition = (activatorEvent)=>{\n    const isKeyboardActivator = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent);\n    return isKeyboardActivator ? \"transform 250ms ease\" : undefined;\n};\nconst PositionedOverlay = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((_ref, ref)=>{\n    let { as, activatorEvent, adjustScale, children, className, rect, style, transform, transition = defaultTransition } = _ref;\n    if (!rect) {\n        return null;\n    }\n    const scaleAdjustedTransform = adjustScale ? transform : {\n        ...transform,\n        scaleX: 1,\n        scaleY: 1\n    };\n    const styles = {\n        ...baseStyles,\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        left: rect.left,\n        transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(scaleAdjustedTransform),\n        transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,\n        transition: typeof transition === \"function\" ? transition(activatorEvent) : transition,\n        ...style\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(as, {\n        className,\n        style: styles,\n        ref\n    }, children);\n});\nconst defaultDropAnimationSideEffects = (options)=>(_ref)=>{\n        let { active, dragOverlay } = _ref;\n        const originalStyles = {};\n        const { styles, className } = options;\n        if (styles != null && styles.active) {\n            for (const [key, value] of Object.entries(styles.active)){\n                if (value === undefined) {\n                    continue;\n                }\n                originalStyles[key] = active.node.style.getPropertyValue(key);\n                active.node.style.setProperty(key, value);\n            }\n        }\n        if (styles != null && styles.dragOverlay) {\n            for (const [key, value] of Object.entries(styles.dragOverlay)){\n                if (value === undefined) {\n                    continue;\n                }\n                dragOverlay.node.style.setProperty(key, value);\n            }\n        }\n        if (className != null && className.active) {\n            active.node.classList.add(className.active);\n        }\n        if (className != null && className.dragOverlay) {\n            dragOverlay.node.classList.add(className.dragOverlay);\n        }\n        return function cleanup() {\n            for (const [key, value] of Object.entries(originalStyles)){\n                active.node.style.setProperty(key, value);\n            }\n            if (className != null && className.active) {\n                active.node.classList.remove(className.active);\n            }\n        };\n    };\nconst defaultKeyframeResolver = (_ref2)=>{\n    let { transform: { initial, final } } = _ref2;\n    return [\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(initial)\n        },\n        {\n            transform: _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transform.toString(final)\n        }\n    ];\n};\nconst defaultDropAnimationConfiguration = {\n    duration: 250,\n    easing: \"ease\",\n    keyframes: defaultKeyframeResolver,\n    sideEffects: /*#__PURE__*/ defaultDropAnimationSideEffects({\n        styles: {\n            active: {\n                opacity: \"0\"\n            }\n        }\n    })\n};\nfunction useDropAnimation(_ref3) {\n    let { config, draggableNodes, droppableContainers, measuringConfiguration } = _ref3;\n    return (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useEvent)((id, node)=>{\n        if (config === null) {\n            return;\n        }\n        const activeDraggable = draggableNodes.get(id);\n        if (!activeDraggable) {\n            return;\n        }\n        const activeNode = activeDraggable.node.current;\n        if (!activeNode) {\n            return;\n        }\n        const measurableNode = getMeasurableNode(node);\n        if (!measurableNode) {\n            return;\n        }\n        const { transform } = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.getWindow)(node).getComputedStyle(node);\n        const parsedTransform = parseTransform(transform);\n        if (!parsedTransform) {\n            return;\n        }\n        const animation = typeof config === \"function\" ? config : createDefaultDropAnimation(config);\n        scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);\n        return animation({\n            active: {\n                id,\n                data: activeDraggable.data,\n                node: activeNode,\n                rect: measuringConfiguration.draggable.measure(activeNode)\n            },\n            draggableNodes,\n            dragOverlay: {\n                node,\n                rect: measuringConfiguration.dragOverlay.measure(measurableNode)\n            },\n            droppableContainers,\n            measuringConfiguration,\n            transform: parsedTransform\n        });\n    });\n}\nfunction createDefaultDropAnimation(options) {\n    const { duration, easing, sideEffects, keyframes } = {\n        ...defaultDropAnimationConfiguration,\n        ...options\n    };\n    return (_ref4)=>{\n        let { active, dragOverlay, transform, ...rest } = _ref4;\n        if (!duration) {\n            // Do not animate if animation duration is zero.\n            return;\n        }\n        const delta = {\n            x: dragOverlay.rect.left - active.rect.left,\n            y: dragOverlay.rect.top - active.rect.top\n        };\n        const scale = {\n            scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,\n            scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1\n        };\n        const finalTransform = {\n            x: transform.x - delta.x,\n            y: transform.y - delta.y,\n            ...scale\n        };\n        const animationKeyframes = keyframes({\n            ...rest,\n            active,\n            dragOverlay,\n            transform: {\n                initial: transform,\n                final: finalTransform\n            }\n        });\n        const [firstKeyframe] = animationKeyframes;\n        const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];\n        if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {\n            // The start and end keyframes are the same, infer that there is no animation needed.\n            return;\n        }\n        const cleanup = sideEffects == null ? void 0 : sideEffects({\n            active,\n            dragOverlay,\n            ...rest\n        });\n        const animation = dragOverlay.node.animate(animationKeyframes, {\n            duration,\n            easing,\n            fill: \"forwards\"\n        });\n        return new Promise((resolve)=>{\n            animation.onfinish = ()=>{\n                cleanup == null ? void 0 : cleanup();\n                resolve();\n            };\n        });\n    };\n}\nlet key = 0;\nfunction useKey(id) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (id == null) {\n            return;\n        }\n        key++;\n        return key;\n    }, [\n        id\n    ]);\n}\nconst DragOverlay = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().memo((_ref)=>{\n    let { adjustScale = false, children, dropAnimation: dropAnimationConfig, style, transition, modifiers, wrapperElement = \"div\", className, zIndex = 999 } = _ref;\n    const { activatorEvent, active, activeNodeRect, containerNodeRect, draggableNodes, droppableContainers, dragOverlay, over, measuringConfiguration, scrollableAncestors, scrollableAncestorRects, windowRect } = useDndContext();\n    const transform = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ActiveDraggableContext);\n    const key = useKey(active == null ? void 0 : active.id);\n    const modifiedTransform = applyModifiers(modifiers, {\n        activatorEvent,\n        active,\n        activeNodeRect,\n        containerNodeRect,\n        draggingNodeRect: dragOverlay.rect,\n        over,\n        overlayNodeRect: dragOverlay.rect,\n        scrollableAncestors,\n        scrollableAncestorRects,\n        transform,\n        windowRect\n    });\n    const initialRect = useInitialValue(activeNodeRect);\n    const dropAnimation = useDropAnimation({\n        config: dropAnimationConfig,\n        draggableNodes,\n        droppableContainers,\n        measuringConfiguration\n    }); // We need to wait for the active node to be measured before connecting the drag overlay ref\n    // otherwise collisions can be computed against a mispositioned drag overlay\n    const ref = initialRect ? dragOverlay.setRef : undefined;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(NullifiedContextProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AnimationManager, {\n        animation: dropAnimation\n    }, active && key ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(PositionedOverlay, {\n        key: key,\n        id: active.id,\n        ref: ref,\n        as: wrapperElement,\n        activatorEvent: activatorEvent,\n        adjustScale: adjustScale,\n        className: className,\n        transition: transition,\n        rect: initialRect,\n        style: {\n            zIndex,\n            ...style\n        },\n        transform: modifiedTransform\n    }, children) : null));\n});\n //# sourceMappingURL=core.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvY29yZS9kaXN0L2NvcmUuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3SjtBQUN0RjtBQUM0UTtBQUM3UDtBQUVqRixNQUFNdUMsb0JBQW9CLFdBQVcsR0FBRXRDLG9EQUFhQSxDQUFDO0FBRXJELFNBQVN1QyxjQUFjQyxRQUFRO0lBQzdCLE1BQU1DLG1CQUFtQnhDLGlEQUFVQSxDQUFDcUM7SUFDcENwQyxnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ3VDLGtCQUFrQjtZQUNyQixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxNQUFNQyxjQUFjRixpQkFBaUJEO1FBQ3JDLE9BQU9HO0lBQ1QsR0FBRztRQUFDSDtRQUFVQztLQUFpQjtBQUNqQztBQUVBLFNBQVNHO0lBQ1AsTUFBTSxDQUFDQyxVQUFVLEdBQUcxQywrQ0FBUUEsQ0FBQyxJQUFNLElBQUkyQztJQUN2QyxNQUFNTCxtQkFBbUJyQyxrREFBV0EsQ0FBQ29DLENBQUFBO1FBQ25DSyxVQUFVdEIsR0FBRyxDQUFDaUI7UUFDZCxPQUFPLElBQU1LLFVBQVVFLE1BQU0sQ0FBQ1A7SUFDaEMsR0FBRztRQUFDSztLQUFVO0lBQ2QsTUFBTUcsV0FBVzVDLGtEQUFXQSxDQUFDNkMsQ0FBQUE7UUFDM0IsSUFBSSxFQUNGQyxJQUFJLEVBQ0pDLEtBQUssRUFDTixHQUFHRjtRQUNKSixVQUFVTyxPQUFPLENBQUNaLENBQUFBO1lBQ2hCLElBQUlhO1lBRUosT0FBTyxDQUFDQSxpQkFBaUJiLFFBQVEsQ0FBQ1UsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJRyxlQUFlQyxJQUFJLENBQUNkLFVBQVVXO1FBQzVGO0lBQ0YsR0FBRztRQUFDTjtLQUFVO0lBQ2QsT0FBTztRQUFDRztRQUFVUDtLQUFpQjtBQUNyQztBQUVBLE1BQU1jLGtDQUFrQztJQUN0Q0MsV0FBVztBQUNiO0FBQ0EsTUFBTUMsdUJBQXVCO0lBQzNCQyxhQUFZVCxJQUFJO1FBQ2QsSUFBSSxFQUNGVSxNQUFNLEVBQ1AsR0FBR1Y7UUFDSixPQUFPLDhCQUE4QlUsT0FBT0MsRUFBRSxHQUFHO0lBQ25EO0lBRUFDLFlBQVdDLEtBQUs7UUFDZCxJQUFJLEVBQ0ZILE1BQU0sRUFDTkksSUFBSSxFQUNMLEdBQUdEO1FBRUosSUFBSUMsTUFBTTtZQUNSLE9BQU8sb0JBQW9CSixPQUFPQyxFQUFFLEdBQUcsb0NBQW9DRyxLQUFLSCxFQUFFLEdBQUc7UUFDdkY7UUFFQSxPQUFPLG9CQUFvQkQsT0FBT0MsRUFBRSxHQUFHO0lBQ3pDO0lBRUFJLFdBQVVDLEtBQUs7UUFDYixJQUFJLEVBQ0ZOLE1BQU0sRUFDTkksSUFBSSxFQUNMLEdBQUdFO1FBRUosSUFBSUYsTUFBTTtZQUNSLE9BQU8sb0JBQW9CSixPQUFPQyxFQUFFLEdBQUcsc0NBQXNDRyxLQUFLSCxFQUFFO1FBQ3RGO1FBRUEsT0FBTyxvQkFBb0JELE9BQU9DLEVBQUUsR0FBRztJQUN6QztJQUVBTSxjQUFhQyxLQUFLO1FBQ2hCLElBQUksRUFDRlIsTUFBTSxFQUNQLEdBQUdRO1FBQ0osT0FBTyw0Q0FBNENSLE9BQU9DLEVBQUUsR0FBRztJQUNqRTtBQUVGO0FBRUEsU0FBU1EsY0FBY25CLElBQUk7SUFDekIsSUFBSSxFQUNGb0IsZ0JBQWdCWixvQkFBb0IsRUFDcENhLFNBQVMsRUFDVEMsdUJBQXVCLEVBQ3ZCQywyQkFBMkJqQiwrQkFBK0IsRUFDM0QsR0FBR047SUFDSixNQUFNLEVBQ0p3QixRQUFRLEVBQ1JDLFlBQVksRUFDYixHQUFHdkMsdUVBQWVBO0lBQ25CLE1BQU13QyxlQUFlOUQsK0RBQVdBLENBQUM7SUFDakMsTUFBTSxDQUFDK0QsU0FBU0MsV0FBVyxHQUFHMUUsK0NBQVFBLENBQUM7SUFDdkNELGdEQUFTQSxDQUFDO1FBQ1IyRSxXQUFXO0lBQ2IsR0FBRyxFQUFFO0lBQ0x0QyxjQUFjbEMsOENBQU9BLENBQUMsSUFBTztZQUMzQnFELGFBQVlJLEtBQUs7Z0JBQ2YsSUFBSSxFQUNGSCxNQUFNLEVBQ1AsR0FBR0c7Z0JBQ0pXLFNBQVNKLGNBQWNYLFdBQVcsQ0FBQztvQkFDakNDO2dCQUNGO1lBQ0Y7WUFFQW1CLFlBQVdiLEtBQUs7Z0JBQ2QsSUFBSSxFQUNGTixNQUFNLEVBQ05JLElBQUksRUFDTCxHQUFHRTtnQkFFSixJQUFJSSxjQUFjUyxVQUFVLEVBQUU7b0JBQzVCTCxTQUFTSixjQUFjUyxVQUFVLENBQUM7d0JBQ2hDbkI7d0JBQ0FJO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQUYsWUFBV00sS0FBSztnQkFDZCxJQUFJLEVBQ0ZSLE1BQU0sRUFDTkksSUFBSSxFQUNMLEdBQUdJO2dCQUNKTSxTQUFTSixjQUFjUixVQUFVLENBQUM7b0JBQ2hDRjtvQkFDQUk7Z0JBQ0Y7WUFDRjtZQUVBQyxXQUFVZSxLQUFLO2dCQUNiLElBQUksRUFDRnBCLE1BQU0sRUFDTkksSUFBSSxFQUNMLEdBQUdnQjtnQkFDSk4sU0FBU0osY0FBY0wsU0FBUyxDQUFDO29CQUMvQkw7b0JBQ0FJO2dCQUNGO1lBQ0Y7WUFFQUcsY0FBYWMsS0FBSztnQkFDaEIsSUFBSSxFQUNGckIsTUFBTSxFQUNOSSxJQUFJLEVBQ0wsR0FBR2lCO2dCQUNKUCxTQUFTSixjQUFjSCxZQUFZLENBQUM7b0JBQ2xDUDtvQkFDQUk7Z0JBQ0Y7WUFDRjtRQUVGLElBQUk7UUFBQ1U7UUFBVUo7S0FBYztJQUU3QixJQUFJLENBQUNPLFNBQVM7UUFDWixPQUFPO0lBQ1Q7SUFFQSxNQUFNSyx1QkFBU2xGLDBEQUFtQixDQUFDQSx1REFBYyxFQUFFLG9CQUFNQSwwREFBbUIsQ0FBQ3FDLDhEQUFVQSxFQUFFO1FBQ3ZGd0IsSUFBSVc7UUFDSmEsT0FBT1oseUJBQXlCaEIsU0FBUztJQUMzQyxrQkFBSXpELDBEQUFtQixDQUFDc0MsOERBQVVBLEVBQUU7UUFDbEN1QixJQUFJZTtRQUNKRCxjQUFjQTtJQUNoQjtJQUNBLE9BQU9KLDBCQUFZM0QsdURBQVlBLENBQUNzRSxRQUFRWCxhQUFhVztBQUN2RDtBQUVBLElBQUlJO0FBRUgsVUFBVUEsTUFBTTtJQUNmQSxNQUFNLENBQUMsWUFBWSxHQUFHO0lBQ3RCQSxNQUFNLENBQUMsV0FBVyxHQUFHO0lBQ3JCQSxNQUFNLENBQUMsVUFBVSxHQUFHO0lBQ3BCQSxNQUFNLENBQUMsYUFBYSxHQUFHO0lBQ3ZCQSxNQUFNLENBQUMsV0FBVyxHQUFHO0lBQ3JCQSxNQUFNLENBQUMsb0JBQW9CLEdBQUc7SUFDOUJBLE1BQU0sQ0FBQyx1QkFBdUIsR0FBRztJQUNqQ0EsTUFBTSxDQUFDLHNCQUFzQixHQUFHO0FBQ2xDLEdBQUdBLFVBQVdBLENBQUFBLFNBQVMsQ0FBQztBQUV4QixTQUFTQyxRQUFRO0FBRWpCLFNBQVNDLFVBQVVDLE1BQU0sRUFBRUMsT0FBTztJQUNoQyxPQUFPcEYsOENBQU9BLENBQUMsSUFBTztZQUNwQm1GO1lBQ0FDLFNBQVNBLFdBQVcsT0FBT0EsVUFBVSxDQUFDO1FBQ3hDLElBQ0E7UUFBQ0Q7UUFBUUM7S0FBUTtBQUNuQjtBQUVBLFNBQVNDO0lBQ1AsSUFBSyxJQUFJQyxPQUFPQyxVQUFVQyxNQUFNLEVBQUVDLFVBQVUsSUFBSUMsTUFBTUosT0FBT0ssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO1FBQzFGRixPQUFPLENBQUNFLEtBQUssR0FBR0osU0FBUyxDQUFDSSxLQUFLO0lBQ2pDO0lBRUEsT0FBTzNGLDhDQUFPQSxDQUFDLElBQU07ZUFBSXlGO1NBQVEsQ0FBQ0csTUFBTSxDQUFDVCxDQUFBQSxTQUFVQSxVQUFVLE9BQzdEO1dBQUlNO0tBQVE7QUFDZDtBQUVBLE1BQU1JLHFCQUFxQixXQUFXLEdBQUVDLE9BQU9DLE1BQU0sQ0FBQztJQUNwREMsR0FBRztJQUNIQyxHQUFHO0FBQ0w7QUFFQTs7Q0FFQyxHQUNELFNBQVNDLGdCQUFnQkMsRUFBRSxFQUFFQyxFQUFFO0lBQzdCLE9BQU9DLEtBQUtDLElBQUksQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDSixHQUFHSCxDQUFDLEdBQUdJLEdBQUdKLENBQUMsRUFBRSxLQUFLSyxLQUFLRSxHQUFHLENBQUNKLEdBQUdGLENBQUMsR0FBR0csR0FBR0gsQ0FBQyxFQUFFO0FBQ3BFO0FBRUEsU0FBU08sMkJBQTJCMUQsS0FBSyxFQUFFMkQsSUFBSTtJQUM3QyxNQUFNQyxtQkFBbUJqRyx1RUFBbUJBLENBQUNxQztJQUU3QyxJQUFJLENBQUM0RCxrQkFBa0I7UUFDckIsT0FBTztJQUNUO0lBRUEsTUFBTUMsa0JBQWtCO1FBQ3RCWCxHQUFHLENBQUNVLGlCQUFpQlYsQ0FBQyxHQUFHUyxLQUFLRyxJQUFJLElBQUlILEtBQUtJLEtBQUssR0FBRztRQUNuRFosR0FBRyxDQUFDUyxpQkFBaUJULENBQUMsR0FBR1EsS0FBS0ssR0FBRyxJQUFJTCxLQUFLTSxNQUFNLEdBQUc7SUFDckQ7SUFDQSxPQUFPSixnQkFBZ0JYLENBQUMsR0FBRyxPQUFPVyxnQkFBZ0JWLENBQUMsR0FBRztBQUN4RDtBQUVBOztDQUVDLEdBQ0QsU0FBU2Usa0JBQWtCcEUsSUFBSSxFQUFFYSxLQUFLO0lBQ3BDLElBQUksRUFDRndELE1BQU0sRUFDSmxDLE9BQU9tQyxDQUFDLEVBQ1QsRUFDRixHQUFHdEU7SUFDSixJQUFJLEVBQ0ZxRSxNQUFNLEVBQ0psQyxPQUFPb0MsQ0FBQyxFQUNULEVBQ0YsR0FBRzFEO0lBQ0osT0FBT3lELElBQUlDO0FBQ2I7QUFDQTs7Q0FFQyxHQUVELFNBQVNDLG1CQUFtQnhELEtBQUssRUFBRUUsS0FBSztJQUN0QyxJQUFJLEVBQ0ZtRCxNQUFNLEVBQ0psQyxPQUFPbUMsQ0FBQyxFQUNULEVBQ0YsR0FBR3REO0lBQ0osSUFBSSxFQUNGcUQsTUFBTSxFQUNKbEMsT0FBT29DLENBQUMsRUFDVCxFQUNGLEdBQUdyRDtJQUNKLE9BQU9xRCxJQUFJRDtBQUNiO0FBQ0E7OztDQUdDLEdBRUQsU0FBU0csbUJBQW1CM0MsS0FBSztJQUMvQixJQUFJLEVBQ0ZrQyxJQUFJLEVBQ0pFLEdBQUcsRUFDSEMsTUFBTSxFQUNORixLQUFLLEVBQ04sR0FBR25DO0lBQ0osT0FBTztRQUFDO1lBQ05zQixHQUFHWTtZQUNIWCxHQUFHYTtRQUNMO1FBQUc7WUFDRGQsR0FBR1ksT0FBT0M7WUFDVlosR0FBR2E7UUFDTDtRQUFHO1lBQ0RkLEdBQUdZO1lBQ0hYLEdBQUdhLE1BQU1DO1FBQ1g7UUFBRztZQUNEZixHQUFHWSxPQUFPQztZQUNWWixHQUFHYSxNQUFNQztRQUNYO0tBQUU7QUFDSjtBQUNBLFNBQVNPLGtCQUFrQkMsVUFBVSxFQUFFQyxRQUFRO0lBQzdDLElBQUksQ0FBQ0QsY0FBY0EsV0FBVy9CLE1BQU0sS0FBSyxHQUFHO1FBQzFDLE9BQU87SUFDVDtJQUVBLE1BQU0sQ0FBQ2lDLGVBQWUsR0FBR0Y7SUFDekIsT0FBT0MsV0FBV0MsY0FBYyxDQUFDRCxTQUFTLEdBQUdDO0FBQy9DO0FBRUE7O0NBRUMsR0FFRCxTQUFTQyxrQkFBa0JqQixJQUFJLEVBQUVHLElBQUksRUFBRUUsR0FBRztJQUN4QyxJQUFJRixTQUFTLEtBQUssR0FBRztRQUNuQkEsT0FBT0gsS0FBS0csSUFBSTtJQUNsQjtJQUVBLElBQUlFLFFBQVEsS0FBSyxHQUFHO1FBQ2xCQSxNQUFNTCxLQUFLSyxHQUFHO0lBQ2hCO0lBRUEsT0FBTztRQUNMZCxHQUFHWSxPQUFPSCxLQUFLSSxLQUFLLEdBQUc7UUFDdkJaLEdBQUdhLE1BQU1MLEtBQUtNLE1BQU0sR0FBRztJQUN6QjtBQUNGO0FBQ0E7OztDQUdDLEdBR0QsTUFBTVksZ0JBQWdCL0UsQ0FBQUE7SUFDcEIsSUFBSSxFQUNGZ0YsYUFBYSxFQUNiQyxjQUFjLEVBQ2RDLG1CQUFtQixFQUNwQixHQUFHbEY7SUFDSixNQUFNbUYsYUFBYUwsa0JBQWtCRSxlQUFlQSxjQUFjaEIsSUFBSSxFQUFFZ0IsY0FBY2QsR0FBRztJQUN6RixNQUFNUyxhQUFhLEVBQUU7SUFFckIsS0FBSyxNQUFNUyxzQkFBc0JGLG9CQUFxQjtRQUNwRCxNQUFNLEVBQ0p2RSxFQUFFLEVBQ0gsR0FBR3lFO1FBQ0osTUFBTXZCLE9BQU9vQixlQUFlSSxHQUFHLENBQUMxRTtRQUVoQyxJQUFJa0QsTUFBTTtZQUNSLE1BQU15QixjQUFjaEMsZ0JBQWdCd0Isa0JBQWtCakIsT0FBT3NCO1lBQzdEUixXQUFXWSxJQUFJLENBQUM7Z0JBQ2Q1RTtnQkFDQTBELE1BQU07b0JBQ0plO29CQUNBakQsT0FBT21EO2dCQUNUO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT1gsV0FBV2EsSUFBSSxDQUFDcEI7QUFDekI7QUFFQTs7O0NBR0MsR0FFRCxNQUFNcUIsaUJBQWlCekYsQ0FBQUE7SUFDckIsSUFBSSxFQUNGZ0YsYUFBYSxFQUNiQyxjQUFjLEVBQ2RDLG1CQUFtQixFQUNwQixHQUFHbEY7SUFDSixNQUFNMEYsVUFBVWpCLG1CQUFtQk87SUFDbkMsTUFBTUwsYUFBYSxFQUFFO0lBRXJCLEtBQUssTUFBTVMsc0JBQXNCRixvQkFBcUI7UUFDcEQsTUFBTSxFQUNKdkUsRUFBRSxFQUNILEdBQUd5RTtRQUNKLE1BQU12QixPQUFPb0IsZUFBZUksR0FBRyxDQUFDMUU7UUFFaEMsSUFBSWtELE1BQU07WUFDUixNQUFNOEIsY0FBY2xCLG1CQUFtQlo7WUFDdkMsTUFBTStCLFlBQVlGLFFBQVFHLE1BQU0sQ0FBQyxDQUFDQyxhQUFhQyxRQUFRQztnQkFDckQsT0FBT0YsY0FBY3hDLGdCQUFnQnFDLFdBQVcsQ0FBQ0ssTUFBTSxFQUFFRDtZQUMzRCxHQUFHO1lBQ0gsTUFBTUUsb0JBQW9CQyxPQUFPLENBQUNOLFlBQVksR0FBR08sT0FBTyxDQUFDO1lBQ3pEeEIsV0FBV1ksSUFBSSxDQUFDO2dCQUNkNUU7Z0JBQ0EwRCxNQUFNO29CQUNKZTtvQkFDQWpELE9BQU84RDtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU90QixXQUFXYSxJQUFJLENBQUNwQjtBQUN6QjtBQUVBOztDQUVDLEdBRUQsU0FBU2dDLHFCQUFxQkMsS0FBSyxFQUFFQyxNQUFNO0lBQ3pDLE1BQU1wQyxNQUFNVCxLQUFLOEMsR0FBRyxDQUFDRCxPQUFPcEMsR0FBRyxFQUFFbUMsTUFBTW5DLEdBQUc7SUFDMUMsTUFBTUYsT0FBT1AsS0FBSzhDLEdBQUcsQ0FBQ0QsT0FBT3RDLElBQUksRUFBRXFDLE1BQU1yQyxJQUFJO0lBQzdDLE1BQU13QyxRQUFRL0MsS0FBS2dELEdBQUcsQ0FBQ0gsT0FBT3RDLElBQUksR0FBR3NDLE9BQU9yQyxLQUFLLEVBQUVvQyxNQUFNckMsSUFBSSxHQUFHcUMsTUFBTXBDLEtBQUs7SUFDM0UsTUFBTXlDLFNBQVNqRCxLQUFLZ0QsR0FBRyxDQUFDSCxPQUFPcEMsR0FBRyxHQUFHb0MsT0FBT25DLE1BQU0sRUFBRWtDLE1BQU1uQyxHQUFHLEdBQUdtQyxNQUFNbEMsTUFBTTtJQUM1RSxNQUFNRixRQUFRdUMsUUFBUXhDO0lBQ3RCLE1BQU1HLFNBQVN1QyxTQUFTeEM7SUFFeEIsSUFBSUYsT0FBT3dDLFNBQVN0QyxNQUFNd0MsUUFBUTtRQUNoQyxNQUFNQyxhQUFhTCxPQUFPckMsS0FBSyxHQUFHcUMsT0FBT25DLE1BQU07UUFDL0MsTUFBTXlDLFlBQVlQLE1BQU1wQyxLQUFLLEdBQUdvQyxNQUFNbEMsTUFBTTtRQUM1QyxNQUFNMEMsbUJBQW1CNUMsUUFBUUU7UUFDakMsTUFBTTJDLG9CQUFvQkQsbUJBQW9CRixDQUFBQSxhQUFhQyxZQUFZQyxnQkFBZTtRQUN0RixPQUFPWCxPQUFPWSxrQkFBa0JYLE9BQU8sQ0FBQztJQUMxQyxFQUFFLGtGQUFrRjtJQUdwRixPQUFPO0FBQ1Q7QUFDQTs7O0NBR0MsR0FFRCxNQUFNWSxtQkFBbUIvRyxDQUFBQTtJQUN2QixJQUFJLEVBQ0ZnRixhQUFhLEVBQ2JDLGNBQWMsRUFDZEMsbUJBQW1CLEVBQ3BCLEdBQUdsRjtJQUNKLE1BQU0yRSxhQUFhLEVBQUU7SUFFckIsS0FBSyxNQUFNUyxzQkFBc0JGLG9CQUFxQjtRQUNwRCxNQUFNLEVBQ0p2RSxFQUFFLEVBQ0gsR0FBR3lFO1FBQ0osTUFBTXZCLE9BQU9vQixlQUFlSSxHQUFHLENBQUMxRTtRQUVoQyxJQUFJa0QsTUFBTTtZQUNSLE1BQU1pRCxvQkFBb0JWLHFCQUFxQnZDLE1BQU1tQjtZQUVyRCxJQUFJOEIsb0JBQW9CLEdBQUc7Z0JBQ3pCbkMsV0FBV1ksSUFBSSxDQUFDO29CQUNkNUU7b0JBQ0EwRCxNQUFNO3dCQUNKZTt3QkFDQWpELE9BQU8yRTtvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU9uQyxXQUFXYSxJQUFJLENBQUNoQjtBQUN6QjtBQUVBOztDQUVDLEdBRUQsU0FBU3dDLGtCQUFrQkMsS0FBSyxFQUFFcEQsSUFBSTtJQUNwQyxNQUFNLEVBQ0pLLEdBQUcsRUFDSEYsSUFBSSxFQUNKMEMsTUFBTSxFQUNORixLQUFLLEVBQ04sR0FBRzNDO0lBQ0osT0FBT0ssT0FBTytDLE1BQU01RCxDQUFDLElBQUk0RCxNQUFNNUQsQ0FBQyxJQUFJcUQsVUFBVTFDLFFBQVFpRCxNQUFNN0QsQ0FBQyxJQUFJNkQsTUFBTTdELENBQUMsSUFBSW9EO0FBQzlFO0FBQ0E7O0NBRUMsR0FHRCxNQUFNVSxnQkFBZ0JsSCxDQUFBQTtJQUNwQixJQUFJLEVBQ0ZrRixtQkFBbUIsRUFDbkJELGNBQWMsRUFDZGtDLGtCQUFrQixFQUNuQixHQUFHbkg7SUFFSixJQUFJLENBQUNtSCxvQkFBb0I7UUFDdkIsT0FBTyxFQUFFO0lBQ1g7SUFFQSxNQUFNeEMsYUFBYSxFQUFFO0lBRXJCLEtBQUssTUFBTVMsc0JBQXNCRixvQkFBcUI7UUFDcEQsTUFBTSxFQUNKdkUsRUFBRSxFQUNILEdBQUd5RTtRQUNKLE1BQU12QixPQUFPb0IsZUFBZUksR0FBRyxDQUFDMUU7UUFFaEMsSUFBSWtELFFBQVFtRCxrQkFBa0JHLG9CQUFvQnRELE9BQU87WUFDdkQ7Ozs7T0FJQyxHQUNELE1BQU02QixVQUFVakIsbUJBQW1CWjtZQUNuQyxNQUFNK0IsWUFBWUYsUUFBUUcsTUFBTSxDQUFDLENBQUNDLGFBQWFDO2dCQUM3QyxPQUFPRCxjQUFjeEMsZ0JBQWdCNkQsb0JBQW9CcEI7WUFDM0QsR0FBRztZQUNILE1BQU1FLG9CQUFvQkMsT0FBTyxDQUFDTixZQUFZLEdBQUdPLE9BQU8sQ0FBQztZQUN6RHhCLFdBQVdZLElBQUksQ0FBQztnQkFDZDVFO2dCQUNBMEQsTUFBTTtvQkFDSmU7b0JBQ0FqRCxPQUFPOEQ7Z0JBQ1Q7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPdEIsV0FBV2EsSUFBSSxDQUFDcEI7QUFDekI7QUFFQSxTQUFTZ0QsWUFBWUMsU0FBUyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDMUMsT0FBTztRQUFFLEdBQUdGLFNBQVM7UUFDbkJHLFFBQVFGLFNBQVNDLFFBQVFELE1BQU1yRCxLQUFLLEdBQUdzRCxNQUFNdEQsS0FBSyxHQUFHO1FBQ3JEd0QsUUFBUUgsU0FBU0MsUUFBUUQsTUFBTW5ELE1BQU0sR0FBR29ELE1BQU1wRCxNQUFNLEdBQUc7SUFDekQ7QUFDRjtBQUVBLFNBQVN1RCxhQUFhSixLQUFLLEVBQUVDLEtBQUs7SUFDaEMsT0FBT0QsU0FBU0MsUUFBUTtRQUN0Qm5FLEdBQUdrRSxNQUFNdEQsSUFBSSxHQUFHdUQsTUFBTXZELElBQUk7UUFDMUJYLEdBQUdpRSxNQUFNcEQsR0FBRyxHQUFHcUQsTUFBTXJELEdBQUc7SUFDMUIsSUFBSWpCO0FBQ047QUFFQSxTQUFTMEUsdUJBQXVCQyxRQUFRO0lBQ3RDLE9BQU8sU0FBU0MsaUJBQWlCaEUsSUFBSTtRQUNuQyxJQUFLLElBQUluQixPQUFPQyxVQUFVQyxNQUFNLEVBQUVrRixjQUFjLElBQUloRixNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7WUFDakgrRSxXQUFXLENBQUMvRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO1FBQ3pDO1FBRUEsT0FBTytFLFlBQVlqQyxNQUFNLENBQUMsQ0FBQ2tDLEtBQUtDLGFBQWdCO2dCQUFFLEdBQUdELEdBQUc7Z0JBQ3REN0QsS0FBSzZELElBQUk3RCxHQUFHLEdBQUcwRCxXQUFXSSxXQUFXM0UsQ0FBQztnQkFDdENxRCxRQUFRcUIsSUFBSXJCLE1BQU0sR0FBR2tCLFdBQVdJLFdBQVczRSxDQUFDO2dCQUM1Q1csTUFBTStELElBQUkvRCxJQUFJLEdBQUc0RCxXQUFXSSxXQUFXNUUsQ0FBQztnQkFDeENvRCxPQUFPdUIsSUFBSXZCLEtBQUssR0FBR29CLFdBQVdJLFdBQVc1RSxDQUFDO1lBQzVDLElBQUk7WUFBRSxHQUFHUyxJQUFJO1FBQ2I7SUFDRjtBQUNGO0FBQ0EsTUFBTW9FLGtCQUFrQixXQUFXLEdBQUVOLHVCQUF1QjtBQUU1RCxTQUFTTyxlQUFlYixTQUFTO0lBQy9CLElBQUlBLFVBQVVjLFVBQVUsQ0FBQyxjQUFjO1FBQ3JDLE1BQU1DLGlCQUFpQmYsVUFBVWdCLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR0MsS0FBSyxDQUFDO1FBQ3BELE9BQU87WUFDTGxGLEdBQUcsQ0FBQ2dGLGNBQWMsQ0FBQyxHQUFHO1lBQ3RCL0UsR0FBRyxDQUFDK0UsY0FBYyxDQUFDLEdBQUc7WUFDdEJaLFFBQVEsQ0FBQ1ksY0FBYyxDQUFDLEVBQUU7WUFDMUJYLFFBQVEsQ0FBQ1csY0FBYyxDQUFDLEVBQUU7UUFDNUI7SUFDRixPQUFPLElBQUlmLFVBQVVjLFVBQVUsQ0FBQyxZQUFZO1FBQzFDLE1BQU1DLGlCQUFpQmYsVUFBVWdCLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR0MsS0FBSyxDQUFDO1FBQ3BELE9BQU87WUFDTGxGLEdBQUcsQ0FBQ2dGLGNBQWMsQ0FBQyxFQUFFO1lBQ3JCL0UsR0FBRyxDQUFDK0UsY0FBYyxDQUFDLEVBQUU7WUFDckJaLFFBQVEsQ0FBQ1ksY0FBYyxDQUFDLEVBQUU7WUFDMUJYLFFBQVEsQ0FBQ1csY0FBYyxDQUFDLEVBQUU7UUFDNUI7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVNHLGlCQUFpQjFFLElBQUksRUFBRXdELFNBQVMsRUFBRXRELGVBQWU7SUFDeEQsTUFBTXlFLGtCQUFrQk4sZUFBZWI7SUFFdkMsSUFBSSxDQUFDbUIsaUJBQWlCO1FBQ3BCLE9BQU8zRTtJQUNUO0lBRUEsTUFBTSxFQUNKMkQsTUFBTSxFQUNOQyxNQUFNLEVBQ05yRSxHQUFHcUYsVUFBVSxFQUNicEYsR0FBR3FGLFVBQVUsRUFDZCxHQUFHRjtJQUNKLE1BQU1wRixJQUFJUyxLQUFLRyxJQUFJLEdBQUd5RSxhQUFhLENBQUMsSUFBSWpCLE1BQUssSUFBS21CLFdBQVc1RTtJQUM3RCxNQUFNVixJQUFJUSxLQUFLSyxHQUFHLEdBQUd3RSxhQUFhLENBQUMsSUFBSWpCLE1BQUssSUFBS2tCLFdBQVc1RSxnQkFBZ0JzRSxLQUFLLENBQUN0RSxnQkFBZ0I2RSxPQUFPLENBQUMsT0FBTztJQUNqSCxNQUFNQyxJQUFJckIsU0FBUzNELEtBQUtJLEtBQUssR0FBR3VELFNBQVMzRCxLQUFLSSxLQUFLO0lBQ25ELE1BQU02RSxJQUFJckIsU0FBUzVELEtBQUtNLE1BQU0sR0FBR3NELFNBQVM1RCxLQUFLTSxNQUFNO0lBQ3JELE9BQU87UUFDTEYsT0FBTzRFO1FBQ1AxRSxRQUFRMkU7UUFDUjVFLEtBQUtiO1FBQ0xtRCxPQUFPcEQsSUFBSXlGO1FBQ1huQyxRQUFRckQsSUFBSXlGO1FBQ1o5RSxNQUFNWjtJQUNSO0FBQ0Y7QUFFQSxNQUFNMkYsaUJBQWlCO0lBQ3JCQyxpQkFBaUI7QUFDbkI7QUFDQTs7Q0FFQyxHQUVELFNBQVNDLGNBQWNDLE9BQU8sRUFBRTFHLE9BQU87SUFDckMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVV1RztJQUNaO0lBRUEsSUFBSWxGLE9BQU9xRixRQUFRQyxxQkFBcUI7SUFFeEMsSUFBSTNHLFFBQVF3RyxlQUFlLEVBQUU7UUFDM0IsTUFBTSxFQUNKM0IsU0FBUyxFQUNUdEQsZUFBZSxFQUNoQixHQUFHakcsNkRBQVNBLENBQUNvTCxTQUFTRSxnQkFBZ0IsQ0FBQ0Y7UUFFeEMsSUFBSTdCLFdBQVc7WUFDYnhELE9BQU8wRSxpQkFBaUIxRSxNQUFNd0QsV0FBV3REO1FBQzNDO0lBQ0Y7SUFFQSxNQUFNLEVBQ0pHLEdBQUcsRUFDSEYsSUFBSSxFQUNKQyxLQUFLLEVBQ0xFLE1BQU0sRUFDTnVDLE1BQU0sRUFDTkYsS0FBSyxFQUNOLEdBQUczQztJQUNKLE9BQU87UUFDTEs7UUFDQUY7UUFDQUM7UUFDQUU7UUFDQXVDO1FBQ0FGO0lBQ0Y7QUFDRjtBQUNBOzs7Ozs7O0NBT0MsR0FFRCxTQUFTNkMsK0JBQStCSCxPQUFPO0lBQzdDLE9BQU9ELGNBQWNDLFNBQVM7UUFDNUJGLGlCQUFpQjtJQUNuQjtBQUNGO0FBRUEsU0FBU00sb0JBQW9CSixPQUFPO0lBQ2xDLE1BQU1qRixRQUFRaUYsUUFBUUssVUFBVTtJQUNoQyxNQUFNcEYsU0FBUytFLFFBQVFNLFdBQVc7SUFDbEMsT0FBTztRQUNMdEYsS0FBSztRQUNMRixNQUFNO1FBQ053QyxPQUFPdkM7UUFDUHlDLFFBQVF2QztRQUNSRjtRQUNBRTtJQUNGO0FBQ0Y7QUFFQSxTQUFTc0YsUUFBUUMsSUFBSSxFQUFFQyxhQUFhO0lBQ2xDLElBQUlBLGtCQUFrQixLQUFLLEdBQUc7UUFDNUJBLGdCQUFnQjdMLDZEQUFTQSxDQUFDNEwsTUFBTU4sZ0JBQWdCLENBQUNNO0lBQ25EO0lBRUEsT0FBT0MsY0FBY0MsUUFBUSxLQUFLO0FBQ3BDO0FBRUEsU0FBU0MsYUFBYVgsT0FBTyxFQUFFUyxhQUFhO0lBQzFDLElBQUlBLGtCQUFrQixLQUFLLEdBQUc7UUFDNUJBLGdCQUFnQjdMLDZEQUFTQSxDQUFDb0wsU0FBU0UsZ0JBQWdCLENBQUNGO0lBQ3REO0lBRUEsTUFBTVksZ0JBQWdCO0lBQ3RCLE1BQU1DLGFBQWE7UUFBQztRQUFZO1FBQWE7S0FBWTtJQUN6RCxPQUFPQSxXQUFXQyxJQUFJLENBQUNwRixDQUFBQTtRQUNyQixNQUFNekMsUUFBUXdILGFBQWEsQ0FBQy9FLFNBQVM7UUFDckMsT0FBTyxPQUFPekMsVUFBVSxXQUFXMkgsY0FBY0csSUFBSSxDQUFDOUgsU0FBUztJQUNqRTtBQUNGO0FBRUEsU0FBUytILHVCQUF1QmhCLE9BQU8sRUFBRWlCLEtBQUs7SUFDNUMsTUFBTUMsZ0JBQWdCLEVBQUU7SUFFeEIsU0FBU0Msd0JBQXdCWCxJQUFJO1FBQ25DLElBQUlTLFNBQVMsUUFBUUMsY0FBY3hILE1BQU0sSUFBSXVILE9BQU87WUFDbEQsT0FBT0M7UUFDVDtRQUVBLElBQUksQ0FBQ1YsTUFBTTtZQUNULE9BQU9VO1FBQ1Q7UUFFQSxJQUFJck0sOERBQVVBLENBQUMyTCxTQUFTQSxLQUFLWSxnQkFBZ0IsSUFBSSxRQUFRLENBQUNGLGNBQWNHLFFBQVEsQ0FBQ2IsS0FBS1ksZ0JBQWdCLEdBQUc7WUFDdkdGLGNBQWM3RSxJQUFJLENBQUNtRSxLQUFLWSxnQkFBZ0I7WUFDeEMsT0FBT0Y7UUFDVDtRQUVBLElBQUksQ0FBQ3BNLGlFQUFhQSxDQUFDMEwsU0FBU3pMLGdFQUFZQSxDQUFDeUwsT0FBTztZQUM5QyxPQUFPVTtRQUNUO1FBRUEsSUFBSUEsY0FBY0csUUFBUSxDQUFDYixPQUFPO1lBQ2hDLE9BQU9VO1FBQ1Q7UUFFQSxNQUFNVCxnQkFBZ0I3TCw2REFBU0EsQ0FBQ29MLFNBQVNFLGdCQUFnQixDQUFDTTtRQUUxRCxJQUFJQSxTQUFTUixTQUFTO1lBQ3BCLElBQUlXLGFBQWFILE1BQU1DLGdCQUFnQjtnQkFDckNTLGNBQWM3RSxJQUFJLENBQUNtRTtZQUNyQjtRQUNGO1FBRUEsSUFBSUQsUUFBUUMsTUFBTUMsZ0JBQWdCO1lBQ2hDLE9BQU9TO1FBQ1Q7UUFFQSxPQUFPQyx3QkFBd0JYLEtBQUtjLFVBQVU7SUFDaEQ7SUFFQSxJQUFJLENBQUN0QixTQUFTO1FBQ1osT0FBT2tCO0lBQ1Q7SUFFQSxPQUFPQyx3QkFBd0JuQjtBQUNqQztBQUNBLFNBQVN1QiwyQkFBMkJmLElBQUk7SUFDdEMsTUFBTSxDQUFDZ0Isd0JBQXdCLEdBQUdSLHVCQUF1QlIsTUFBTTtJQUMvRCxPQUFPZ0IsMkJBQTJCLE9BQU9BLDBCQUEwQjtBQUNyRTtBQUVBLFNBQVNDLHFCQUFxQnpCLE9BQU87SUFDbkMsSUFBSSxDQUFDaEwseURBQVNBLElBQUksQ0FBQ2dMLFNBQVM7UUFDMUIsT0FBTztJQUNUO0lBRUEsSUFBSS9LLDREQUFRQSxDQUFDK0ssVUFBVTtRQUNyQixPQUFPQTtJQUNUO0lBRUEsSUFBSSxDQUFDOUssMERBQU1BLENBQUM4SyxVQUFVO1FBQ3BCLE9BQU87SUFDVDtJQUVBLElBQUluTCw4REFBVUEsQ0FBQ21MLFlBQVlBLFlBQVk3SyxvRUFBZ0JBLENBQUM2SyxTQUFTb0IsZ0JBQWdCLEVBQUU7UUFDakYsT0FBT007SUFDVDtJQUVBLElBQUk1TSxpRUFBYUEsQ0FBQ2tMLFVBQVU7UUFDMUIsT0FBT0E7SUFDVDtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVMyQixxQkFBcUIzQixPQUFPO0lBQ25DLElBQUkvSyw0REFBUUEsQ0FBQytLLFVBQVU7UUFDckIsT0FBT0EsUUFBUTRCLE9BQU87SUFDeEI7SUFFQSxPQUFPNUIsUUFBUTZCLFVBQVU7QUFDM0I7QUFDQSxTQUFTQyxxQkFBcUI5QixPQUFPO0lBQ25DLElBQUkvSyw0REFBUUEsQ0FBQytLLFVBQVU7UUFDckIsT0FBT0EsUUFBUStCLE9BQU87SUFDeEI7SUFFQSxPQUFPL0IsUUFBUWdDLFNBQVM7QUFDMUI7QUFDQSxTQUFTQyxxQkFBcUJqQyxPQUFPO0lBQ25DLE9BQU87UUFDTDlGLEdBQUd5SCxxQkFBcUIzQjtRQUN4QjdGLEdBQUcySCxxQkFBcUI5QjtJQUMxQjtBQUNGO0FBRUEsSUFBSWtDO0FBRUgsVUFBVUEsU0FBUztJQUNsQkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUN0Q0EsU0FBUyxDQUFDQSxTQUFTLENBQUMsV0FBVyxHQUFHLENBQUMsRUFBRSxHQUFHO0FBQzFDLEdBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQztBQUU5QixTQUFTQywyQkFBMkJuQyxPQUFPO0lBQ3pDLElBQUksQ0FBQ2hMLHlEQUFTQSxJQUFJLENBQUNnTCxTQUFTO1FBQzFCLE9BQU87SUFDVDtJQUVBLE9BQU9BLFlBQVlvQyxTQUFTaEIsZ0JBQWdCO0FBQzlDO0FBRUEsU0FBU2lCLGtCQUFrQkMsa0JBQWtCO0lBQzNDLE1BQU1DLFlBQVk7UUFDaEJySSxHQUFHO1FBQ0hDLEdBQUc7SUFDTDtJQUNBLE1BQU1xSSxhQUFhTCwyQkFBMkJHLHNCQUFzQjtRQUNsRXJILFFBQVF5RyxPQUFPcEIsV0FBVztRQUMxQnZGLE9BQU8yRyxPQUFPckIsVUFBVTtJQUMxQixJQUFJO1FBQ0ZwRixRQUFRcUgsbUJBQW1CRyxZQUFZO1FBQ3ZDMUgsT0FBT3VILG1CQUFtQkksV0FBVztJQUN2QztJQUNBLE1BQU1DLFlBQVk7UUFDaEJ6SSxHQUFHb0ksbUJBQW1CTSxXQUFXLEdBQUdKLFdBQVd6SCxLQUFLO1FBQ3BEWixHQUFHbUksbUJBQW1CTyxZQUFZLEdBQUdMLFdBQVd2SCxNQUFNO0lBQ3hEO0lBQ0EsTUFBTTZILFFBQVFSLG1CQUFtQk4sU0FBUyxJQUFJTyxVQUFVcEksQ0FBQztJQUN6RCxNQUFNNEksU0FBU1QsbUJBQW1CVCxVQUFVLElBQUlVLFVBQVVySSxDQUFDO0lBQzNELE1BQU04SSxXQUFXVixtQkFBbUJOLFNBQVMsSUFBSVcsVUFBVXhJLENBQUM7SUFDNUQsTUFBTThJLFVBQVVYLG1CQUFtQlQsVUFBVSxJQUFJYyxVQUFVekksQ0FBQztJQUM1RCxPQUFPO1FBQ0w0STtRQUNBQztRQUNBQztRQUNBQztRQUNBTjtRQUNBSjtJQUNGO0FBQ0Y7QUFFQSxNQUFNVyxtQkFBbUI7SUFDdkJoSixHQUFHO0lBQ0hDLEdBQUc7QUFDTDtBQUNBLFNBQVNnSiwyQkFBMkJDLGVBQWUsRUFBRUMsbUJBQW1CLEVBQUV2TSxJQUFJLEVBQUV3TSxZQUFZLEVBQUVDLG1CQUFtQjtJQUMvRyxJQUFJLEVBQ0Z2SSxHQUFHLEVBQ0hGLElBQUksRUFDSndDLEtBQUssRUFDTEUsTUFBTSxFQUNQLEdBQUcxRztJQUVKLElBQUl3TSxpQkFBaUIsS0FBSyxHQUFHO1FBQzNCQSxlQUFlO0lBQ2pCO0lBRUEsSUFBSUMsd0JBQXdCLEtBQUssR0FBRztRQUNsQ0Esc0JBQXNCTDtJQUN4QjtJQUVBLE1BQU0sRUFDSkosS0FBSyxFQUNMRSxRQUFRLEVBQ1JELE1BQU0sRUFDTkUsT0FBTyxFQUNSLEdBQUdaLGtCQUFrQmU7SUFDdEIsTUFBTUksWUFBWTtRQUNoQnRKLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0EsTUFBTXNKLFFBQVE7UUFDWnZKLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0EsTUFBTXVKLFlBQVk7UUFDaEJ6SSxRQUFRb0ksb0JBQW9CcEksTUFBTSxHQUFHc0ksb0JBQW9CcEosQ0FBQztRQUMxRFksT0FBT3NJLG9CQUFvQnRJLEtBQUssR0FBR3dJLG9CQUFvQnJKLENBQUM7SUFDMUQ7SUFFQSxJQUFJLENBQUM0SSxTQUFTOUgsT0FBT3FJLG9CQUFvQnJJLEdBQUcsR0FBRzBJLFVBQVV6SSxNQUFNLEVBQUU7UUFDL0QsWUFBWTtRQUNadUksVUFBVXJKLENBQUMsR0FBRytILFVBQVV5QixRQUFRO1FBQ2hDRixNQUFNdEosQ0FBQyxHQUFHbUosZUFBZS9JLEtBQUtxSixHQUFHLENBQUMsQ0FBQ1Asb0JBQW9CckksR0FBRyxHQUFHMEksVUFBVXpJLE1BQU0sR0FBR0QsR0FBRSxJQUFLMEksVUFBVXpJLE1BQU07SUFDekcsT0FBTyxJQUFJLENBQUMrSCxZQUFZeEYsVUFBVTZGLG9CQUFvQjdGLE1BQU0sR0FBR2tHLFVBQVV6SSxNQUFNLEVBQUU7UUFDL0UsY0FBYztRQUNkdUksVUFBVXJKLENBQUMsR0FBRytILFVBQVUyQixPQUFPO1FBQy9CSixNQUFNdEosQ0FBQyxHQUFHbUosZUFBZS9JLEtBQUtxSixHQUFHLENBQUMsQ0FBQ1Asb0JBQW9CN0YsTUFBTSxHQUFHa0csVUFBVXpJLE1BQU0sR0FBR3VDLE1BQUssSUFBS2tHLFVBQVV6SSxNQUFNO0lBQy9HO0lBRUEsSUFBSSxDQUFDZ0ksV0FBVzNGLFNBQVMrRixvQkFBb0IvRixLQUFLLEdBQUdvRyxVQUFVM0ksS0FBSyxFQUFFO1FBQ3BFLGVBQWU7UUFDZnlJLFVBQVV0SixDQUFDLEdBQUdnSSxVQUFVMkIsT0FBTztRQUMvQkosTUFBTXZKLENBQUMsR0FBR29KLGVBQWUvSSxLQUFLcUosR0FBRyxDQUFDLENBQUNQLG9CQUFvQi9GLEtBQUssR0FBR29HLFVBQVUzSSxLQUFLLEdBQUd1QyxLQUFJLElBQUtvRyxVQUFVM0ksS0FBSztJQUMzRyxPQUFPLElBQUksQ0FBQ2dJLFVBQVVqSSxRQUFRdUksb0JBQW9CdkksSUFBSSxHQUFHNEksVUFBVTNJLEtBQUssRUFBRTtRQUN4RSxjQUFjO1FBQ2R5SSxVQUFVdEosQ0FBQyxHQUFHZ0ksVUFBVXlCLFFBQVE7UUFDaENGLE1BQU12SixDQUFDLEdBQUdvSixlQUFlL0ksS0FBS3FKLEdBQUcsQ0FBQyxDQUFDUCxvQkFBb0J2SSxJQUFJLEdBQUc0SSxVQUFVM0ksS0FBSyxHQUFHRCxJQUFHLElBQUs0SSxVQUFVM0ksS0FBSztJQUN6RztJQUVBLE9BQU87UUFDTHlJO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNLLHFCQUFxQjlELE9BQU87SUFDbkMsSUFBSUEsWUFBWW9DLFNBQVNoQixnQkFBZ0IsRUFBRTtRQUN6QyxNQUFNLEVBQ0pmLFVBQVUsRUFDVkMsV0FBVyxFQUNaLEdBQUdvQjtRQUNKLE9BQU87WUFDTDFHLEtBQUs7WUFDTEYsTUFBTTtZQUNOd0MsT0FBTytDO1lBQ1A3QyxRQUFROEM7WUFDUnZGLE9BQU9zRjtZQUNQcEYsUUFBUXFGO1FBQ1Y7SUFDRjtJQUVBLE1BQU0sRUFDSnRGLEdBQUcsRUFDSEYsSUFBSSxFQUNKd0MsS0FBSyxFQUNMRSxNQUFNLEVBQ1AsR0FBR3dDLFFBQVFDLHFCQUFxQjtJQUNqQyxPQUFPO1FBQ0xqRjtRQUNBRjtRQUNBd0M7UUFDQUU7UUFDQXpDLE9BQU9pRixRQUFRMEMsV0FBVztRQUMxQnpILFFBQVErRSxRQUFReUMsWUFBWTtJQUM5QjtBQUNGO0FBRUEsU0FBU3NCLGlCQUFpQkMsbUJBQW1CO0lBQzNDLE9BQU9BLG9CQUFvQnJILE1BQU0sQ0FBQyxDQUFDa0MsS0FBSzJCO1FBQ3RDLE9BQU9wTCx1REFBR0EsQ0FBQ3lKLEtBQUtvRCxxQkFBcUJ6QjtJQUN2QyxHQUFHekc7QUFDTDtBQUNBLFNBQVNrSyxpQkFBaUJELG1CQUFtQjtJQUMzQyxPQUFPQSxvQkFBb0JySCxNQUFNLENBQUMsQ0FBQ2tDLEtBQUsyQjtRQUN0QyxPQUFPM0IsTUFBTThDLHFCQUFxQm5CO0lBQ3BDLEdBQUc7QUFDTDtBQUNBLFNBQVMwRCxpQkFBaUJGLG1CQUFtQjtJQUMzQyxPQUFPQSxvQkFBb0JySCxNQUFNLENBQUMsQ0FBQ2tDLEtBQUsyQjtRQUN0QyxPQUFPM0IsTUFBTWlELHFCQUFxQnRCO0lBQ3BDLEdBQUc7QUFDTDtBQUVBLFNBQVMyRCx1QkFBdUJuRSxPQUFPLEVBQUVvRSxPQUFPO0lBQzlDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVckU7SUFDWjtJQUVBLElBQUksQ0FBQ0MsU0FBUztRQUNaO0lBQ0Y7SUFFQSxNQUFNLEVBQ0poRixHQUFHLEVBQ0hGLElBQUksRUFDSjBDLE1BQU0sRUFDTkYsS0FBSyxFQUNOLEdBQUc4RyxRQUFRcEU7SUFDWixNQUFNd0IsMEJBQTBCRCwyQkFBMkJ2QjtJQUUzRCxJQUFJLENBQUN3Qix5QkFBeUI7UUFDNUI7SUFDRjtJQUVBLElBQUloRSxVQUFVLEtBQUtGLFNBQVMsS0FBS3RDLE9BQU8wRyxPQUFPcEIsV0FBVyxJQUFJeEYsUUFBUTRHLE9BQU9yQixVQUFVLEVBQUU7UUFDdkZMLFFBQVFxRSxjQUFjLENBQUM7WUFDckJDLE9BQU87WUFDUEMsUUFBUTtRQUNWO0lBQ0Y7QUFDRjtBQUVBLE1BQU0xRCxhQUFhO0lBQUM7UUFBQztRQUFLO1lBQUM7WUFBUTtTQUFRO1FBQUVvRDtLQUFpQjtJQUFFO1FBQUM7UUFBSztZQUFDO1lBQU87U0FBUztRQUFFQztLQUFpQjtDQUFDO0FBQzNHLE1BQU1NO0lBQ0pDLFlBQVk5SixJQUFJLEVBQUVxRixPQUFPLENBQUU7UUFDekIsSUFBSSxDQUFDckYsSUFBSSxHQUFHLEtBQUs7UUFDakIsSUFBSSxDQUFDSSxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNFLE1BQU0sR0FBRyxLQUFLO1FBQ25CLElBQUksQ0FBQ0QsR0FBRyxHQUFHLEtBQUs7UUFDaEIsSUFBSSxDQUFDd0MsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDRixLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUN4QyxJQUFJLEdBQUcsS0FBSztRQUNqQixNQUFNa0osc0JBQXNCaEQsdUJBQXVCaEI7UUFDbkQsTUFBTTBFLGdCQUFnQlgsaUJBQWlCQztRQUN2QyxJQUFJLENBQUNySixJQUFJLEdBQUc7WUFBRSxHQUFHQSxJQUFJO1FBQ3JCO1FBQ0EsSUFBSSxDQUFDSSxLQUFLLEdBQUdKLEtBQUtJLEtBQUs7UUFDdkIsSUFBSSxDQUFDRSxNQUFNLEdBQUdOLEtBQUtNLE1BQU07UUFFekIsS0FBSyxNQUFNLENBQUMwSixNQUFNQyxNQUFNQyxnQkFBZ0IsSUFBSWhFLFdBQVk7WUFDdEQsS0FBSyxNQUFNaUUsT0FBT0YsS0FBTTtnQkFDdEI1SyxPQUFPK0ssY0FBYyxDQUFDLElBQUksRUFBRUQsS0FBSztvQkFDL0IzSSxLQUFLO3dCQUNILE1BQU02SSxpQkFBaUJILGdCQUFnQmI7d0JBQ3ZDLE1BQU1pQixzQkFBc0JQLGFBQWEsQ0FBQ0MsS0FBSyxHQUFHSzt3QkFDbEQsT0FBTyxJQUFJLENBQUNySyxJQUFJLENBQUNtSyxJQUFJLEdBQUdHO29CQUMxQjtvQkFDQUMsWUFBWTtnQkFDZDtZQUNGO1FBQ0Y7UUFFQWxMLE9BQU8rSyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDbENHLFlBQVk7UUFDZDtJQUNGO0FBRUY7QUFFQSxNQUFNQztJQUNKVixZQUFZckgsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDMUcsU0FBUyxHQUFHLEVBQUU7UUFFbkIsSUFBSSxDQUFDME8sU0FBUyxHQUFHO1lBQ2YsSUFBSSxDQUFDMU8sU0FBUyxDQUFDTyxPQUFPLENBQUNaLENBQUFBO2dCQUNyQixJQUFJZ1A7Z0JBRUosT0FBTyxDQUFDQSxlQUFlLElBQUksQ0FBQ2pJLE1BQU0sS0FBSyxPQUFPLEtBQUssSUFBSWlJLGFBQWFDLG1CQUFtQixJQUFJalA7WUFDN0Y7UUFDRjtRQUVBLElBQUksQ0FBQytHLE1BQU0sR0FBR0E7SUFDaEI7SUFFQWhJLElBQUltUSxTQUFTLEVBQUVDLE9BQU8sRUFBRWxNLE9BQU8sRUFBRTtRQUMvQixJQUFJbU07UUFFSEEsQ0FBQUEsZ0JBQWdCLElBQUksQ0FBQ3JJLE1BQU0sS0FBSyxPQUFPLEtBQUssSUFBSXFJLGNBQWNDLGdCQUFnQixDQUFDSCxXQUFXQyxTQUFTbE07UUFDcEcsSUFBSSxDQUFDNUMsU0FBUyxDQUFDMkYsSUFBSSxDQUFDO1lBQUNrSjtZQUFXQztZQUFTbE07U0FBUTtJQUNuRDtBQUVGO0FBRUEsU0FBU3FNLHVCQUF1QnZJLE1BQU07SUFDcEMsMkZBQTJGO0lBQzNGLDZFQUE2RTtJQUM3RSw4RUFBOEU7SUFDOUUsNkVBQTZFO0lBQzdFLCtEQUErRDtJQUMvRCxNQUFNLEVBQ0p3SSxXQUFXLEVBQ1osR0FBR2hSLDZEQUFTQSxDQUFDd0k7SUFDZCxPQUFPQSxrQkFBa0J3SSxjQUFjeEksU0FBU2pJLG9FQUFnQkEsQ0FBQ2lJO0FBQ25FO0FBRUEsU0FBU3lJLG9CQUFvQkMsS0FBSyxFQUFFQyxXQUFXO0lBQzdDLE1BQU1DLEtBQUt6TCxLQUFLcUosR0FBRyxDQUFDa0MsTUFBTTVMLENBQUM7SUFDM0IsTUFBTStMLEtBQUsxTCxLQUFLcUosR0FBRyxDQUFDa0MsTUFBTTNMLENBQUM7SUFFM0IsSUFBSSxPQUFPNEwsZ0JBQWdCLFVBQVU7UUFDbkMsT0FBT3hMLEtBQUtDLElBQUksQ0FBQ3dMLE1BQU0sSUFBSUMsTUFBTSxLQUFLRjtJQUN4QztJQUVBLElBQUksT0FBT0EsZUFBZSxPQUFPQSxhQUFhO1FBQzVDLE9BQU9DLEtBQUtELFlBQVk3TCxDQUFDLElBQUkrTCxLQUFLRixZQUFZNUwsQ0FBQztJQUNqRDtJQUVBLElBQUksT0FBTzRMLGFBQWE7UUFDdEIsT0FBT0MsS0FBS0QsWUFBWTdMLENBQUM7SUFDM0I7SUFFQSxJQUFJLE9BQU82TCxhQUFhO1FBQ3RCLE9BQU9FLEtBQUtGLFlBQVk1TCxDQUFDO0lBQzNCO0lBRUEsT0FBTztBQUNUO0FBRUEsSUFBSStMO0FBRUgsVUFBVUEsU0FBUztJQUNsQkEsU0FBUyxDQUFDLFFBQVEsR0FBRztJQUNyQkEsU0FBUyxDQUFDLFlBQVksR0FBRztJQUN6QkEsU0FBUyxDQUFDLFVBQVUsR0FBRztJQUN2QkEsU0FBUyxDQUFDLGNBQWMsR0FBRztJQUMzQkEsU0FBUyxDQUFDLFNBQVMsR0FBRztJQUN0QkEsU0FBUyxDQUFDLGtCQUFrQixHQUFHO0lBQy9CQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7QUFDbEMsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBRTlCLFNBQVNDLGVBQWVuUCxLQUFLO0lBQzNCQSxNQUFNbVAsY0FBYztBQUN0QjtBQUNBLFNBQVNDLGdCQUFnQnBQLEtBQUs7SUFDNUJBLE1BQU1vUCxlQUFlO0FBQ3ZCO0FBRUEsSUFBSUM7QUFFSCxVQUFVQSxZQUFZO0lBQ3JCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsS0FBSyxHQUFHO0lBQ3JCQSxZQUFZLENBQUMsTUFBTSxHQUFHO0lBQ3RCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0FBQzFCLEdBQUdBLGdCQUFpQkEsQ0FBQUEsZUFBZSxDQUFDO0FBRXBDLE1BQU1DLHVCQUF1QjtJQUMzQkMsT0FBTztRQUFDRixhQUFhRyxLQUFLO1FBQUVILGFBQWFJLEtBQUs7S0FBQztJQUMvQ0MsUUFBUTtRQUFDTCxhQUFhTSxHQUFHO0tBQUM7SUFDMUJDLEtBQUs7UUFBQ1AsYUFBYUcsS0FBSztRQUFFSCxhQUFhSSxLQUFLO0tBQUM7QUFDL0M7QUFDQSxNQUFNSSxrQ0FBa0MsQ0FBQzdQLE9BQU9GO0lBQzlDLElBQUksRUFDRmdRLGtCQUFrQixFQUNuQixHQUFHaFE7SUFFSixPQUFRRSxNQUFNK1AsSUFBSTtRQUNoQixLQUFLVixhQUFhVyxLQUFLO1lBQ3JCLE9BQU87Z0JBQUUsR0FBR0Ysa0JBQWtCO2dCQUM1QjVNLEdBQUc0TSxtQkFBbUI1TSxDQUFDLEdBQUc7WUFDNUI7UUFFRixLQUFLbU0sYUFBYVksSUFBSTtZQUNwQixPQUFPO2dCQUFFLEdBQUdILGtCQUFrQjtnQkFDNUI1TSxHQUFHNE0sbUJBQW1CNU0sQ0FBQyxHQUFHO1lBQzVCO1FBRUYsS0FBS21NLGFBQWFhLElBQUk7WUFDcEIsT0FBTztnQkFBRSxHQUFHSixrQkFBa0I7Z0JBQzVCM00sR0FBRzJNLG1CQUFtQjNNLENBQUMsR0FBRztZQUM1QjtRQUVGLEtBQUtrTSxhQUFhYyxFQUFFO1lBQ2xCLE9BQU87Z0JBQUUsR0FBR0wsa0JBQWtCO2dCQUM1QjNNLEdBQUcyTSxtQkFBbUIzTSxDQUFDLEdBQUc7WUFDNUI7SUFDSjtJQUVBLE9BQU9pTjtBQUNUO0FBRUEsTUFBTUM7SUFDSjVDLFlBQVk2QyxLQUFLLENBQUU7UUFDakIsSUFBSSxDQUFDQSxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUcsS0FBSztRQUNqQyxJQUFJLENBQUM5USxTQUFTLEdBQUcsS0FBSztRQUN0QixJQUFJLENBQUMrUSxlQUFlLEdBQUcsS0FBSztRQUM1QixJQUFJLENBQUNILEtBQUssR0FBR0E7UUFDYixNQUFNLEVBQ0p0USxPQUFPLEVBQ0xvRyxNQUFNLEVBQ1AsRUFDRixHQUFHa0s7UUFDSixJQUFJLENBQUNBLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUM1USxTQUFTLEdBQUcsSUFBSXlPLFVBQVVoUSxvRUFBZ0JBLENBQUNpSTtRQUNoRCxJQUFJLENBQUNxSyxlQUFlLEdBQUcsSUFBSXRDLFVBQVV2USw2REFBU0EsQ0FBQ3dJO1FBQy9DLElBQUksQ0FBQ3NLLGFBQWEsR0FBRyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0MsSUFBSSxDQUFDLElBQUk7UUFDakQsSUFBSSxDQUFDQyxZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZLENBQUNELElBQUksQ0FBQyxJQUFJO1FBQy9DLElBQUksQ0FBQ0UsTUFBTTtJQUNiO0lBRUFBLFNBQVM7UUFDUCxJQUFJLENBQUNDLFdBQVc7UUFDaEIsSUFBSSxDQUFDTCxlQUFlLENBQUNyUyxHQUFHLENBQUM4USxVQUFVNkIsTUFBTSxFQUFFLElBQUksQ0FBQ0gsWUFBWTtRQUM1RCxJQUFJLENBQUNILGVBQWUsQ0FBQ3JTLEdBQUcsQ0FBQzhRLFVBQVU4QixnQkFBZ0IsRUFBRSxJQUFJLENBQUNKLFlBQVk7UUFDdEVLLFdBQVcsSUFBTSxJQUFJLENBQUN2UixTQUFTLENBQUN0QixHQUFHLENBQUM4USxVQUFVZ0MsT0FBTyxFQUFFLElBQUksQ0FBQ1IsYUFBYTtJQUMzRTtJQUVBSSxjQUFjO1FBQ1osTUFBTSxFQUNKSyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUixHQUFHLElBQUksQ0FBQ2QsS0FBSztRQUNkLE1BQU05RyxPQUFPMkgsV0FBVzNILElBQUksQ0FBQzZILE9BQU87UUFFcEMsSUFBSTdILE1BQU07WUFDUjJELHVCQUF1QjNEO1FBQ3pCO1FBRUE0SCxRQUFRck87SUFDVjtJQUVBMk4sY0FBYzFRLEtBQUssRUFBRTtRQUNuQixJQUFJM0IsbUVBQWVBLENBQUMyQixRQUFRO1lBQzFCLE1BQU0sRUFDSlEsTUFBTSxFQUNOOFEsT0FBTyxFQUNQaFAsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDZ08sS0FBSztZQUNkLE1BQU0sRUFDSmlCLGdCQUFnQmpDLG9CQUFvQixFQUNwQ2tDLG1CQUFtQjNCLCtCQUErQixFQUNsRDRCLGlCQUFpQixRQUFRLEVBQzFCLEdBQUduUDtZQUNKLE1BQU0sRUFDSnlOLElBQUksRUFDTCxHQUFHL1A7WUFFSixJQUFJdVIsY0FBYzNCLEdBQUcsQ0FBQ3ZGLFFBQVEsQ0FBQzBGLE9BQU87Z0JBQ3BDLElBQUksQ0FBQzJCLFNBQVMsQ0FBQzFSO2dCQUNmO1lBQ0Y7WUFFQSxJQUFJdVIsY0FBYzdCLE1BQU0sQ0FBQ3JGLFFBQVEsQ0FBQzBGLE9BQU87Z0JBQ3ZDLElBQUksQ0FBQ2EsWUFBWSxDQUFDNVE7Z0JBQ2xCO1lBQ0Y7WUFFQSxNQUFNLEVBQ0o4RSxhQUFhLEVBQ2QsR0FBR3dNLFFBQVFELE9BQU87WUFDbkIsTUFBTXZCLHFCQUFxQmhMLGdCQUFnQjtnQkFDekM1QixHQUFHNEIsY0FBY2hCLElBQUk7Z0JBQ3JCWCxHQUFHMkIsY0FBY2QsR0FBRztZQUN0QixJQUFJakI7WUFFSixJQUFJLENBQUMsSUFBSSxDQUFDeU4sb0JBQW9CLEVBQUU7Z0JBQzlCLElBQUksQ0FBQ0Esb0JBQW9CLEdBQUdWO1lBQzlCO1lBRUEsTUFBTTZCLGlCQUFpQkgsaUJBQWlCeFIsT0FBTztnQkFDN0NRO2dCQUNBOFEsU0FBU0EsUUFBUUQsT0FBTztnQkFDeEJ2QjtZQUNGO1lBRUEsSUFBSTZCLGdCQUFnQjtnQkFDbEIsTUFBTUMsbUJBQW1CdFQsNERBQVFBLENBQUNxVCxnQkFBZ0I3QjtnQkFDbEQsTUFBTStCLGNBQWM7b0JBQ2xCM08sR0FBRztvQkFDSEMsR0FBRztnQkFDTDtnQkFDQSxNQUFNLEVBQ0o2SixtQkFBbUIsRUFDcEIsR0FBR3NFLFFBQVFELE9BQU87Z0JBRW5CLEtBQUssTUFBTWpGLG1CQUFtQlksb0JBQXFCO29CQUNqRCxNQUFNUixZQUFZeE0sTUFBTStQLElBQUk7b0JBQzVCLE1BQU0sRUFDSmpFLEtBQUssRUFDTEcsT0FBTyxFQUNQRixNQUFNLEVBQ05DLFFBQVEsRUFDUkwsU0FBUyxFQUNUSixTQUFTLEVBQ1YsR0FBR0Ysa0JBQWtCZTtvQkFDdEIsTUFBTTBGLG9CQUFvQmhGLHFCQUFxQlY7b0JBQy9DLE1BQU0yRixxQkFBcUI7d0JBQ3pCN08sR0FBR0ssS0FBS2dELEdBQUcsQ0FBQ2lHLGNBQWM2QyxhQUFhVyxLQUFLLEdBQUc4QixrQkFBa0J4TCxLQUFLLEdBQUd3TCxrQkFBa0IvTixLQUFLLEdBQUcsSUFBSStOLGtCQUFrQnhMLEtBQUssRUFBRS9DLEtBQUs4QyxHQUFHLENBQUNtRyxjQUFjNkMsYUFBYVcsS0FBSyxHQUFHOEIsa0JBQWtCaE8sSUFBSSxHQUFHZ08sa0JBQWtCaE8sSUFBSSxHQUFHZ08sa0JBQWtCL04sS0FBSyxHQUFHLEdBQUc0TixlQUFlek8sQ0FBQzt3QkFDM1FDLEdBQUdJLEtBQUtnRCxHQUFHLENBQUNpRyxjQUFjNkMsYUFBYWEsSUFBSSxHQUFHNEIsa0JBQWtCdEwsTUFBTSxHQUFHc0wsa0JBQWtCN04sTUFBTSxHQUFHLElBQUk2TixrQkFBa0J0TCxNQUFNLEVBQUVqRCxLQUFLOEMsR0FBRyxDQUFDbUcsY0FBYzZDLGFBQWFhLElBQUksR0FBRzRCLGtCQUFrQjlOLEdBQUcsR0FBRzhOLGtCQUFrQjlOLEdBQUcsR0FBRzhOLGtCQUFrQjdOLE1BQU0sR0FBRyxHQUFHME4sZUFBZXhPLENBQUM7b0JBQzdRO29CQUNBLE1BQU02TyxhQUFheEYsY0FBYzZDLGFBQWFXLEtBQUssSUFBSSxDQUFDL0QsV0FBV08sY0FBYzZDLGFBQWFZLElBQUksSUFBSSxDQUFDbEU7b0JBQ3ZHLE1BQU1rRyxhQUFhekYsY0FBYzZDLGFBQWFhLElBQUksSUFBSSxDQUFDbEUsWUFBWVEsY0FBYzZDLGFBQWFjLEVBQUUsSUFBSSxDQUFDckU7b0JBRXJHLElBQUlrRyxjQUFjRCxtQkFBbUI3TyxDQUFDLEtBQUt5TyxlQUFlek8sQ0FBQyxFQUFFO3dCQUMzRCxNQUFNZ1AsdUJBQXVCOUYsZ0JBQWdCdkIsVUFBVSxHQUFHK0csaUJBQWlCMU8sQ0FBQzt3QkFDNUUsTUFBTWlQLDRCQUE0QjNGLGNBQWM2QyxhQUFhVyxLQUFLLElBQUlrQyx3QkFBd0J2RyxVQUFVekksQ0FBQyxJQUFJc0osY0FBYzZDLGFBQWFZLElBQUksSUFBSWlDLHdCQUF3QjNHLFVBQVVySSxDQUFDO3dCQUVuTCxJQUFJaVAsNkJBQTZCLENBQUNQLGlCQUFpQnpPLENBQUMsRUFBRTs0QkFDcEQsZ0ZBQWdGOzRCQUNoRixxREFBcUQ7NEJBQ3JEaUosZ0JBQWdCZ0csUUFBUSxDQUFDO2dDQUN2QnRPLE1BQU1vTztnQ0FDTkcsVUFBVVo7NEJBQ1o7NEJBQ0E7d0JBQ0Y7d0JBRUEsSUFBSVUsMkJBQTJCOzRCQUM3Qk4sWUFBWTNPLENBQUMsR0FBR2tKLGdCQUFnQnZCLFVBQVUsR0FBR3FIO3dCQUMvQyxPQUFPOzRCQUNMTCxZQUFZM08sQ0FBQyxHQUFHc0osY0FBYzZDLGFBQWFXLEtBQUssR0FBRzVELGdCQUFnQnZCLFVBQVUsR0FBR2MsVUFBVXpJLENBQUMsR0FBR2tKLGdCQUFnQnZCLFVBQVUsR0FBR1UsVUFBVXJJLENBQUM7d0JBQ3hJO3dCQUVBLElBQUkyTyxZQUFZM08sQ0FBQyxFQUFFOzRCQUNqQmtKLGdCQUFnQmtHLFFBQVEsQ0FBQztnQ0FDdkJ4TyxNQUFNLENBQUMrTixZQUFZM08sQ0FBQztnQ0FDcEJtUCxVQUFVWjs0QkFDWjt3QkFDRjt3QkFFQTtvQkFDRixPQUFPLElBQUlRLGNBQWNGLG1CQUFtQjVPLENBQUMsS0FBS3dPLGVBQWV4TyxDQUFDLEVBQUU7d0JBQ2xFLE1BQU0rTyx1QkFBdUI5RixnQkFBZ0JwQixTQUFTLEdBQUc0RyxpQkFBaUJ6TyxDQUFDO3dCQUMzRSxNQUFNZ1AsNEJBQTRCM0YsY0FBYzZDLGFBQWFhLElBQUksSUFBSWdDLHdCQUF3QnZHLFVBQVV4SSxDQUFDLElBQUlxSixjQUFjNkMsYUFBYWMsRUFBRSxJQUFJK0Isd0JBQXdCM0csVUFBVXBJLENBQUM7d0JBRWhMLElBQUlnUCw2QkFBNkIsQ0FBQ1AsaUJBQWlCMU8sQ0FBQyxFQUFFOzRCQUNwRCxnRkFBZ0Y7NEJBQ2hGLHFEQUFxRDs0QkFDckRrSixnQkFBZ0JnRyxRQUFRLENBQUM7Z0NBQ3ZCcE8sS0FBS2tPO2dDQUNMRyxVQUFVWjs0QkFDWjs0QkFDQTt3QkFDRjt3QkFFQSxJQUFJVSwyQkFBMkI7NEJBQzdCTixZQUFZMU8sQ0FBQyxHQUFHaUosZ0JBQWdCcEIsU0FBUyxHQUFHa0g7d0JBQzlDLE9BQU87NEJBQ0xMLFlBQVkxTyxDQUFDLEdBQUdxSixjQUFjNkMsYUFBYWEsSUFBSSxHQUFHOUQsZ0JBQWdCcEIsU0FBUyxHQUFHVyxVQUFVeEksQ0FBQyxHQUFHaUosZ0JBQWdCcEIsU0FBUyxHQUFHTyxVQUFVcEksQ0FBQzt3QkFDckk7d0JBRUEsSUFBSTBPLFlBQVkxTyxDQUFDLEVBQUU7NEJBQ2pCaUosZ0JBQWdCa0csUUFBUSxDQUFDO2dDQUN2QnRPLEtBQUssQ0FBQzZOLFlBQVkxTyxDQUFDO2dDQUNuQmtQLFVBQVVaOzRCQUNaO3dCQUNGO3dCQUVBO29CQUNGO2dCQUNGO2dCQUVBLElBQUksQ0FBQ2MsVUFBVSxDQUFDdlMsT0FBTzVCLHVEQUFHQSxDQUFDRSw0REFBUUEsQ0FBQ3FULGdCQUFnQixJQUFJLENBQUNuQixvQkFBb0IsR0FBR3FCO1lBQ2xGO1FBQ0Y7SUFDRjtJQUVBVSxXQUFXdlMsS0FBSyxFQUFFd1MsV0FBVyxFQUFFO1FBQzdCLE1BQU0sRUFDSkMsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDbkMsS0FBSztRQUNkdFEsTUFBTW1QLGNBQWM7UUFDcEJzRCxPQUFPRDtJQUNUO0lBRUFkLFVBQVUxUixLQUFLLEVBQUU7UUFDZixNQUFNLEVBQ0owUyxLQUFLLEVBQ04sR0FBRyxJQUFJLENBQUNwQyxLQUFLO1FBQ2R0USxNQUFNbVAsY0FBYztRQUNwQixJQUFJLENBQUN3RCxNQUFNO1FBQ1hEO0lBQ0Y7SUFFQTlCLGFBQWE1USxLQUFLLEVBQUU7UUFDbEIsTUFBTSxFQUNKNFMsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDdEMsS0FBSztRQUNkdFEsTUFBTW1QLGNBQWM7UUFDcEIsSUFBSSxDQUFDd0QsTUFBTTtRQUNYQztJQUNGO0lBRUFELFNBQVM7UUFDUCxJQUFJLENBQUNqVCxTQUFTLENBQUMwTyxTQUFTO1FBQ3hCLElBQUksQ0FBQ3FDLGVBQWUsQ0FBQ3JDLFNBQVM7SUFDaEM7QUFFRjtBQUNBaUMsZUFBZXdDLFVBQVUsR0FBRztJQUFDO1FBQzNCdEUsV0FBVztRQUNYQyxTQUFTLENBQUN4TyxPQUFPRixNQUFNYTtZQUNyQixJQUFJLEVBQ0Y0USxnQkFBZ0JqQyxvQkFBb0IsRUFDcEN3RCxZQUFZLEVBQ2IsR0FBR2hUO1lBQ0osSUFBSSxFQUNGVSxNQUFNLEVBQ1AsR0FBR0c7WUFDSixNQUFNLEVBQ0pvUCxJQUFJLEVBQ0wsR0FBRy9QLE1BQU0rUyxXQUFXO1lBRXJCLElBQUl4QixjQUFjaEMsS0FBSyxDQUFDbEYsUUFBUSxDQUFDMEYsT0FBTztnQkFDdEMsTUFBTWlELFlBQVl4UyxPQUFPeVMsYUFBYSxDQUFDNUIsT0FBTztnQkFFOUMsSUFBSTJCLGFBQWFoVCxNQUFNb0csTUFBTSxLQUFLNE0sV0FBVztvQkFDM0MsT0FBTztnQkFDVDtnQkFFQWhULE1BQU1tUCxjQUFjO2dCQUNwQjJELGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYTtvQkFDM0M5UyxPQUFPQSxNQUFNK1MsV0FBVztnQkFDMUI7Z0JBQ0EsT0FBTztZQUNUO1lBRUEsT0FBTztRQUNUO0lBQ0Y7Q0FBRTtBQUVGLFNBQVNHLHFCQUFxQkMsVUFBVTtJQUN0QyxPQUFPQyxRQUFRRCxjQUFjLGNBQWNBO0FBQzdDO0FBRUEsU0FBU0Usa0JBQWtCRixVQUFVO0lBQ25DLE9BQU9DLFFBQVFELGNBQWMsV0FBV0E7QUFDMUM7QUFFQSxNQUFNRztJQUNKN0YsWUFBWTZDLEtBQUssRUFBRWlELE1BQU0sRUFBRUMsY0FBYyxDQUFFO1FBQ3pDLElBQUlDO1FBRUosSUFBSUQsbUJBQW1CLEtBQUssR0FBRztZQUM3QkEsaUJBQWlCN0UsdUJBQXVCMkIsTUFBTXRRLEtBQUssQ0FBQ29HLE1BQU07UUFDNUQ7UUFFQSxJQUFJLENBQUNrSyxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNpRCxNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUNoRCxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNuRixRQUFRLEdBQUcsS0FBSztRQUNyQixJQUFJLENBQUNzSSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxLQUFLO1FBQy9CLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2xVLFNBQVMsR0FBRyxLQUFLO1FBQ3RCLElBQUksQ0FBQ21VLGlCQUFpQixHQUFHLEtBQUs7UUFDOUIsSUFBSSxDQUFDcEQsZUFBZSxHQUFHLEtBQUs7UUFDNUIsSUFBSSxDQUFDSCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDaUQsTUFBTSxHQUFHQTtRQUNkLE1BQU0sRUFDSnZULEtBQUssRUFDTixHQUFHc1E7UUFDSixNQUFNLEVBQ0psSyxNQUFNLEVBQ1AsR0FBR3BHO1FBQ0osSUFBSSxDQUFDc1EsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2lELE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNuSSxRQUFRLEdBQUdqTixvRUFBZ0JBLENBQUNpSTtRQUNqQyxJQUFJLENBQUN5TixpQkFBaUIsR0FBRyxJQUFJMUYsVUFBVSxJQUFJLENBQUMvQyxRQUFRO1FBQ3BELElBQUksQ0FBQzFMLFNBQVMsR0FBRyxJQUFJeU8sVUFBVXFGO1FBQy9CLElBQUksQ0FBQy9DLGVBQWUsR0FBRyxJQUFJdEMsVUFBVXZRLDZEQUFTQSxDQUFDd0k7UUFDL0MsSUFBSSxDQUFDdU4sa0JBQWtCLEdBQUcsQ0FBQ0YsdUJBQXVCOVYsdUVBQW1CQSxDQUFDcUMsTUFBSyxLQUFNLE9BQU95VCx1QkFBdUIxUTtRQUMvRyxJQUFJLENBQUMrTixXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNILElBQUksQ0FBQyxJQUFJO1FBQzdDLElBQUksQ0FBQzRCLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQzVCLElBQUksQ0FBQyxJQUFJO1FBQzNDLElBQUksQ0FBQ2UsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDZixJQUFJLENBQUMsSUFBSTtRQUN6QyxJQUFJLENBQUNDLFlBQVksR0FBRyxJQUFJLENBQUNBLFlBQVksQ0FBQ0QsSUFBSSxDQUFDLElBQUk7UUFDL0MsSUFBSSxDQUFDbUQsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDbkQsSUFBSSxDQUFDLElBQUk7UUFDakQsSUFBSSxDQUFDb0QsbUJBQW1CLEdBQUcsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQ3BELElBQUksQ0FBQyxJQUFJO1FBQzdELElBQUksQ0FBQ0UsTUFBTTtJQUNiO0lBRUFBLFNBQVM7UUFDUCxNQUFNLEVBQ0owQyxNQUFNLEVBQ05qRCxPQUFPLEVBQ0xoTyxTQUFTLEVBQ1AwUixvQkFBb0IsRUFDckIsRUFDRixFQUNGLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQ3RVLFNBQVMsQ0FBQ3RCLEdBQUcsQ0FBQ21WLE9BQU9VLElBQUksQ0FBQ0MsSUFBSSxFQUFFLElBQUksQ0FBQzNCLFVBQVUsRUFBRTtZQUNwRDRCLFNBQVM7UUFDWDtRQUNBLElBQUksQ0FBQ3pVLFNBQVMsQ0FBQ3RCLEdBQUcsQ0FBQ21WLE9BQU8zRCxHQUFHLENBQUNzRSxJQUFJLEVBQUUsSUFBSSxDQUFDeEMsU0FBUztRQUNsRCxJQUFJLENBQUNqQixlQUFlLENBQUNyUyxHQUFHLENBQUM4USxVQUFVNkIsTUFBTSxFQUFFLElBQUksQ0FBQ0gsWUFBWTtRQUM1RCxJQUFJLENBQUNILGVBQWUsQ0FBQ3JTLEdBQUcsQ0FBQzhRLFVBQVVrRixTQUFTLEVBQUVqRjtRQUM5QyxJQUFJLENBQUNzQixlQUFlLENBQUNyUyxHQUFHLENBQUM4USxVQUFVOEIsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDSixZQUFZO1FBQ3RFLElBQUksQ0FBQ0gsZUFBZSxDQUFDclMsR0FBRyxDQUFDOFEsVUFBVW1GLFdBQVcsRUFBRWxGO1FBQ2hELElBQUksQ0FBQzBFLGlCQUFpQixDQUFDelYsR0FBRyxDQUFDOFEsVUFBVWdDLE9BQU8sRUFBRSxJQUFJLENBQUM0QyxhQUFhO1FBRWhFLElBQUlFLHNCQUFzQjtZQUN4QixJQUFJZCxxQkFBcUJjLHVCQUF1QjtnQkFDOUM7WUFDRjtZQUVBLElBQUlYLGtCQUFrQlcsdUJBQXVCO2dCQUMzQyxJQUFJLENBQUNKLFNBQVMsR0FBRzNDLFdBQVcsSUFBSSxDQUFDSCxXQUFXLEVBQUVrRCxxQkFBcUJNLEtBQUs7Z0JBQ3hFO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ3hELFdBQVc7SUFDbEI7SUFFQTZCLFNBQVM7UUFDUCxJQUFJLENBQUNqVCxTQUFTLENBQUMwTyxTQUFTO1FBQ3hCLElBQUksQ0FBQ3FDLGVBQWUsQ0FBQ3JDLFNBQVMsSUFBSSxvRUFBb0U7UUFDdEcseUZBQXlGO1FBRXpGNkMsV0FBVyxJQUFJLENBQUM0QyxpQkFBaUIsQ0FBQ3pGLFNBQVMsRUFBRTtRQUU3QyxJQUFJLElBQUksQ0FBQ3dGLFNBQVMsS0FBSyxNQUFNO1lBQzNCVyxhQUFhLElBQUksQ0FBQ1gsU0FBUztZQUMzQixJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNuQjtJQUNGO0lBRUE5QyxjQUFjO1FBQ1osTUFBTSxFQUNKNkMsa0JBQWtCLEVBQ25CLEdBQUcsSUFBSTtRQUNSLE1BQU0sRUFDSnZDLE9BQU8sRUFDUixHQUFHLElBQUksQ0FBQ2QsS0FBSztRQUVkLElBQUlxRCxvQkFBb0I7WUFDdEIsSUFBSSxDQUFDRCxTQUFTLEdBQUcsTUFBTSx1RUFBdUU7WUFFOUYsSUFBSSxDQUFDRyxpQkFBaUIsQ0FBQ3pWLEdBQUcsQ0FBQzhRLFVBQVVzRixLQUFLLEVBQUVwRixpQkFBaUI7Z0JBQzNEcUYsU0FBUztZQUNYLElBQUksOENBQThDO1lBRWxELElBQUksQ0FBQ1YsbUJBQW1CLElBQUksZ0RBQWdEO1lBRTVFLElBQUksQ0FBQ0YsaUJBQWlCLENBQUN6VixHQUFHLENBQUM4USxVQUFVd0YsZUFBZSxFQUFFLElBQUksQ0FBQ1gsbUJBQW1CO1lBQzlFM0MsUUFBUXVDO1FBQ1Y7SUFDRjtJQUVBcEIsV0FBV3ZTLEtBQUssRUFBRTtRQUNoQixJQUFJMlU7UUFFSixNQUFNLEVBQ0pqQixTQUFTLEVBQ1RDLGtCQUFrQixFQUNsQnJELEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixNQUFNLEVBQ0ptQyxNQUFNLEVBQ05uUSxTQUFTLEVBQ1AwUixvQkFBb0IsRUFDckIsRUFDRixHQUFHMUQ7UUFFSixJQUFJLENBQUNxRCxvQkFBb0I7WUFDdkI7UUFDRjtRQUVBLE1BQU1uQixjQUFjLENBQUNtQyx3QkFBd0JoWCx1RUFBbUJBLENBQUNxQyxNQUFLLEtBQU0sT0FBTzJVLHdCQUF3QjVSO1FBQzNHLE1BQU0rTCxRQUFReFEsNERBQVFBLENBQUNxVixvQkFBb0JuQjtRQUUzQyxJQUFJLENBQUNrQixhQUFhTSxzQkFBc0I7WUFDdEMsd0JBQXdCO1lBQ3hCLElBQUlYLGtCQUFrQlcsdUJBQXVCO2dCQUMzQyxJQUFJbkYsb0JBQW9CQyxPQUFPa0YscUJBQXFCWSxTQUFTLEdBQUc7b0JBQzlELE9BQU8sSUFBSSxDQUFDaEUsWUFBWTtnQkFDMUI7Z0JBRUE7WUFDRjtZQUVBLElBQUlzQyxxQkFBcUJjLHVCQUF1QjtnQkFDOUMsSUFBSUEscUJBQXFCWSxTQUFTLElBQUksUUFBUS9GLG9CQUFvQkMsT0FBT2tGLHFCQUFxQlksU0FBUyxHQUFHO29CQUN4RyxPQUFPLElBQUksQ0FBQ2hFLFlBQVk7Z0JBQzFCO2dCQUVBLElBQUkvQixvQkFBb0JDLE9BQU9rRixxQkFBcUJhLFFBQVEsR0FBRztvQkFDN0QsT0FBTyxJQUFJLENBQUMvRCxXQUFXO2dCQUN6QjtnQkFFQTtZQUNGO1FBQ0Y7UUFFQSxJQUFJOVEsTUFBTThVLFVBQVUsRUFBRTtZQUNwQjlVLE1BQU1tUCxjQUFjO1FBQ3RCO1FBRUFzRCxPQUFPRDtJQUNUO0lBRUFkLFlBQVk7UUFDVixNQUFNLEVBQ0pnQixLQUFLLEVBQ04sR0FBRyxJQUFJLENBQUNwQyxLQUFLO1FBQ2QsSUFBSSxDQUFDcUMsTUFBTTtRQUNYRDtJQUNGO0lBRUE5QixlQUFlO1FBQ2IsTUFBTSxFQUNKZ0MsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDdEMsS0FBSztRQUNkLElBQUksQ0FBQ3FDLE1BQU07UUFDWEM7SUFDRjtJQUVBa0IsY0FBYzlULEtBQUssRUFBRTtRQUNuQixJQUFJQSxNQUFNK1AsSUFBSSxLQUFLVixhQUFhTSxHQUFHLEVBQUU7WUFDbkMsSUFBSSxDQUFDaUIsWUFBWTtRQUNuQjtJQUNGO0lBRUFtRCxzQkFBc0I7UUFDcEIsSUFBSWdCO1FBRUhBLENBQUFBLHdCQUF3QixJQUFJLENBQUMzSixRQUFRLENBQUM0SixZQUFZLEVBQUMsS0FBTSxPQUFPLEtBQUssSUFBSUQsc0JBQXNCRSxlQUFlO0lBQ2pIO0FBRUY7QUFFQSxNQUFNMUIsU0FBUztJQUNiVSxNQUFNO1FBQ0pDLE1BQU07SUFDUjtJQUNBdEUsS0FBSztRQUNIc0UsTUFBTTtJQUNSO0FBQ0Y7QUFDQSxNQUFNZ0Isc0JBQXNCNUI7SUFDMUI3RixZQUFZNkMsS0FBSyxDQUFFO1FBQ2pCLE1BQU0sRUFDSnRRLEtBQUssRUFDTixHQUFHc1EsT0FBTyx1RUFBdUU7UUFDbEYsOERBQThEO1FBRTlELE1BQU1rRCxpQkFBaUJyVixvRUFBZ0JBLENBQUM2QixNQUFNb0csTUFBTTtRQUNwRCxLQUFLLENBQUNrSyxPQUFPaUQsUUFBUUM7SUFDdkI7QUFFRjtBQUNBMEIsY0FBY3JDLFVBQVUsR0FBRztJQUFDO1FBQzFCdEUsV0FBVztRQUNYQyxTQUFTLENBQUMxTyxNQUFNYTtZQUNkLElBQUksRUFDRm9TLGFBQWEvUyxLQUFLLEVBQ25CLEdBQUdGO1lBQ0osSUFBSSxFQUNGZ1QsWUFBWSxFQUNiLEdBQUduUztZQUVKLElBQUksQ0FBQ1gsTUFBTW1WLFNBQVMsSUFBSW5WLE1BQU1vVixNQUFNLEtBQUssR0FBRztnQkFDMUMsT0FBTztZQUNUO1lBRUF0QyxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7Z0JBQzNDOVM7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixNQUFNcVYsV0FBVztJQUNmcEIsTUFBTTtRQUNKQyxNQUFNO0lBQ1I7SUFDQXRFLEtBQUs7UUFDSHNFLE1BQU07SUFDUjtBQUNGO0FBQ0EsSUFBSW9CO0FBRUgsVUFBVUEsV0FBVztJQUNwQkEsV0FBVyxDQUFDQSxXQUFXLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztBQUMvQyxHQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDO0FBRWxDLE1BQU1DLG9CQUFvQmpDO0lBQ3hCN0YsWUFBWTZDLEtBQUssQ0FBRTtRQUNqQixLQUFLLENBQUNBLE9BQU8rRSxVQUFVbFgsb0VBQWdCQSxDQUFDbVMsTUFBTXRRLEtBQUssQ0FBQ29HLE1BQU07SUFDNUQ7QUFFRjtBQUNBbVAsWUFBWTFDLFVBQVUsR0FBRztJQUFDO1FBQ3hCdEUsV0FBVztRQUNYQyxTQUFTLENBQUMxTyxNQUFNYTtZQUNkLElBQUksRUFDRm9TLGFBQWEvUyxLQUFLLEVBQ25CLEdBQUdGO1lBQ0osSUFBSSxFQUNGZ1QsWUFBWSxFQUNiLEdBQUduUztZQUVKLElBQUlYLE1BQU1vVixNQUFNLEtBQUtFLFlBQVlFLFVBQVUsRUFBRTtnQkFDM0MsT0FBTztZQUNUO1lBRUExQyxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7Z0JBQzNDOVM7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixNQUFNeVYsV0FBVztJQUNmeEIsTUFBTTtRQUNKQyxNQUFNO0lBQ1I7SUFDQXRFLEtBQUs7UUFDSHNFLE1BQU07SUFDUjtBQUNGO0FBQ0EsTUFBTXdCLG9CQUFvQnBDO0lBQ3hCN0YsWUFBWTZDLEtBQUssQ0FBRTtRQUNqQixLQUFLLENBQUNBLE9BQU9tRjtJQUNmO0lBRUEsT0FBT0UsUUFBUTtRQUNiLHFFQUFxRTtRQUNyRSx1RUFBdUU7UUFDdkUsNkRBQTZEO1FBQzdEakwsT0FBT2dFLGdCQUFnQixDQUFDK0csU0FBU3hCLElBQUksQ0FBQ0MsSUFBSSxFQUFFL1IsTUFBTTtZQUNoRHNTLFNBQVM7WUFDVE4sU0FBUztRQUNYO1FBQ0EsT0FBTyxTQUFTeUI7WUFDZGxMLE9BQU80RCxtQkFBbUIsQ0FBQ21ILFNBQVN4QixJQUFJLENBQUNDLElBQUksRUFBRS9SO1FBQ2pELEdBQUcsMEVBQTBFO1FBQzdFLDRFQUE0RTtRQUU1RSxTQUFTQSxRQUFRO0lBQ25CO0FBRUY7QUFDQXVULFlBQVk3QyxVQUFVLEdBQUc7SUFBQztRQUN4QnRFLFdBQVc7UUFDWEMsU0FBUyxDQUFDMU8sTUFBTWE7WUFDZCxJQUFJLEVBQ0ZvUyxhQUFhL1MsS0FBSyxFQUNuQixHQUFHRjtZQUNKLElBQUksRUFDRmdULFlBQVksRUFDYixHQUFHblM7WUFDSixNQUFNLEVBQ0prVixPQUFPLEVBQ1IsR0FBRzdWO1lBRUosSUFBSTZWLFFBQVFuVCxNQUFNLEdBQUcsR0FBRztnQkFDdEIsT0FBTztZQUNUO1lBRUFvUSxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7Z0JBQzNDOVM7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixJQUFJOFY7QUFFSCxVQUFVQSxtQkFBbUI7SUFDNUJBLG1CQUFtQixDQUFDQSxtQkFBbUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzFEQSxtQkFBbUIsQ0FBQ0EsbUJBQW1CLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0FBQ2xFLEdBQUdBLHVCQUF3QkEsQ0FBQUEsc0JBQXNCLENBQUM7QUFFbEQsSUFBSUM7QUFFSCxVQUFVQSxjQUFjO0lBQ3ZCQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7QUFDNUQsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUV4QyxTQUFTQyxnQkFBZ0JsVyxJQUFJO0lBQzNCLElBQUksRUFDRndNLFlBQVksRUFDWjBHLFlBQVk4QyxvQkFBb0JHLE9BQU8sRUFDdkNDLFNBQVMsRUFDVEMsWUFBWSxFQUNaQyxPQUFPLEVBQ1BDLFdBQVcsQ0FBQyxFQUNaQyxRQUFRUCxlQUFlUSxTQUFTLEVBQ2hDdFAsa0JBQWtCLEVBQ2xCK0YsbUJBQW1CLEVBQ25Cd0osdUJBQXVCLEVBQ3ZCMUgsS0FBSyxFQUNMcEMsU0FBUyxFQUNWLEdBQUc1TTtJQUNKLE1BQU0yVyxlQUFlQyxnQkFBZ0I7UUFDbkM1SDtRQUNBNkgsVUFBVSxDQUFDUDtJQUNiO0lBQ0EsTUFBTSxDQUFDUSx1QkFBdUJDLHdCQUF3QixHQUFHclksK0RBQVdBO0lBQ3BFLE1BQU1zWSxjQUFjM1osNkNBQU1BLENBQUM7UUFDekIrRixHQUFHO1FBQ0hDLEdBQUc7SUFDTDtJQUNBLE1BQU00VCxrQkFBa0I1Wiw2Q0FBTUEsQ0FBQztRQUM3QitGLEdBQUc7UUFDSEMsR0FBRztJQUNMO0lBQ0EsTUFBTVEsT0FBT3pHLDhDQUFPQSxDQUFDO1FBQ25CLE9BQVE4VjtZQUNOLEtBQUs4QyxvQkFBb0JHLE9BQU87Z0JBQzlCLE9BQU9oUCxxQkFBcUI7b0JBQzFCakQsS0FBS2lELG1CQUFtQjlELENBQUM7b0JBQ3pCcUQsUUFBUVMsbUJBQW1COUQsQ0FBQztvQkFDNUJXLE1BQU1tRCxtQkFBbUIvRCxDQUFDO29CQUMxQm9ELE9BQU9XLG1CQUFtQi9ELENBQUM7Z0JBQzdCLElBQUk7WUFFTixLQUFLNFMsb0JBQW9Ca0IsYUFBYTtnQkFDcEMsT0FBT2I7UUFDWDtJQUNGLEdBQUc7UUFBQ25EO1FBQVdtRDtRQUFjbFA7S0FBbUI7SUFDaEQsTUFBTWdRLHFCQUFxQjlaLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU0rWixhQUFhamEsa0RBQVdBLENBQUM7UUFDN0IsTUFBTW1QLGtCQUFrQjZLLG1CQUFtQjVGLE9BQU87UUFFbEQsSUFBSSxDQUFDakYsaUJBQWlCO1lBQ3BCO1FBQ0Y7UUFFQSxNQUFNdkIsYUFBYWlNLFlBQVl6RixPQUFPLENBQUNuTyxDQUFDLEdBQUc2VCxnQkFBZ0IxRixPQUFPLENBQUNuTyxDQUFDO1FBQ3BFLE1BQU04SCxZQUFZOEwsWUFBWXpGLE9BQU8sQ0FBQ2xPLENBQUMsR0FBRzRULGdCQUFnQjFGLE9BQU8sQ0FBQ2xPLENBQUM7UUFDbkVpSixnQkFBZ0JrRyxRQUFRLENBQUN6SCxZQUFZRztJQUN2QyxHQUFHLEVBQUU7SUFDTCxNQUFNbU0sNEJBQTRCamEsOENBQU9BLENBQUMsSUFBTW9aLFVBQVVQLGVBQWVRLFNBQVMsR0FBRztlQUFJdko7U0FBb0IsQ0FBQ29LLE9BQU8sS0FBS3BLLHFCQUFxQjtRQUFDc0o7UUFBT3RKO0tBQW9CO0lBQzNLalEsZ0RBQVNBLENBQUM7UUFDUixJQUFJLENBQUNxWixXQUFXLENBQUNwSixvQkFBb0J0SyxNQUFNLElBQUksQ0FBQ2lCLE1BQU07WUFDcERrVDtZQUNBO1FBQ0Y7UUFFQSxLQUFLLE1BQU16SyxtQkFBbUIrSywwQkFBMkI7WUFDdkQsSUFBSSxDQUFDakIsYUFBYSxPQUFPLEtBQUssSUFBSUEsVUFBVTlKLGdCQUFlLE1BQU8sT0FBTztnQkFDdkU7WUFDRjtZQUVBLE1BQU10RyxRQUFRa0gsb0JBQW9CdEUsT0FBTyxDQUFDMEQ7WUFDMUMsTUFBTUMsc0JBQXNCbUssdUJBQXVCLENBQUMxUSxNQUFNO1lBRTFELElBQUksQ0FBQ3VHLHFCQUFxQjtnQkFDeEI7WUFDRjtZQUVBLE1BQU0sRUFDSkcsU0FBUyxFQUNUQyxLQUFLLEVBQ04sR0FBR04sMkJBQTJCQyxpQkFBaUJDLHFCQUFxQjFJLE1BQU0ySSxjQUFjSTtZQUV6RixLQUFLLE1BQU1pQixRQUFRO2dCQUFDO2dCQUFLO2FBQUksQ0FBRTtnQkFDN0IsSUFBSSxDQUFDOEksWUFBWSxDQUFDOUksS0FBSyxDQUFDbkIsU0FBUyxDQUFDbUIsS0FBSyxDQUFDLEVBQUU7b0JBQ3hDbEIsS0FBSyxDQUFDa0IsS0FBSyxHQUFHO29CQUNkbkIsU0FBUyxDQUFDbUIsS0FBSyxHQUFHO2dCQUNwQjtZQUNGO1lBRUEsSUFBSWxCLE1BQU12SixDQUFDLEdBQUcsS0FBS3VKLE1BQU10SixDQUFDLEdBQUcsR0FBRztnQkFDOUIwVDtnQkFDQUksbUJBQW1CNUYsT0FBTyxHQUFHakY7Z0JBQzdCd0ssc0JBQXNCTSxZQUFZYjtnQkFDbENTLFlBQVl6RixPQUFPLEdBQUc1RTtnQkFDdEJzSyxnQkFBZ0IxRixPQUFPLEdBQUc3RTtnQkFDMUI7WUFDRjtRQUNGO1FBRUFzSyxZQUFZekYsT0FBTyxHQUFHO1lBQ3BCbk8sR0FBRztZQUNIQyxHQUFHO1FBQ0w7UUFDQTRULGdCQUFnQjFGLE9BQU8sR0FBRztZQUN4Qm5PLEdBQUc7WUFDSEMsR0FBRztRQUNMO1FBQ0EwVDtJQUNGLEdBQ0E7UUFBQ3ZLO1FBQWM0SztRQUFZaEI7UUFBV1c7UUFBeUJUO1FBQVNDO1FBQ3hFZ0IsS0FBS0MsU0FBUyxDQUFDM1Q7UUFDZjBULEtBQUtDLFNBQVMsQ0FBQ2I7UUFBZUc7UUFBdUI1SjtRQUFxQm1LO1FBQTJCWDtRQUNyR2EsS0FBS0MsU0FBUyxDQUFDNUs7S0FBVztBQUM1QjtBQUNBLE1BQU02SyxzQkFBc0I7SUFDMUJyVSxHQUFHO1FBQ0QsQ0FBQ2dJLFVBQVV5QixRQUFRLENBQUMsRUFBRTtRQUN0QixDQUFDekIsVUFBVTJCLE9BQU8sQ0FBQyxFQUFFO0lBQ3ZCO0lBQ0ExSixHQUFHO1FBQ0QsQ0FBQytILFVBQVV5QixRQUFRLENBQUMsRUFBRTtRQUN0QixDQUFDekIsVUFBVTJCLE9BQU8sQ0FBQyxFQUFFO0lBQ3ZCO0FBQ0Y7QUFFQSxTQUFTNkosZ0JBQWdCL1YsS0FBSztJQUM1QixJQUFJLEVBQ0ZtTyxLQUFLLEVBQ0w2SCxRQUFRLEVBQ1QsR0FBR2hXO0lBQ0osTUFBTTZXLGdCQUFnQi9ZLCtEQUFXQSxDQUFDcVE7SUFDbEMsT0FBT3ZRLCtEQUFXQSxDQUFDa1osQ0FBQUE7UUFDakIsSUFBSWQsWUFBWSxDQUFDYSxpQkFBaUIsQ0FBQ0MsZ0JBQWdCO1lBQ2pELCtEQUErRDtZQUMvRCxPQUFPRjtRQUNUO1FBRUEsTUFBTS9LLFlBQVk7WUFDaEJ0SixHQUFHSyxLQUFLbVUsSUFBSSxDQUFDNUksTUFBTTVMLENBQUMsR0FBR3NVLGNBQWN0VSxDQUFDO1lBQ3RDQyxHQUFHSSxLQUFLbVUsSUFBSSxDQUFDNUksTUFBTTNMLENBQUMsR0FBR3FVLGNBQWNyVSxDQUFDO1FBQ3hDLEdBQUcsMEVBQTBFO1FBRTdFLE9BQU87WUFDTEQsR0FBRztnQkFDRCxDQUFDZ0ksVUFBVXlCLFFBQVEsQ0FBQyxFQUFFOEssZUFBZXZVLENBQUMsQ0FBQ2dJLFVBQVV5QixRQUFRLENBQUMsSUFBSUgsVUFBVXRKLENBQUMsS0FBSyxDQUFDO2dCQUMvRSxDQUFDZ0ksVUFBVTJCLE9BQU8sQ0FBQyxFQUFFNEssZUFBZXZVLENBQUMsQ0FBQ2dJLFVBQVUyQixPQUFPLENBQUMsSUFBSUwsVUFBVXRKLENBQUMsS0FBSztZQUM5RTtZQUNBQyxHQUFHO2dCQUNELENBQUMrSCxVQUFVeUIsUUFBUSxDQUFDLEVBQUU4SyxlQUFldFUsQ0FBQyxDQUFDK0gsVUFBVXlCLFFBQVEsQ0FBQyxJQUFJSCxVQUFVckosQ0FBQyxLQUFLLENBQUM7Z0JBQy9FLENBQUMrSCxVQUFVMkIsT0FBTyxDQUFDLEVBQUU0SyxlQUFldFUsQ0FBQyxDQUFDK0gsVUFBVTJCLE9BQU8sQ0FBQyxJQUFJTCxVQUFVckosQ0FBQyxLQUFLO1lBQzlFO1FBQ0Y7SUFDRixHQUFHO1FBQUN3VDtRQUFVN0g7UUFBTzBJO0tBQWM7QUFDckM7QUFFQSxTQUFTRyxjQUFjQyxjQUFjLEVBQUVuWCxFQUFFO0lBQ3ZDLE1BQU1vWCxnQkFBZ0JwWCxPQUFPLE9BQU9tWCxlQUFlelMsR0FBRyxDQUFDMUUsTUFBTTJQO0lBQzdELE1BQU01RyxPQUFPcU8sZ0JBQWdCQSxjQUFjck8sSUFBSSxDQUFDNkgsT0FBTyxHQUFHO0lBQzFELE9BQU85UywrREFBV0EsQ0FBQ3VaLENBQUFBO1FBQ2pCLElBQUloWTtRQUVKLElBQUlXLE9BQU8sTUFBTTtZQUNmLE9BQU87UUFDVCxFQUFFLCtEQUErRDtRQUNqRSwrREFBK0Q7UUFDL0Qsc0RBQXNEO1FBR3RELE9BQU8sQ0FBQ1gsT0FBTzBKLFFBQVEsT0FBT0EsT0FBT3NPLFVBQVMsS0FBTSxPQUFPaFksT0FBTztJQUNwRSxHQUFHO1FBQUMwSjtRQUFNL0k7S0FBRztBQUNmO0FBRUEsU0FBU3NYLHFCQUFxQnBWLE9BQU8sRUFBRXFWLG1CQUFtQjtJQUN4RCxPQUFPOWEsOENBQU9BLENBQUMsSUFBTXlGLFFBQVFnRCxNQUFNLENBQUMsQ0FBQ0MsYUFBYXZEO1lBQ2hELE1BQU0sRUFDSkEsUUFBUTRWLE1BQU0sRUFDZixHQUFHNVY7WUFDSixNQUFNNlYsbUJBQW1CRCxPQUFPcEYsVUFBVSxDQUFDc0YsR0FBRyxDQUFDbkYsQ0FBQUEsWUFBYztvQkFDM0R6RSxXQUFXeUUsVUFBVXpFLFNBQVM7b0JBQzlCQyxTQUFTd0osb0JBQW9CaEYsVUFBVXhFLE9BQU8sRUFBRW5NO2dCQUNsRDtZQUNBLE9BQU87bUJBQUl1RDttQkFBZ0JzUzthQUFpQjtRQUM5QyxHQUFHLEVBQUUsR0FBRztRQUFDdlY7UUFBU3FWO0tBQW9CO0FBQ3hDO0FBRUEsSUFBSUk7QUFFSCxVQUFVQSxpQkFBaUI7SUFDMUJBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxHQUFHO0lBQzdEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsZ0JBQWdCLEdBQUcsRUFBRSxHQUFHO0FBQzlELEdBQUdBLHFCQUFzQkEsQ0FBQUEsb0JBQW9CLENBQUM7QUFFOUMsSUFBSUM7QUFFSCxVQUFVQSxrQkFBa0I7SUFDM0JBLGtCQUFrQixDQUFDLFlBQVksR0FBRztBQUNwQyxHQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDO0FBRWhELE1BQU1DLGVBQWUsV0FBVyxHQUFFLElBQUlDO0FBQ3RDLFNBQVNDLHNCQUFzQkMsVUFBVSxFQUFFM1ksSUFBSTtJQUM3QyxJQUFJLEVBQ0Y0WSxRQUFRLEVBQ1JDLFlBQVksRUFDWkMsTUFBTSxFQUNQLEdBQUc5WTtJQUNKLE1BQU0sQ0FBQytZLE9BQU9DLFNBQVMsR0FBRzliLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sRUFDSitiLFNBQVMsRUFDVDNMLE9BQU8sRUFDUDRMLFFBQVEsRUFDVCxHQUFHSjtJQUNKLE1BQU1LLGdCQUFnQjliLDZDQUFNQSxDQUFDc2I7SUFDN0IsTUFBTTlCLFdBQVd1QztJQUNqQixNQUFNQyxjQUFjemEsa0VBQWNBLENBQUNpWTtJQUNuQyxNQUFNeUMsNkJBQTZCbmMsa0RBQVdBLENBQUMsU0FBVW9jLEdBQUc7UUFDMUQsSUFBSUEsUUFBUSxLQUFLLEdBQUc7WUFDbEJBLE1BQU0sRUFBRTtRQUNWO1FBRUEsSUFBSUYsWUFBWTlILE9BQU8sRUFBRTtZQUN2QjtRQUNGO1FBRUF5SCxTQUFTN1csQ0FBQUE7WUFDUCxJQUFJQSxVQUFVLE1BQU07Z0JBQ2xCLE9BQU9vWDtZQUNUO1lBRUEsT0FBT3BYLE1BQU1xWCxNQUFNLENBQUNELElBQUl2VyxNQUFNLENBQUNyQyxDQUFBQSxLQUFNLENBQUN3QixNQUFNb0ksUUFBUSxDQUFDNUo7UUFDdkQ7SUFDRixHQUFHO1FBQUMwWTtLQUFZO0lBQ2hCLE1BQU12RixZQUFZelcsNkNBQU1BLENBQUM7SUFDekIsTUFBTTRILGlCQUFpQnhHLCtEQUFXQSxDQUFDZ2IsQ0FBQUE7UUFDakMsSUFBSTVDLFlBQVksQ0FBQytCLFVBQVU7WUFDekIsT0FBT0o7UUFDVDtRQUVBLElBQUksQ0FBQ2lCLGlCQUFpQkEsa0JBQWtCakIsZ0JBQWdCVyxjQUFjNUgsT0FBTyxLQUFLb0gsY0FBY0ksU0FBUyxNQUFNO1lBQzdHLE1BQU1WLE1BQU0sSUFBSUk7WUFFaEIsS0FBSyxJQUFJcFgsYUFBYXNYLFdBQVk7Z0JBQ2hDLElBQUksQ0FBQ3RYLFdBQVc7b0JBQ2Q7Z0JBQ0Y7Z0JBRUEsSUFBSTBYLFNBQVNBLE1BQU1uVyxNQUFNLEdBQUcsS0FBSyxDQUFDbVcsTUFBTXhPLFFBQVEsQ0FBQ2xKLFVBQVVWLEVBQUUsS0FBS1UsVUFBVXdDLElBQUksQ0FBQzBOLE9BQU8sRUFBRTtvQkFDeEYsaURBQWlEO29CQUNqRDhHLElBQUlxQixHQUFHLENBQUNyWSxVQUFVVixFQUFFLEVBQUVVLFVBQVV3QyxJQUFJLENBQUMwTixPQUFPO29CQUM1QztnQkFDRjtnQkFFQSxNQUFNN0gsT0FBT3JJLFVBQVVxSSxJQUFJLENBQUM2SCxPQUFPO2dCQUNuQyxNQUFNMU4sT0FBTzZGLE9BQU8sSUFBSWdFLEtBQUtKLFFBQVE1RCxPQUFPQSxRQUFRO2dCQUNwRHJJLFVBQVV3QyxJQUFJLENBQUMwTixPQUFPLEdBQUcxTjtnQkFFekIsSUFBSUEsTUFBTTtvQkFDUndVLElBQUlxQixHQUFHLENBQUNyWSxVQUFVVixFQUFFLEVBQUVrRDtnQkFDeEI7WUFDRjtZQUVBLE9BQU93VTtRQUNUO1FBRUEsT0FBT29CO0lBQ1QsR0FBRztRQUFDZDtRQUFZSTtRQUFPSDtRQUFVL0I7UUFBVXZKO0tBQVE7SUFDbkRyUSxnREFBU0EsQ0FBQztRQUNSa2MsY0FBYzVILE9BQU8sR0FBR29IO0lBQzFCLEdBQUc7UUFBQ0E7S0FBVztJQUNmMWIsZ0RBQVNBLENBQUM7UUFDUixJQUFJNFosVUFBVTtZQUNaO1FBQ0Y7UUFFQXlDO0lBQ0YsR0FDQTtRQUFDVjtRQUFVL0I7S0FBUztJQUNwQjVaLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSThiLFNBQVNBLE1BQU1uVyxNQUFNLEdBQUcsR0FBRztZQUM3Qm9XLFNBQVM7UUFDWDtJQUNGLEdBQ0E7UUFBQ3pCLEtBQUtDLFNBQVMsQ0FBQ3VCO0tBQU87SUFDdkI5YixnREFBU0EsQ0FBQztRQUNSLElBQUk0WixZQUFZLE9BQU9vQyxjQUFjLFlBQVluRixVQUFVdkMsT0FBTyxLQUFLLE1BQU07WUFDM0U7UUFDRjtRQUVBdUMsVUFBVXZDLE9BQU8sR0FBR0osV0FBVztZQUM3Qm1JO1lBQ0F4RixVQUFVdkMsT0FBTyxHQUFHO1FBQ3RCLEdBQUcwSDtJQUNMLEdBQ0E7UUFBQ0E7UUFBV3BDO1FBQVV5QztXQUErQlQ7S0FBYTtJQUNsRSxPQUFPO1FBQ0w1VDtRQUNBcVU7UUFDQUssb0JBQW9CWixTQUFTO0lBQy9CO0lBRUEsU0FBU0s7UUFDUCxPQUFRRjtZQUNOLEtBQUtaLGtCQUFrQnNCLE1BQU07Z0JBQzNCLE9BQU87WUFFVCxLQUFLdEIsa0JBQWtCdUIsY0FBYztnQkFDbkMsT0FBT2pCO1lBRVQ7Z0JBQ0UsT0FBTyxDQUFDQTtRQUNaO0lBQ0Y7QUFDRjtBQUVBLFNBQVNrQixnQkFBZ0IzWCxLQUFLLEVBQUU0WCxTQUFTO0lBQ3ZDLE9BQU90YiwrREFBV0EsQ0FBQ2diLENBQUFBO1FBQ2pCLElBQUksQ0FBQ3RYLE9BQU87WUFDVixPQUFPO1FBQ1Q7UUFFQSxJQUFJc1gsZUFBZTtZQUNqQixPQUFPQTtRQUNUO1FBRUEsT0FBTyxPQUFPTSxjQUFjLGFBQWFBLFVBQVU1WCxTQUFTQTtJQUM5RCxHQUFHO1FBQUM0WDtRQUFXNVg7S0FBTTtBQUN2QjtBQUVBLFNBQVM2WCxlQUFldFEsSUFBSSxFQUFFNEQsT0FBTztJQUNuQyxPQUFPd00sZ0JBQWdCcFEsTUFBTTREO0FBQy9CO0FBRUE7OztDQUdDLEdBRUQsU0FBUzJNLG9CQUFvQmphLElBQUk7SUFDL0IsSUFBSSxFQUNGa2EsUUFBUSxFQUNSckQsUUFBUSxFQUNULEdBQUc3VztJQUNKLE1BQU1tYSxrQkFBa0J0Yiw0REFBUUEsQ0FBQ3FiO0lBQ2pDLE1BQU1FLG1CQUFtQmhkLDhDQUFPQSxDQUFDO1FBQy9CLElBQUl5WixZQUFZLGdCQUFrQixlQUFlLENBQW1DLEVBQWE7WUFDL0YsT0FBT3ZHO1FBQ1Q7UUFFQSxNQUFNLEVBQ0orSixnQkFBZ0IsRUFDakIsR0FBR3pQO1FBQ0osT0FBTyxJQUFJeVAsaUJBQWlCRjtJQUM5QixHQUFHO1FBQUNBO1FBQWlCdEQ7S0FBUztJQUM5QjVaLGdEQUFTQSxDQUFDO1FBQ1IsT0FBTyxJQUFNbWQsb0JBQW9CLE9BQU8sS0FBSyxJQUFJQSxpQkFBaUJFLFVBQVU7SUFDOUUsR0FBRztRQUFDRjtLQUFpQjtJQUNyQixPQUFPQTtBQUNUO0FBRUE7OztDQUdDLEdBRUQsU0FBU0csa0JBQWtCdmEsSUFBSTtJQUM3QixJQUFJLEVBQ0ZrYSxRQUFRLEVBQ1JyRCxRQUFRLEVBQ1QsR0FBRzdXO0lBQ0osTUFBTXdhLGVBQWUzYiw0REFBUUEsQ0FBQ3FiO0lBQzlCLE1BQU1PLGlCQUFpQnJkLDhDQUFPQSxDQUFDO1FBQzdCLElBQUl5WixZQUFZLGdCQUFrQixlQUFlLENBQWlDLEVBQWE7WUFDN0YsT0FBT3ZHO1FBQ1Q7UUFFQSxNQUFNLEVBQ0pvSyxjQUFjLEVBQ2YsR0FBRzlQO1FBQ0osT0FBTyxJQUFJOFAsZUFBZUY7SUFDNUIsR0FDQTtRQUFDM0Q7S0FBUztJQUNWNVosZ0RBQVNBLENBQUM7UUFDUixPQUFPLElBQU13ZCxrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVILFVBQVU7SUFDMUUsR0FBRztRQUFDRztLQUFlO0lBQ25CLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTRSxlQUFlelIsT0FBTztJQUM3QixPQUFPLElBQUl3RSxLQUFLekUsY0FBY0MsVUFBVUE7QUFDMUM7QUFFQSxTQUFTMFIsUUFBUTFSLE9BQU8sRUFBRW9FLE9BQU8sRUFBRXVOLFlBQVk7SUFDN0MsSUFBSXZOLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVcU47SUFDWjtJQUVBLE1BQU0sQ0FBQzlXLE1BQU1pWCxZQUFZLEdBQUd4ZCxpREFBVUEsQ0FBQ3lkLFNBQVM7SUFDaEQsTUFBTVgsbUJBQW1CSCxvQkFBb0I7UUFDM0NDLFVBQVNjLE9BQU87WUFDZCxJQUFJLENBQUM5UixTQUFTO2dCQUNaO1lBQ0Y7WUFFQSxLQUFLLE1BQU0rUixVQUFVRCxRQUFTO2dCQUM1QixNQUFNLEVBQ0ovYSxJQUFJLEVBQ0pxRyxNQUFNLEVBQ1AsR0FBRzJVO2dCQUVKLElBQUloYixTQUFTLGVBQWVxRyxrQkFBa0I0VSxlQUFlNVUsT0FBTzZVLFFBQVEsQ0FBQ2pTLFVBQVU7b0JBQ3JGNFI7b0JBQ0E7Z0JBQ0Y7WUFDRjtRQUNGO0lBRUY7SUFDQSxNQUFNTCxpQkFBaUJGLGtCQUFrQjtRQUN2Q0wsVUFBVVk7SUFDWjtJQUNBaGMsNkVBQXlCQSxDQUFDO1FBQ3hCZ2M7UUFFQSxJQUFJNVIsU0FBUztZQUNYdVIsa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlVyxPQUFPLENBQUNsUztZQUN6RGtSLG9CQUFvQixPQUFPLEtBQUssSUFBSUEsaUJBQWlCZ0IsT0FBTyxDQUFDOVAsU0FBUytQLElBQUksRUFBRTtnQkFDMUVDLFdBQVc7Z0JBQ1hDLFNBQVM7WUFDWDtRQUNGLE9BQU87WUFDTGQsa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlSCxVQUFVO1lBQzNERixvQkFBb0IsT0FBTyxLQUFLLElBQUlBLGlCQUFpQkUsVUFBVTtRQUNqRTtJQUNGLEdBQUc7UUFBQ3BSO0tBQVE7SUFDWixPQUFPckY7SUFFUCxTQUFTa1gsUUFBUVMsV0FBVztRQUMxQixJQUFJLENBQUN0UyxTQUFTO1lBQ1osT0FBTztRQUNUO1FBRUEsSUFBSUEsUUFBUXVTLFdBQVcsS0FBSyxPQUFPO1lBQ2pDLElBQUl6YjtZQUVKLHVEQUF1RDtZQUN2RCxrQ0FBa0M7WUFDbEMsT0FBTyxDQUFDQSxPQUFPd2IsZUFBZSxPQUFPQSxjQUFjWCxZQUFXLEtBQU0sT0FBTzdhLE9BQU87UUFDcEY7UUFFQSxNQUFNMGIsVUFBVXBPLFFBQVFwRTtRQUV4QixJQUFJcU8sS0FBS0MsU0FBUyxDQUFDZ0UsaUJBQWlCakUsS0FBS0MsU0FBUyxDQUFDa0UsVUFBVTtZQUMzRCxPQUFPRjtRQUNUO1FBRUEsT0FBT0U7SUFDVDtBQUNGO0FBRUEsU0FBU0MsYUFBYTlYLElBQUk7SUFDeEIsTUFBTStYLGNBQWM5QixnQkFBZ0JqVztJQUNwQyxPQUFPNkQsYUFBYTdELE1BQU0rWDtBQUM1QjtBQUVBLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLFNBQVNDLHVCQUF1QnBTLElBQUk7SUFDbEMsTUFBTXFTLGVBQWUxZSw2Q0FBTUEsQ0FBQ3FNO0lBQzVCLE1BQU1zUyxZQUFZdmQsK0RBQVdBLENBQUNnYixDQUFBQTtRQUM1QixJQUFJLENBQUMvUCxNQUFNO1lBQ1QsT0FBT21TO1FBQ1Q7UUFFQSxJQUFJcEMsaUJBQWlCQSxrQkFBa0JvQyxrQkFBa0JuUyxRQUFRcVMsYUFBYXhLLE9BQU8sSUFBSTdILEtBQUtjLFVBQVUsS0FBS3VSLGFBQWF4SyxPQUFPLENBQUMvRyxVQUFVLEVBQUU7WUFDNUksT0FBT2lQO1FBQ1Q7UUFFQSxPQUFPdlAsdUJBQXVCUjtJQUNoQyxHQUFHO1FBQUNBO0tBQUs7SUFDVHpNLGdEQUFTQSxDQUFDO1FBQ1I4ZSxhQUFheEssT0FBTyxHQUFHN0g7SUFDekIsR0FBRztRQUFDQTtLQUFLO0lBQ1QsT0FBT3NTO0FBQ1Q7QUFFQSxTQUFTQyxpQkFBaUJDLFFBQVE7SUFDaEMsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHbGYsK0NBQVFBLENBQUM7SUFDM0QsTUFBTW1mLGVBQWVoZiw2Q0FBTUEsQ0FBQzZlLFdBQVcsNENBQTRDO0lBRW5GLE1BQU1JLGVBQWVuZixrREFBV0EsQ0FBQytDLENBQUFBO1FBQy9CLE1BQU1vSyxtQkFBbUJLLHFCQUFxQnpLLE1BQU1vRyxNQUFNO1FBRTFELElBQUksQ0FBQ2dFLGtCQUFrQjtZQUNyQjtRQUNGO1FBRUE4UixxQkFBcUJELENBQUFBO1lBQ25CLElBQUksQ0FBQ0EsbUJBQW1CO2dCQUN0QixPQUFPO1lBQ1Q7WUFFQUEsa0JBQWtCekMsR0FBRyxDQUFDcFAsa0JBQWtCYSxxQkFBcUJiO1lBQzdELE9BQU8sSUFBSW1PLElBQUkwRDtRQUNqQjtJQUNGLEdBQUcsRUFBRTtJQUNMbGYsZ0RBQVNBLENBQUM7UUFDUixNQUFNc2YsbUJBQW1CRixhQUFhOUssT0FBTztRQUU3QyxJQUFJMkssYUFBYUssa0JBQWtCO1lBQ2pDQyxRQUFRRDtZQUNSLE1BQU1FLFVBQVVQLFNBQVM3RCxHQUFHLENBQUNuUCxDQUFBQTtnQkFDM0IsTUFBTXdULG9CQUFvQi9SLHFCQUFxQnpCO2dCQUUvQyxJQUFJd1QsbUJBQW1CO29CQUNyQkEsa0JBQWtCOU4sZ0JBQWdCLENBQUMsVUFBVTBOLGNBQWM7d0JBQ3pEakksU0FBUztvQkFDWDtvQkFDQSxPQUFPO3dCQUFDcUk7d0JBQW1CdlIscUJBQXFCdVI7cUJBQW1CO2dCQUNyRTtnQkFFQSxPQUFPO1lBQ1QsR0FBRzFaLE1BQU0sQ0FBQ3FELENBQUFBLFFBQVNBLFNBQVM7WUFDNUIrVixxQkFBcUJLLFFBQVE3WixNQUFNLEdBQUcsSUFBSTZWLElBQUlnRSxXQUFXO1lBQ3pESixhQUFhOUssT0FBTyxHQUFHMks7UUFDekI7UUFFQSxPQUFPO1lBQ0xNLFFBQVFOO1lBQ1JNLFFBQVFEO1FBQ1Y7UUFFQSxTQUFTQyxRQUFRTixRQUFRO1lBQ3ZCQSxTQUFTL2IsT0FBTyxDQUFDK0ksQ0FBQUE7Z0JBQ2YsTUFBTXdULG9CQUFvQi9SLHFCQUFxQnpCO2dCQUMvQ3dULHFCQUFxQixPQUFPLEtBQUssSUFBSUEsa0JBQWtCbE8sbUJBQW1CLENBQUMsVUFBVThOO1lBQ3ZGO1FBQ0Y7SUFDRixHQUFHO1FBQUNBO1FBQWNKO0tBQVM7SUFDM0IsT0FBTzllLDhDQUFPQSxDQUFDO1FBQ2IsSUFBSThlLFNBQVN0WixNQUFNLEVBQUU7WUFDbkIsT0FBT3VaLG9CQUFvQnJaLE1BQU02WixJQUFJLENBQUNSLGtCQUFrQlMsTUFBTSxJQUFJL1csTUFBTSxDQUFDLENBQUNrQyxLQUFLMkssY0FBZ0JwVSx1REFBR0EsQ0FBQ3lKLEtBQUsySyxjQUFjelAsc0JBQXNCZ0ssaUJBQWlCaVA7UUFDL0o7UUFFQSxPQUFPalo7SUFDVCxHQUFHO1FBQUNpWjtRQUFVQztLQUFrQjtBQUNsQztBQUVBLFNBQVNVLHNCQUFzQmpQLGFBQWEsRUFBRWlMLFlBQVk7SUFDeEQsSUFBSUEsaUJBQWlCLEtBQUssR0FBRztRQUMzQkEsZUFBZSxFQUFFO0lBQ25CO0lBRUEsTUFBTWlFLHVCQUF1QnpmLDZDQUFNQSxDQUFDO0lBQ3BDSixnREFBU0EsQ0FBQztRQUNSNmYscUJBQXFCdkwsT0FBTyxHQUFHO0lBQ2pDLEdBQ0FzSDtJQUNBNWIsZ0RBQVNBLENBQUM7UUFDUixNQUFNOGYsbUJBQW1CblAsa0JBQWtCM0s7UUFFM0MsSUFBSThaLG9CQUFvQixDQUFDRCxxQkFBcUJ2TCxPQUFPLEVBQUU7WUFDckR1TCxxQkFBcUJ2TCxPQUFPLEdBQUczRDtRQUNqQztRQUVBLElBQUksQ0FBQ21QLG9CQUFvQkQscUJBQXFCdkwsT0FBTyxFQUFFO1lBQ3JEdUwscUJBQXFCdkwsT0FBTyxHQUFHO1FBQ2pDO0lBQ0YsR0FBRztRQUFDM0Q7S0FBYztJQUNsQixPQUFPa1AscUJBQXFCdkwsT0FBTyxHQUFHL1MsNERBQVFBLENBQUNvUCxlQUFla1AscUJBQXFCdkwsT0FBTyxJQUFJdE87QUFDaEc7QUFFQSxTQUFTK1osZUFBZW5hLE9BQU87SUFDN0I1RixnREFBU0EsQ0FBQztRQUNSLElBQUksQ0FBQ2lCLHlEQUFTQSxFQUFFO1lBQ2Q7UUFDRjtRQUVBLE1BQU0rZSxjQUFjcGEsUUFBUXdWLEdBQUcsQ0FBQ3JZLENBQUFBO1lBQzlCLElBQUksRUFDRnVDLE1BQU0sRUFDUCxHQUFHdkM7WUFDSixPQUFPdUMsT0FBT3NULEtBQUssSUFBSSxPQUFPLEtBQUssSUFBSXRULE9BQU9zVCxLQUFLO1FBQ3JEO1FBQ0EsT0FBTztZQUNMLEtBQUssTUFBTUMsWUFBWW1ILFlBQWE7Z0JBQ2xDbkgsWUFBWSxPQUFPLEtBQUssSUFBSUE7WUFDOUI7UUFDRjtJQUNGLEdBQ0EsdURBQXVEO0lBQ3ZEalQsUUFBUXdWLEdBQUcsQ0FBQ3hYLENBQUFBO1FBQ1YsSUFBSSxFQUNGMEIsTUFBTSxFQUNQLEdBQUcxQjtRQUNKLE9BQU8wQjtJQUNUO0FBQ0Y7QUFFQSxTQUFTMmEsc0JBQXNCdGQsU0FBUyxFQUFFZSxFQUFFO0lBQzFDLE9BQU92RCw4Q0FBT0EsQ0FBQztRQUNiLE9BQU93QyxVQUFVaUcsTUFBTSxDQUFDLENBQUNrQyxLQUFLL0g7WUFDNUIsSUFBSSxFQUNGeU8sU0FBUyxFQUNUQyxPQUFPLEVBQ1IsR0FBRzFPO1lBRUorSCxHQUFHLENBQUMwRyxVQUFVLEdBQUd2TyxDQUFBQTtnQkFDZndPLFFBQVF4TyxPQUFPUztZQUNqQjtZQUVBLE9BQU9vSDtRQUNULEdBQUcsQ0FBQztJQUNOLEdBQUc7UUFBQ25JO1FBQVdlO0tBQUc7QUFDcEI7QUFFQSxTQUFTd2MsY0FBY2pVLE9BQU87SUFDNUIsT0FBTzlMLDhDQUFPQSxDQUFDLElBQU04TCxVQUFVSSxvQkFBb0JKLFdBQVcsTUFBTTtRQUFDQTtLQUFRO0FBQy9FO0FBRUEsTUFBTWtVLGlCQUFpQixFQUFFO0FBQ3pCLFNBQVNDLFNBQVNuQixRQUFRLEVBQUU1TyxPQUFPO0lBQ2pDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVckU7SUFDWjtJQUVBLE1BQU0sQ0FBQ3FVLGFBQWEsR0FBR3BCO0lBQ3ZCLE1BQU1xQixhQUFhSixjQUFjRyxlQUFleGYsNkRBQVNBLENBQUN3ZixnQkFBZ0I7SUFDMUUsTUFBTSxDQUFDRSxPQUFPQyxhQUFhLEdBQUduZ0IsaURBQVVBLENBQUN5ZCxTQUFTcUM7SUFDbEQsTUFBTTNDLGlCQUFpQkYsa0JBQWtCO1FBQ3ZDTCxVQUFVdUQ7SUFDWjtJQUVBLElBQUl2QixTQUFTdFosTUFBTSxHQUFHLEtBQUs0YSxVQUFVSixnQkFBZ0I7UUFDbkRLO0lBQ0Y7SUFFQTNlLDZFQUF5QkEsQ0FBQztRQUN4QixJQUFJb2QsU0FBU3RaLE1BQU0sRUFBRTtZQUNuQnNaLFNBQVMvYixPQUFPLENBQUMrSSxDQUFBQSxVQUFXdVIsa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlVyxPQUFPLENBQUNsUztRQUN2RixPQUFPO1lBQ0x1UixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVILFVBQVU7WUFDM0RtRDtRQUNGO0lBQ0YsR0FBRztRQUFDdkI7S0FBUztJQUNiLE9BQU9zQjtJQUVQLFNBQVN6QztRQUNQLElBQUksQ0FBQ21CLFNBQVN0WixNQUFNLEVBQUU7WUFDcEIsT0FBT3dhO1FBQ1Q7UUFFQSxPQUFPbEIsU0FBUzdELEdBQUcsQ0FBQ25QLENBQUFBLFVBQVdtQywyQkFBMkJuQyxXQUFXcVUsYUFBYSxJQUFJN1AsS0FBS0osUUFBUXBFLFVBQVVBO0lBQy9HO0FBQ0Y7QUFFQSxTQUFTd1Usa0JBQWtCaFUsSUFBSTtJQUM3QixJQUFJLENBQUNBLE1BQU07UUFDVCxPQUFPO0lBQ1Q7SUFFQSxJQUFJQSxLQUFLaVUsUUFBUSxDQUFDL2EsTUFBTSxHQUFHLEdBQUc7UUFDNUIsT0FBTzhHO0lBQ1Q7SUFFQSxNQUFNa1UsYUFBYWxVLEtBQUtpVSxRQUFRLENBQUMsRUFBRTtJQUNuQyxPQUFPM2YsaUVBQWFBLENBQUM0ZixjQUFjQSxhQUFhbFU7QUFDbEQ7QUFFQSxTQUFTbVUsd0JBQXdCN2QsSUFBSTtJQUNuQyxJQUFJLEVBQ0ZzTixPQUFPLEVBQ1IsR0FBR3ROO0lBQ0osTUFBTSxDQUFDNkQsTUFBTWlhLFFBQVEsR0FBRzVnQiwrQ0FBUUEsQ0FBQztJQUNqQyxNQUFNc2QsZUFBZXJkLGtEQUFXQSxDQUFDc2YsQ0FBQUE7UUFDL0IsS0FBSyxNQUFNLEVBQ1RuVyxNQUFNLEVBQ1AsSUFBSW1XLFFBQVM7WUFDWixJQUFJemUsaUVBQWFBLENBQUNzSSxTQUFTO2dCQUN6QndYLFFBQVFqYSxDQUFBQTtvQkFDTixNQUFNNlgsVUFBVXBPLFFBQVFoSDtvQkFDeEIsT0FBT3pDLE9BQU87d0JBQUUsR0FBR0EsSUFBSTt3QkFDckJJLE9BQU95WCxRQUFRelgsS0FBSzt3QkFDcEJFLFFBQVF1WCxRQUFRdlgsTUFBTTtvQkFDeEIsSUFBSXVYO2dCQUNOO2dCQUNBO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ3BPO0tBQVE7SUFDWixNQUFNbU4saUJBQWlCRixrQkFBa0I7UUFDdkNMLFVBQVVNO0lBQ1o7SUFDQSxNQUFNdUQsbUJBQW1CNWdCLGtEQUFXQSxDQUFDK0wsQ0FBQUE7UUFDbkMsTUFBTVEsT0FBT2dVLGtCQUFrQnhVO1FBQy9CdVIsa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlSCxVQUFVO1FBRTNELElBQUk1USxNQUFNO1lBQ1IrUSxrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVXLE9BQU8sQ0FBQzFSO1FBQzNEO1FBRUFvVSxRQUFRcFUsT0FBTzRELFFBQVE1RCxRQUFRO0lBQ2pDLEdBQUc7UUFBQzREO1FBQVNtTjtLQUFlO0lBQzVCLE1BQU0sQ0FBQ3VELFNBQVNDLE9BQU8sR0FBR2xmLDhEQUFVQSxDQUFDZ2Y7SUFDckMsT0FBTzNnQiw4Q0FBT0EsQ0FBQyxJQUFPO1lBQ3BCNGdCO1lBQ0FuYTtZQUNBb2E7UUFDRixJQUFJO1FBQUNwYTtRQUFNbWE7UUFBU0M7S0FBTztBQUM3QjtBQUVBLE1BQU1DLGlCQUFpQjtJQUFDO1FBQ3RCM2IsUUFBUTZTO1FBQ1I1UyxTQUFTLENBQUM7SUFDWjtJQUFHO1FBQ0RELFFBQVFnTztRQUNSL04sU0FBUyxDQUFDO0lBQ1o7Q0FBRTtBQUNGLE1BQU0yYixjQUFjO0lBQ2xCNU0sU0FBUyxDQUFDO0FBQ1o7QUFDQSxNQUFNNk0sZ0NBQWdDO0lBQ3BDN2QsV0FBVztRQUNUK00sU0FBU2pFO0lBQ1g7SUFDQWdWLFdBQVc7UUFDVC9RLFNBQVNqRTtRQUNUNlAsVUFBVVosa0JBQWtCZ0csYUFBYTtRQUN6Q3JGLFdBQVdWLG1CQUFtQmdHLFNBQVM7SUFDekM7SUFDQUMsYUFBYTtRQUNYbFIsU0FBU3JFO0lBQ1g7QUFDRjtBQUVBLE1BQU13ViwrQkFBK0JoRztJQUNuQ3BULElBQUkxRSxFQUFFLEVBQUU7UUFDTixJQUFJK2Q7UUFFSixPQUFPL2QsTUFBTSxPQUFPLENBQUMrZCxhQUFhLEtBQUssQ0FBQ3JaLElBQUkxRSxHQUFFLEtBQU0sT0FBTytkLGFBQWFwTyxZQUFZQTtJQUN0RjtJQUVBcU8sVUFBVTtRQUNSLE9BQU83YixNQUFNNlosSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTTtJQUMvQjtJQUVBZ0MsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDRCxPQUFPLEdBQUczYixNQUFNLENBQUNoRCxDQUFBQTtZQUMzQixJQUFJLEVBQ0Y2VyxRQUFRLEVBQ1QsR0FBRzdXO1lBQ0osT0FBTyxDQUFDNlc7UUFDVjtJQUNGO0lBRUFnSSxXQUFXbGUsRUFBRSxFQUFFO1FBQ2IsSUFBSW1lLHVCQUF1QkM7UUFFM0IsT0FBTyxDQUFDRCx3QkFBd0IsQ0FBQ0MsWUFBWSxJQUFJLENBQUMxWixHQUFHLENBQUMxRSxHQUFFLEtBQU0sT0FBTyxLQUFLLElBQUlvZSxVQUFVclYsSUFBSSxDQUFDNkgsT0FBTyxLQUFLLE9BQU91Tix3QkFBd0J4TztJQUMxSTtBQUVGO0FBRUEsTUFBTTBPLHVCQUF1QjtJQUMzQkMsZ0JBQWdCO0lBQ2hCdmUsUUFBUTtJQUNSMlEsWUFBWTtJQUNaNk4sZ0JBQWdCO0lBQ2hCdmEsWUFBWTtJQUNad2EsbUJBQW1CO0lBQ25CckgsZ0JBQWdCLFdBQVcsR0FBRSxJQUFJVztJQUNqQ3hULGdCQUFnQixXQUFXLEdBQUUsSUFBSXdUO0lBQ2pDdlQscUJBQXFCLFdBQVcsR0FBRSxJQUFJdVo7SUFDdEMzZCxNQUFNO0lBQ04wZCxhQUFhO1FBQ1hSLFNBQVM7WUFDUHpNLFNBQVM7UUFDWDtRQUNBMU4sTUFBTTtRQUNOb2EsUUFBUTViO0lBQ1Y7SUFDQTZLLHFCQUFxQixFQUFFO0lBQ3ZCd0oseUJBQXlCLEVBQUU7SUFDM0IwSSx3QkFBd0JoQjtJQUN4QjlFLDRCQUE0QmpYO0lBQzVCa2IsWUFBWTtJQUNaNUQsb0JBQW9CO0FBQ3RCO0FBQ0EsTUFBTTBGLHlCQUF5QjtJQUM3QkosZ0JBQWdCO0lBQ2hCbE0sWUFBWSxFQUFFO0lBQ2RyUyxRQUFRO0lBQ1J3ZSxnQkFBZ0I7SUFDaEJJLG1CQUFtQjtRQUNqQi9lLFdBQVc7SUFDYjtJQUNBUixVQUFVc0M7SUFDVnlWLGdCQUFnQixXQUFXLEdBQUUsSUFBSVc7SUFDakMzWCxNQUFNO0lBQ053WSw0QkFBNEJqWDtBQUM5QjtBQUNBLE1BQU1rZCxrQkFBa0IsV0FBVyxHQUFFeGlCLG9EQUFhQSxDQUFDc2lCO0FBQ25ELE1BQU1HLGdCQUFnQixXQUFXLEdBQUV6aUIsb0RBQWFBLENBQUNpaUI7QUFFakQsU0FBU1M7SUFDUCxPQUFPO1FBQ0xsZixXQUFXO1lBQ1RHLFFBQVE7WUFDUm1ULG9CQUFvQjtnQkFDbEJ6USxHQUFHO2dCQUNIQyxHQUFHO1lBQ0w7WUFDQXFjLE9BQU8sSUFBSWpIO1lBQ1hrSCxXQUFXO2dCQUNUdmMsR0FBRztnQkFDSEMsR0FBRztZQUNMO1FBQ0Y7UUFDQWdiLFdBQVc7WUFDVDFGLFlBQVksSUFBSThGO1FBQ2xCO0lBQ0Y7QUFDRjtBQUNBLFNBQVMxRCxRQUFRNkUsS0FBSyxFQUFFQyxNQUFNO0lBQzVCLE9BQVFBLE9BQU81ZixJQUFJO1FBQ2pCLEtBQUttQyxPQUFPa1MsU0FBUztZQUNuQixPQUFPO2dCQUFFLEdBQUdzTCxLQUFLO2dCQUNmcmYsV0FBVztvQkFBRSxHQUFHcWYsTUFBTXJmLFNBQVM7b0JBQzdCc1Qsb0JBQW9CZ00sT0FBT2hNLGtCQUFrQjtvQkFDN0NuVCxRQUFRbWYsT0FBT25mLE1BQU07Z0JBQ3ZCO1lBQ0Y7UUFFRixLQUFLMEIsT0FBTzBkLFFBQVE7WUFDbEIsSUFBSSxDQUFDRixNQUFNcmYsU0FBUyxDQUFDRyxNQUFNLEVBQUU7Z0JBQzNCLE9BQU9rZjtZQUNUO1lBRUEsT0FBTztnQkFBRSxHQUFHQSxLQUFLO2dCQUNmcmYsV0FBVztvQkFBRSxHQUFHcWYsTUFBTXJmLFNBQVM7b0JBQzdCb2YsV0FBVzt3QkFDVHZjLEdBQUd5YyxPQUFPbk4sV0FBVyxDQUFDdFAsQ0FBQyxHQUFHd2MsTUFBTXJmLFNBQVMsQ0FBQ3NULGtCQUFrQixDQUFDelEsQ0FBQzt3QkFDOURDLEdBQUd3YyxPQUFPbk4sV0FBVyxDQUFDclAsQ0FBQyxHQUFHdWMsTUFBTXJmLFNBQVMsQ0FBQ3NULGtCQUFrQixDQUFDeFEsQ0FBQztvQkFDaEU7Z0JBQ0Y7WUFDRjtRQUVGLEtBQUtqQixPQUFPMmQsT0FBTztRQUNuQixLQUFLM2QsT0FBTzRkLFVBQVU7WUFDcEIsT0FBTztnQkFBRSxHQUFHSixLQUFLO2dCQUNmcmYsV0FBVztvQkFBRSxHQUFHcWYsTUFBTXJmLFNBQVM7b0JBQzdCRyxRQUFRO29CQUNSbVQsb0JBQW9CO3dCQUNsQnpRLEdBQUc7d0JBQ0hDLEdBQUc7b0JBQ0w7b0JBQ0FzYyxXQUFXO3dCQUNUdmMsR0FBRzt3QkFDSEMsR0FBRztvQkFDTDtnQkFDRjtZQUNGO1FBRUYsS0FBS2pCLE9BQU82ZCxpQkFBaUI7WUFDM0I7Z0JBQ0UsTUFBTSxFQUNKL1csT0FBTyxFQUNSLEdBQUcyVztnQkFDSixNQUFNLEVBQ0psZixFQUFFLEVBQ0gsR0FBR3VJO2dCQUNKLE1BQU15UCxhQUFhLElBQUk4Rix1QkFBdUJtQixNQUFNdkIsU0FBUyxDQUFDMUYsVUFBVTtnQkFDeEVBLFdBQVdlLEdBQUcsQ0FBQy9ZLElBQUl1STtnQkFDbkIsT0FBTztvQkFBRSxHQUFHMFcsS0FBSztvQkFDZnZCLFdBQVc7d0JBQUUsR0FBR3VCLE1BQU12QixTQUFTO3dCQUM3QjFGO29CQUNGO2dCQUNGO1lBQ0Y7UUFFRixLQUFLdlcsT0FBTzhkLG9CQUFvQjtZQUM5QjtnQkFDRSxNQUFNLEVBQ0p2ZixFQUFFLEVBQ0ZxTixHQUFHLEVBQ0g2SSxRQUFRLEVBQ1QsR0FBR2dKO2dCQUNKLE1BQU0zVyxVQUFVMFcsTUFBTXZCLFNBQVMsQ0FBQzFGLFVBQVUsQ0FBQ3RULEdBQUcsQ0FBQzFFO2dCQUUvQyxJQUFJLENBQUN1SSxXQUFXOEUsUUFBUTlFLFFBQVE4RSxHQUFHLEVBQUU7b0JBQ25DLE9BQU80UjtnQkFDVDtnQkFFQSxNQUFNakgsYUFBYSxJQUFJOEYsdUJBQXVCbUIsTUFBTXZCLFNBQVMsQ0FBQzFGLFVBQVU7Z0JBQ3hFQSxXQUFXZSxHQUFHLENBQUMvWSxJQUFJO29CQUFFLEdBQUd1SSxPQUFPO29CQUM3QjJOO2dCQUNGO2dCQUNBLE9BQU87b0JBQUUsR0FBRytJLEtBQUs7b0JBQ2Z2QixXQUFXO3dCQUFFLEdBQUd1QixNQUFNdkIsU0FBUzt3QkFDN0IxRjtvQkFDRjtnQkFDRjtZQUNGO1FBRUYsS0FBS3ZXLE9BQU8rZCxtQkFBbUI7WUFDN0I7Z0JBQ0UsTUFBTSxFQUNKeGYsRUFBRSxFQUNGcU4sR0FBRyxFQUNKLEdBQUc2UjtnQkFDSixNQUFNM1csVUFBVTBXLE1BQU12QixTQUFTLENBQUMxRixVQUFVLENBQUN0VCxHQUFHLENBQUMxRTtnQkFFL0MsSUFBSSxDQUFDdUksV0FBVzhFLFFBQVE5RSxRQUFROEUsR0FBRyxFQUFFO29CQUNuQyxPQUFPNFI7Z0JBQ1Q7Z0JBRUEsTUFBTWpILGFBQWEsSUFBSThGLHVCQUF1Qm1CLE1BQU12QixTQUFTLENBQUMxRixVQUFVO2dCQUN4RUEsV0FBVzdZLE1BQU0sQ0FBQ2E7Z0JBQ2xCLE9BQU87b0JBQUUsR0FBR2lmLEtBQUs7b0JBQ2Z2QixXQUFXO3dCQUFFLEdBQUd1QixNQUFNdkIsU0FBUzt3QkFDN0IxRjtvQkFDRjtnQkFDRjtZQUNGO1FBRUY7WUFDRTtnQkFDRSxPQUFPaUg7WUFDVDtJQUNKO0FBQ0Y7QUFFQSxTQUFTUSxhQUFhcGdCLElBQUk7SUFDeEIsSUFBSSxFQUNGNlcsUUFBUSxFQUNULEdBQUc3VztJQUNKLE1BQU0sRUFDSlUsTUFBTSxFQUNOdWUsY0FBYyxFQUNkbkgsY0FBYyxFQUNmLEdBQUc5YSxpREFBVUEsQ0FBQ3VpQjtJQUNmLE1BQU1jLHlCQUF5QjFoQiwrREFBV0EsQ0FBQ3NnQjtJQUMzQyxNQUFNcUIsbUJBQW1CM2hCLCtEQUFXQSxDQUFDK0IsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT0MsRUFBRSxHQUFHLCtDQUErQztJQUUxSDFELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSTRaLFVBQVU7WUFDWjtRQUNGO1FBRUEsSUFBSSxDQUFDb0ksa0JBQWtCb0IsMEJBQTBCQyxvQkFBb0IsTUFBTTtZQUN6RSxJQUFJLENBQUMvaEIsbUVBQWVBLENBQUM4aEIseUJBQXlCO2dCQUM1QztZQUNGO1lBRUEsSUFBSS9VLFNBQVNpVixhQUFhLEtBQUtGLHVCQUF1Qi9aLE1BQU0sRUFBRTtnQkFDNUQsMkJBQTJCO2dCQUMzQjtZQUNGO1lBRUEsTUFBTXlSLGdCQUFnQkQsZUFBZXpTLEdBQUcsQ0FBQ2liO1lBRXpDLElBQUksQ0FBQ3ZJLGVBQWU7Z0JBQ2xCO1lBQ0Y7WUFFQSxNQUFNLEVBQ0o1RSxhQUFhLEVBQ2J6SixJQUFJLEVBQ0wsR0FBR3FPO1lBRUosSUFBSSxDQUFDNUUsY0FBYzVCLE9BQU8sSUFBSSxDQUFDN0gsS0FBSzZILE9BQU8sRUFBRTtnQkFDM0M7WUFDRjtZQUVBaVAsc0JBQXNCO2dCQUNwQixLQUFLLE1BQU10WCxXQUFXO29CQUFDaUssY0FBYzVCLE9BQU87b0JBQUU3SCxLQUFLNkgsT0FBTztpQkFBQyxDQUFFO29CQUMzRCxJQUFJLENBQUNySSxTQUFTO3dCQUNaO29CQUNGO29CQUVBLE1BQU11WCxnQkFBZ0J6aEIsMEVBQXNCQSxDQUFDa0s7b0JBRTdDLElBQUl1WCxlQUFlO3dCQUNqQkEsY0FBY0MsS0FBSzt3QkFDbkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDekI7UUFBZ0JwSTtRQUFVaUI7UUFBZ0J3STtRQUFrQkQ7S0FBdUI7SUFDdkYsT0FBTztBQUNUO0FBRUEsU0FBU00sZUFBZUMsU0FBUyxFQUFFNWdCLElBQUk7SUFDckMsSUFBSSxFQUNGcUgsU0FBUyxFQUNULEdBQUd3WixNQUNKLEdBQUc3Z0I7SUFDSixPQUFPNGdCLGFBQWEsUUFBUUEsVUFBVWhlLE1BQU0sR0FBR2dlLFVBQVUvYSxNQUFNLENBQUMsQ0FBQ0MsYUFBYThCO1FBQzVFLE9BQU9BLFNBQVM7WUFDZFAsV0FBV3ZCO1lBQ1gsR0FBRythLElBQUk7UUFDVDtJQUNGLEdBQUd4WixhQUFhQTtBQUNsQjtBQUVBLFNBQVN5WiwwQkFBMEJoSSxNQUFNO0lBQ3ZDLE9BQU8xYiw4Q0FBT0EsQ0FBQyxJQUFPO1lBQ3BCbUQsV0FBVztnQkFBRSxHQUFHNmQsOEJBQThCN2QsU0FBUztnQkFDckQsR0FBSXVZLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU92WSxTQUFTO1lBQ2hEO1lBQ0E4ZCxXQUFXO2dCQUFFLEdBQUdELDhCQUE4QkMsU0FBUztnQkFDckQsR0FBSXZGLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU91RixTQUFTO1lBQ2hEO1lBQ0FHLGFBQWE7Z0JBQUUsR0FBR0osOEJBQThCSSxXQUFXO2dCQUN6RCxHQUFJMUYsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBTzBGLFdBQVc7WUFDbEQ7UUFDRixJQUNBO1FBQUMxRixVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPdlksU0FBUztRQUFFdVksVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT3VGLFNBQVM7UUFBRXZGLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU8wRixXQUFXO0tBQUM7QUFDeEk7QUFFQSxTQUFTdUMsaUNBQWlDL2dCLElBQUk7SUFDNUMsSUFBSSxFQUNGcVIsVUFBVSxFQUNWL0QsT0FBTyxFQUNQc08sV0FBVyxFQUNYOUMsU0FBUyxJQUFJLEVBQ2QsR0FBRzlZO0lBQ0osTUFBTWdoQixjQUFjM2pCLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU0sRUFDSitGLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUcsT0FBT3lWLFdBQVcsWUFBWTtRQUNoQzFWLEdBQUcwVjtRQUNIelYsR0FBR3lWO0lBQ0wsSUFBSUE7SUFDSmhhLDZFQUF5QkEsQ0FBQztRQUN4QixNQUFNK1gsV0FBVyxDQUFDelQsS0FBSyxDQUFDQztRQUV4QixJQUFJd1QsWUFBWSxDQUFDeEYsWUFBWTtZQUMzQjJQLFlBQVl6UCxPQUFPLEdBQUc7WUFDdEI7UUFDRjtRQUVBLElBQUl5UCxZQUFZelAsT0FBTyxJQUFJLENBQUNxSyxhQUFhO1lBQ3ZDLHlFQUF5RTtZQUN6RSwrQ0FBK0M7WUFDL0M7UUFDRixFQUFFLDREQUE0RDtRQUc5RCxNQUFNbFMsT0FBTzJILGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVczSCxJQUFJLENBQUM2SCxPQUFPO1FBRWxFLElBQUksQ0FBQzdILFFBQVFBLEtBQUsrUixXQUFXLEtBQUssT0FBTztZQUN2QyxrRUFBa0U7WUFDbEUsa0NBQWtDO1lBQ2xDO1FBQ0Y7UUFFQSxNQUFNNVgsT0FBT3lKLFFBQVE1RDtRQUNyQixNQUFNdVgsWUFBWXZaLGFBQWE3RCxNQUFNK1g7UUFFckMsSUFBSSxDQUFDeFksR0FBRztZQUNONmQsVUFBVTdkLENBQUMsR0FBRztRQUNoQjtRQUVBLElBQUksQ0FBQ0MsR0FBRztZQUNONGQsVUFBVTVkLENBQUMsR0FBRztRQUNoQixFQUFFLHFEQUFxRDtRQUd2RDJkLFlBQVl6UCxPQUFPLEdBQUc7UUFFdEIsSUFBSTlOLEtBQUtxSixHQUFHLENBQUNtVSxVQUFVN2QsQ0FBQyxJQUFJLEtBQUtLLEtBQUtxSixHQUFHLENBQUNtVSxVQUFVNWQsQ0FBQyxJQUFJLEdBQUc7WUFDMUQsTUFBTXFILDBCQUEwQkQsMkJBQTJCZjtZQUUzRCxJQUFJZ0IseUJBQXlCO2dCQUMzQkEsd0JBQXdCOEgsUUFBUSxDQUFDO29CQUMvQnRPLEtBQUsrYyxVQUFVNWQsQ0FBQztvQkFDaEJXLE1BQU1pZCxVQUFVN2QsQ0FBQztnQkFDbkI7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDaU87UUFBWWpPO1FBQUdDO1FBQUd1WTtRQUFhdE87S0FBUTtBQUM3QztBQUVBLE1BQU00VCx5QkFBeUIsV0FBVyxHQUFFbmtCLG9EQUFhQSxDQUFDO0lBQUUsR0FBR2tHLGtCQUFrQjtJQUMvRXVFLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBQ0EsSUFBSTBaO0FBRUgsVUFBVUEsTUFBTTtJQUNmQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDckNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7QUFDdEMsR0FBR0EsVUFBV0EsQ0FBQUEsU0FBUyxDQUFDO0FBRXhCLE1BQU1DLGFBQWEsV0FBVyxHQUFFN2pCLDJDQUFJQSxDQUFDLFNBQVM2akIsV0FBV3BoQixJQUFJO0lBQzNELElBQUlxaEIsdUJBQXVCQyx1QkFBdUJDLG1CQUFtQkM7SUFFckUsSUFBSSxFQUNGN2dCLEVBQUUsRUFDRjhnQixhQUFhLEVBQ2JySyxhQUFhLElBQUksRUFDakJ1RyxRQUFRLEVBQ1I5YSxVQUFVcWIsY0FBYyxFQUN4QndELHFCQUFxQjNhLGdCQUFnQixFQUNyQzRhLFNBQVMsRUFDVGYsU0FBUyxFQUNULEdBQUdwUSxPQUNKLEdBQUd4UTtJQUNKLE1BQU00aEIsUUFBUXRrQixpREFBVUEsQ0FBQ3lkLFNBQVN6SyxXQUFXbVA7SUFDN0MsTUFBTSxDQUFDRyxPQUFPN2YsU0FBUyxHQUFHNmhCO0lBQzFCLE1BQU0sQ0FBQ0Msc0JBQXNCQyx3QkFBd0IsR0FBR25pQjtJQUN4RCxNQUFNLENBQUNvaUIsUUFBUUMsVUFBVSxHQUFHOWtCLCtDQUFRQSxDQUFDaWtCLE9BQU9jLGFBQWE7SUFDekQsTUFBTUMsZ0JBQWdCSCxXQUFXWixPQUFPZ0IsV0FBVztJQUNuRCxNQUFNLEVBQ0o1aEIsV0FBVyxFQUNURyxRQUFRMGhCLFFBQVEsRUFDaEIxQyxPQUFPNUgsY0FBYyxFQUNyQjZILFNBQVMsRUFDVixFQUNEdEIsV0FBVyxFQUNUMUYsWUFBWXpULG1CQUFtQixFQUNoQyxFQUNGLEdBQUcwYTtJQUNKLE1BQU1sVyxPQUFPMFksV0FBV3RLLGVBQWV6UyxHQUFHLENBQUMrYyxZQUFZO0lBQ3ZELE1BQU1DLGNBQWNobEIsNkNBQU1BLENBQUM7UUFDekJpbEIsU0FBUztRQUNUQyxZQUFZO0lBQ2Q7SUFDQSxNQUFNN2hCLFNBQVN0RCw4Q0FBT0EsQ0FBQztRQUNyQixJQUFJb2xCO1FBRUosT0FBT0osWUFBWSxPQUFPO1lBQ3hCemhCLElBQUl5aEI7WUFDSiw4REFBOEQ7WUFDOUQvZCxNQUFNLENBQUNtZSxhQUFhOVksUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS3JGLElBQUksS0FBSyxPQUFPbWUsYUFBYXJFO1lBQzlFdGEsTUFBTXdlO1FBQ1IsSUFBSTtJQUNOLEdBQUc7UUFBQ0Q7UUFBVTFZO0tBQUs7SUFDbkIsTUFBTStZLFlBQVlwbEIsNkNBQU1BLENBQUM7SUFDekIsTUFBTSxDQUFDcWxCLGNBQWNDLGdCQUFnQixHQUFHemxCLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQytoQixnQkFBZ0IyRCxrQkFBa0IsR0FBRzFsQiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNMmxCLGNBQWNqa0Isa0VBQWNBLENBQUM0UixPQUFPdE4sT0FBTzBaLE1BQU0sQ0FBQ3BNO0lBQ3hELE1BQU1zUyx5QkFBeUJsbEIsK0RBQVdBLENBQUMsa0JBQWtCK0M7SUFDN0QsTUFBTW9pQiw2QkFBNkIzbEIsOENBQU9BLENBQUMsSUFBTThILG9CQUFvQjBaLFVBQVUsSUFBSTtRQUFDMVo7S0FBb0I7SUFDeEcsTUFBTWthLHlCQUF5QjBCLDBCQUEwQmE7SUFDekQsTUFBTSxFQUNKMWMsY0FBYyxFQUNkcVUsMEJBQTBCLEVBQzFCSyxrQkFBa0IsRUFDbkIsR0FBR2pCLHNCQUFzQnFLLDRCQUE0QjtRQUNwRG5LLFVBQVVzSjtRQUNWckosY0FBYztZQUFDOEcsVUFBVXZjLENBQUM7WUFBRXVjLFVBQVV0YyxDQUFDO1NBQUM7UUFDeEN5VixRQUFRc0csdUJBQXVCZixTQUFTO0lBQzFDO0lBQ0EsTUFBTWhOLGFBQWF3RyxjQUFjQyxnQkFBZ0JzSztJQUNqRCxNQUFNWSx3QkFBd0I1bEIsOENBQU9BLENBQUMsSUFBTTZoQixpQkFBaUJwaEIsdUVBQW1CQSxDQUFDb2hCLGtCQUFrQixNQUFNO1FBQUNBO0tBQWU7SUFDekgsTUFBTWdFLG9CQUFvQkM7SUFDMUIsTUFBTUMsd0JBQXdCbkosZUFBZTNJLFlBQVkrTix1QkFBdUI3ZSxTQUFTLENBQUMrTSxPQUFPO0lBQ2pHeVQsaUNBQWlDO1FBQy9CMVAsWUFBWStRLFdBQVd0SyxlQUFlelMsR0FBRyxDQUFDK2MsWUFBWTtRQUN0RHRKLFFBQVFtSyxrQkFBa0JHLHVCQUF1QjtRQUNqRHhILGFBQWF1SDtRQUNiN1YsU0FBUzhSLHVCQUF1QjdlLFNBQVMsQ0FBQytNLE9BQU87SUFDbkQ7SUFDQSxNQUFNNFIsaUJBQWlCdEUsUUFBUXZKLFlBQVkrTix1QkFBdUI3ZSxTQUFTLENBQUMrTSxPQUFPLEVBQUU2VjtJQUNyRixNQUFNaEUsb0JBQW9CdkUsUUFBUXZKLGFBQWFBLFdBQVdnUyxhQUFhLEdBQUc7SUFDMUUsTUFBTUMsZ0JBQWdCam1CLDZDQUFNQSxDQUFDO1FBQzNCNGhCLGdCQUFnQjtRQUNoQnZlLFFBQVE7UUFDUjJRO1FBQ0FyTSxlQUFlO1FBQ2ZMLFlBQVk7UUFDWk07UUFDQTZTO1FBQ0F5TCxjQUFjO1FBQ2RDLGtCQUFrQjtRQUNsQnRlO1FBQ0FwRSxNQUFNO1FBQ05vTSxxQkFBcUIsRUFBRTtRQUN2QnVXLHlCQUF5QjtJQUMzQjtJQUNBLE1BQU1DLFdBQVd4ZSxvQkFBb0IyWixVQUFVLENBQUMsQ0FBQ3dDLHdCQUF3QmlDLGNBQWMvUixPQUFPLENBQUN6USxJQUFJLEtBQUssT0FBTyxLQUFLLElBQUl1Z0Isc0JBQXNCMWdCLEVBQUU7SUFDaEosTUFBTTZkLGNBQWNYLHdCQUF3QjtRQUMxQ3ZRLFNBQVM4Uix1QkFBdUJaLFdBQVcsQ0FBQ2xSLE9BQU87SUFDckQsSUFBSSxvREFBb0Q7SUFFeEQsTUFBTWlXLGVBQWUsQ0FBQ2pDLHdCQUF3QjlDLFlBQVlSLE9BQU8sQ0FBQ3pNLE9BQU8sS0FBSyxPQUFPK1Asd0JBQXdCalE7SUFDN0csTUFBTW1TLG1CQUFtQnRCLGdCQUFnQixDQUFDWCxvQkFBb0IvQyxZQUFZM2EsSUFBSSxLQUFLLE9BQU8wZCxvQkFBb0JyQyxpQkFBaUI7SUFDL0gsTUFBTXlFLGtCQUFrQnJRLFFBQVFrTCxZQUFZUixPQUFPLENBQUN6TSxPQUFPLElBQUlpTixZQUFZM2EsSUFBSSxHQUFHLHdFQUF3RTtJQUMxSixpREFBaUQ7SUFFakQsTUFBTStmLGdCQUFnQmpJLGFBQWFnSSxrQkFBa0IsT0FBT3pFLGlCQUFpQiwyQ0FBMkM7SUFFeEgsTUFBTTNCLGFBQWFKLGNBQWNvRyxlQUFlemxCLDZEQUFTQSxDQUFDeWxCLGdCQUFnQixPQUFPLGdEQUFnRDtJQUVqSSxNQUFNclcsc0JBQXNCNE8sdUJBQXVCb0csZ0JBQWdCd0IsWUFBWSxPQUFPQSxXQUFXclMsYUFBYTtJQUM5RyxNQUFNcUYsMEJBQTBCMkcsU0FBU25RLHNCQUFzQixrQkFBa0I7SUFFakYsTUFBTTJXLG9CQUFvQmxELGVBQWVDLFdBQVc7UUFDbER2WixXQUFXO1lBQ1RqRSxHQUFHdWMsVUFBVXZjLENBQUMsR0FBR3dnQixjQUFjeGdCLENBQUM7WUFDaENDLEdBQUdzYyxVQUFVdGMsQ0FBQyxHQUFHdWdCLGNBQWN2Z0IsQ0FBQztZQUNoQ21FLFFBQVE7WUFDUkMsUUFBUTtRQUNWO1FBQ0F3WDtRQUNBdmU7UUFDQXdlO1FBQ0FDO1FBQ0FxRTtRQUNBMWlCLE1BQU13aUIsY0FBYy9SLE9BQU8sQ0FBQ3pRLElBQUk7UUFDaENnakIsaUJBQWlCdEYsWUFBWTNhLElBQUk7UUFDakNxSjtRQUNBd0o7UUFDQTZHO0lBQ0Y7SUFDQSxNQUFNcFcscUJBQXFCNmIsd0JBQXdCMWtCLHVEQUFHQSxDQUFDMGtCLHVCQUF1QnJELGFBQWE7SUFDM0YsTUFBTS9SLGdCQUFnQnFPLGlCQUFpQi9PLHNCQUFzQiwyREFBMkQ7SUFFeEgsTUFBTTZXLG1CQUFtQmxILHNCQUFzQmpQLGdCQUFnQixvRkFBb0Y7SUFFbkosTUFBTW9XLHdCQUF3Qm5ILHNCQUFzQmpQLGVBQWU7UUFBQ3NSO0tBQWU7SUFDbkYsTUFBTXVFLDBCQUEwQm5sQix1REFBR0EsQ0FBQ3VsQixtQkFBbUJFO0lBQ3ZELE1BQU0vZSxnQkFBZ0J3ZSxtQkFBbUJ2YixnQkFBZ0J1YixrQkFBa0JLLHFCQUFxQjtJQUNoRyxNQUFNbGYsYUFBYWpFLFVBQVVzRSxnQkFBZ0IwYyxtQkFBbUI7UUFDOURoaEI7UUFDQXNFO1FBQ0FDO1FBQ0FDLHFCQUFxQjZkO1FBQ3JCNWI7SUFDRixLQUFLO0lBQ0wsTUFBTThjLFNBQVN2ZixrQkFBa0JDLFlBQVk7SUFDN0MsTUFBTSxDQUFDN0QsTUFBTW9qQixRQUFRLEdBQUdobkIsK0NBQVFBLENBQUMsT0FBTyxpRUFBaUU7SUFDekcsc0JBQXNCO0lBRXRCLE1BQU1pbkIsbUJBQW1CUixrQkFBa0JFLG9CQUFvQnZsQix1REFBR0EsQ0FBQ3VsQixtQkFBbUJHO0lBQ3RGLE1BQU0zYyxZQUFZRCxZQUFZK2Msa0JBQWtCLENBQUMzQyxhQUFhMWdCLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUsrQyxJQUFJLEtBQUssT0FBTzJkLGFBQWEsTUFBTXRDO0lBQzlILE1BQU1rRixvQkFBb0JqbkIsa0RBQVdBLENBQUMsQ0FBQytDLE9BQU9XO1FBQzVDLElBQUksRUFDRjBCLFFBQVE0VixNQUFNLEVBQ2QzVixPQUFPLEVBQ1IsR0FBRzNCO1FBRUosSUFBSTRoQixVQUFVbFIsT0FBTyxJQUFJLE1BQU07WUFDN0I7UUFDRjtRQUVBLE1BQU1GLGFBQWF5RyxlQUFlelMsR0FBRyxDQUFDb2QsVUFBVWxSLE9BQU87UUFFdkQsSUFBSSxDQUFDRixZQUFZO1lBQ2Y7UUFDRjtRQUVBLE1BQU00TixpQkFBaUIvZSxNQUFNK1MsV0FBVztRQUN4QyxNQUFNb1IsaUJBQWlCLElBQUlsTSxPQUFPO1lBQ2hDelgsUUFBUStoQixVQUFVbFIsT0FBTztZQUN6QkY7WUFDQW5SLE9BQU8rZTtZQUNQemM7WUFDQSxnRkFBZ0Y7WUFDaEYsNkRBQTZEO1lBQzdEZ1AsU0FBUzhSO1lBRVRoUyxTQUFRdUMsa0JBQWtCO2dCQUN4QixNQUFNbFQsS0FBSzhoQixVQUFVbFIsT0FBTztnQkFFNUIsSUFBSTVRLE1BQU0sTUFBTTtvQkFDZDtnQkFDRjtnQkFFQSxNQUFNb1gsZ0JBQWdCRCxlQUFlelMsR0FBRyxDQUFDMUU7Z0JBRXpDLElBQUksQ0FBQ29YLGVBQWU7b0JBQ2xCO2dCQUNGO2dCQUVBLE1BQU0sRUFDSnRYLFdBQVcsRUFDWixHQUFHb2lCLFlBQVl0UixPQUFPO2dCQUN2QixNQUFNclIsUUFBUTtvQkFDWlEsUUFBUTt3QkFDTkM7d0JBQ0EwRCxNQUFNMFQsY0FBYzFULElBQUk7d0JBQ3hCUixNQUFNd2U7b0JBQ1I7Z0JBQ0Y7Z0JBQ0Exa0Isa0VBQXVCQSxDQUFDO29CQUN0QjhDLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVlQO29CQUMzQzhoQixVQUFVYixPQUFPbUQsWUFBWTtvQkFDN0J2a0IsU0FBUzt3QkFDUEUsTUFBTW1DLE9BQU9rUyxTQUFTO3dCQUN0QlQ7d0JBQ0FuVCxRQUFRQztvQkFDVjtvQkFDQWtoQixxQkFBcUI7d0JBQ25CNWhCLE1BQU07d0JBQ05DO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQXlTLFFBQU9ELFdBQVc7Z0JBQ2hCM1MsU0FBUztvQkFDUEUsTUFBTW1DLE9BQU8wZCxRQUFRO29CQUNyQnBOO2dCQUNGO1lBQ0Y7WUFFQUUsT0FBTzJSLGNBQWNuaUIsT0FBTzJkLE9BQU87WUFDbkNqTixVQUFVeVIsY0FBY25pQixPQUFPNGQsVUFBVTtRQUMzQztRQUNBcmlCLGtFQUF1QkEsQ0FBQztZQUN0QmdsQixnQkFBZ0IwQjtZQUNoQnpCLGtCQUFrQjFpQixNQUFNK1MsV0FBVztRQUNyQztRQUVBLFNBQVNzUixjQUFjdGtCLElBQUk7WUFDekIsT0FBTyxlQUFleU87Z0JBQ3BCLE1BQU0sRUFDSmhPLE1BQU0sRUFDTmlFLFVBQVUsRUFDVjdELElBQUksRUFDSjJpQix1QkFBdUIsRUFDeEIsR0FBR0gsY0FBYy9SLE9BQU87Z0JBQ3pCLElBQUlyUixRQUFRO2dCQUVaLElBQUlRLFVBQVUraUIseUJBQXlCO29CQUNyQyxNQUFNLEVBQ0plLFVBQVUsRUFDWCxHQUFHM0IsWUFBWXRSLE9BQU87b0JBQ3ZCclIsUUFBUTt3QkFDTitlO3dCQUNBdmUsUUFBUUE7d0JBQ1JpRTt3QkFDQXFLLE9BQU95VTt3QkFDUDNpQjtvQkFDRjtvQkFFQSxJQUFJYixTQUFTbUMsT0FBTzJkLE9BQU8sSUFBSSxPQUFPeUUsZUFBZSxZQUFZO3dCQUMvRCxNQUFNQyxlQUFlLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQ0gsV0FBV3RrQjt3QkFFdEQsSUFBSXVrQixjQUFjOzRCQUNoQnhrQixPQUFPbUMsT0FBTzRkLFVBQVU7d0JBQzFCO29CQUNGO2dCQUNGO2dCQUVBeUMsVUFBVWxSLE9BQU8sR0FBRztnQkFDcEI1VCxrRUFBdUJBLENBQUM7b0JBQ3RCb0MsU0FBUzt3QkFDUEU7b0JBQ0Y7b0JBQ0EraEIsVUFBVWIsT0FBT2MsYUFBYTtvQkFDOUJpQyxRQUFRO29CQUNSdkIsZ0JBQWdCO29CQUNoQkMsa0JBQWtCO29CQUNsQixNQUFNblUsWUFBWXhPLFNBQVNtQyxPQUFPMmQsT0FBTyxHQUFHLGNBQWM7b0JBRTFELElBQUk3ZixPQUFPO3dCQUNULE1BQU13TyxVQUFVbVUsWUFBWXRSLE9BQU8sQ0FBQzlDLFVBQVU7d0JBQzlDQyxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFReE87d0JBQ25DMmhCLHFCQUFxQjs0QkFDbkI1aEIsTUFBTXdPOzRCQUNOdk87d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0YsR0FDQTtRQUFDNFg7S0FBZTtJQUNoQixNQUFNOE0sb0NBQW9Dem5CLGtEQUFXQSxDQUFDLENBQUN1UixTQUFTbk07UUFDOUQsT0FBTyxDQUFDckMsT0FBT1E7WUFDYixNQUFNdVMsY0FBYy9TLE1BQU0rUyxXQUFXO1lBQ3JDLE1BQU00UixzQkFBc0IvTSxlQUFlelMsR0FBRyxDQUFDM0U7WUFFL0MsSUFDQStoQixVQUFVbFIsT0FBTyxLQUFLLFFBQVEsc0JBQXNCO1lBQ3BELENBQUNzVCx1QkFBdUIsa0NBQWtDO1lBQzFENVIsWUFBWTZSLE1BQU0sSUFBSTdSLFlBQVk4UixnQkFBZ0IsRUFBRTtnQkFDbEQ7WUFDRjtZQUVBLE1BQU1DLG9CQUFvQjtnQkFDeEJ0a0IsUUFBUW1rQjtZQUNWO1lBQ0EsTUFBTUksaUJBQWlCdlcsUUFBUXhPLE9BQU9xQyxPQUFPQyxPQUFPLEVBQUV3aUI7WUFFdEQsSUFBSUMsbUJBQW1CLE1BQU07Z0JBQzNCaFMsWUFBWTZSLE1BQU0sR0FBRztvQkFDbkJJLFlBQVkzaUIsT0FBT0EsTUFBTTtnQkFDM0I7Z0JBQ0FrZ0IsVUFBVWxSLE9BQU8sR0FBRzdRO2dCQUNwQjBqQixrQkFBa0Jsa0IsT0FBT3FDO1lBQzNCO1FBQ0Y7SUFDRixHQUFHO1FBQUN1VjtRQUFnQnNNO0tBQWtCO0lBQ3RDLE1BQU1yUixhQUFha0YscUJBQXFCcFYsU0FBUytoQjtJQUNqRDVILGVBQWVuYTtJQUNmL0QsNkVBQXlCQSxDQUFDO1FBQ3hCLElBQUlvZ0Isa0JBQWtCNkMsV0FBV1osT0FBT21ELFlBQVksRUFBRTtZQUNwRHRDLFVBQVViLE9BQU9nQixXQUFXO1FBQzlCO0lBQ0YsR0FBRztRQUFDakQ7UUFBZ0I2QztLQUFPO0lBQzNCOWtCLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTSxFQUNKNEUsVUFBVSxFQUNYLEdBQUdnaEIsWUFBWXRSLE9BQU87UUFDdkIsTUFBTSxFQUNKN1EsTUFBTSxFQUNOdWUsY0FBYyxFQUNkdGEsVUFBVSxFQUNWN0QsSUFBSSxFQUNMLEdBQUd3aUIsY0FBYy9SLE9BQU87UUFFekIsSUFBSSxDQUFDN1EsVUFBVSxDQUFDdWUsZ0JBQWdCO1lBQzlCO1FBQ0Y7UUFFQSxNQUFNL2UsUUFBUTtZQUNaUTtZQUNBdWU7WUFDQXRhO1lBQ0FxSyxPQUFPO2dCQUNMNUwsR0FBR3FnQix3QkFBd0JyZ0IsQ0FBQztnQkFDNUJDLEdBQUdvZ0Isd0JBQXdCcGdCLENBQUM7WUFDOUI7WUFDQXZDO1FBQ0Y7UUFDQW5ELGtFQUF1QkEsQ0FBQztZQUN0QmtFLGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVczQjtZQUN6QzJoQixxQkFBcUI7Z0JBQ25CNWhCLE1BQU07Z0JBQ05DO1lBQ0Y7UUFDRjtJQUNGLEdBQ0E7UUFBQ3VqQix3QkFBd0JyZ0IsQ0FBQztRQUFFcWdCLHdCQUF3QnBnQixDQUFDO0tBQUM7SUFDdERwRyxnREFBU0EsQ0FBQztRQUNSLE1BQU0sRUFDSnlELE1BQU0sRUFDTnVlLGNBQWMsRUFDZHRhLFVBQVUsRUFDVk8sbUJBQW1CLEVBQ25CdWUsdUJBQXVCLEVBQ3hCLEdBQUdILGNBQWMvUixPQUFPO1FBRXpCLElBQUksQ0FBQzdRLFVBQVUraEIsVUFBVWxSLE9BQU8sSUFBSSxRQUFRLENBQUMwTixrQkFBa0IsQ0FBQ3dFLHlCQUF5QjtZQUN2RjtRQUNGO1FBRUEsTUFBTSxFQUNKN2lCLFVBQVUsRUFDWCxHQUFHaWlCLFlBQVl0UixPQUFPO1FBQ3ZCLE1BQU00VCxnQkFBZ0JqZ0Isb0JBQW9CRyxHQUFHLENBQUM0ZTtRQUM5QyxNQUFNbmpCLE9BQU9xa0IsaUJBQWlCQSxjQUFjdGhCLElBQUksQ0FBQzBOLE9BQU8sR0FBRztZQUN6RDVRLElBQUl3a0IsY0FBY3hrQixFQUFFO1lBQ3BCa0QsTUFBTXNoQixjQUFjdGhCLElBQUksQ0FBQzBOLE9BQU87WUFDaENsTixNQUFNOGdCLGNBQWM5Z0IsSUFBSTtZQUN4QndTLFVBQVVzTyxjQUFjdE8sUUFBUTtRQUNsQyxJQUFJO1FBQ0osTUFBTTNXLFFBQVE7WUFDWlE7WUFDQXVlO1lBQ0F0YTtZQUNBcUssT0FBTztnQkFDTDVMLEdBQUdxZ0Isd0JBQXdCcmdCLENBQUM7Z0JBQzVCQyxHQUFHb2dCLHdCQUF3QnBnQixDQUFDO1lBQzlCO1lBQ0F2QztRQUNGO1FBQ0FuRCxrRUFBdUJBLENBQUM7WUFDdEJ1bUIsUUFBUXBqQjtZQUNSRixjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXVjtZQUN6QzJoQixxQkFBcUI7Z0JBQ25CNWhCLE1BQU07Z0JBQ05DO1lBQ0Y7UUFDRjtJQUNGLEdBQ0E7UUFBQytqQjtLQUFPO0lBQ1JubEIsNkVBQXlCQSxDQUFDO1FBQ3hCd2tCLGNBQWMvUixPQUFPLEdBQUc7WUFDdEIwTjtZQUNBdmU7WUFDQTJRO1lBQ0FyTTtZQUNBTDtZQUNBTTtZQUNBNlM7WUFDQXlMO1lBQ0FDO1lBQ0F0ZTtZQUNBcEU7WUFDQW9NO1lBQ0F1VztRQUNGO1FBQ0FwQixZQUFZOVEsT0FBTyxHQUFHO1lBQ3BCK1EsU0FBU2tCO1lBQ1RqQixZQUFZdmQ7UUFDZDtJQUNGLEdBQUc7UUFBQ3RFO1FBQVEyUTtRQUFZMU07UUFBWUs7UUFBZThTO1FBQWdCeUw7UUFBY0M7UUFBa0J2ZTtRQUFnQkM7UUFBcUJwRTtRQUFNb007UUFBcUJ1VztLQUF3QjtJQUMzTHZOLGdCQUFnQjtRQUFFLEdBQUcrTSxpQkFBaUI7UUFDcENqVSxPQUFPMlE7UUFDUHRKLGNBQWNyUjtRQUNkbUM7UUFDQStGO1FBQ0F3SjtJQUNGO0lBQ0EsTUFBTTBPLGdCQUFnQmhvQiw4Q0FBT0EsQ0FBQztRQUM1QixNQUFNb1UsVUFBVTtZQUNkOVE7WUFDQTJRO1lBQ0E2TjtZQUNBRDtZQUNBdGE7WUFDQXdhO1lBQ0FYO1lBQ0ExRztZQUNBNVM7WUFDQUQ7WUFDQW5FO1lBQ0F3WTtZQUNBcE07WUFDQXdKO1lBQ0EwSTtZQUNBekY7WUFDQTREO1FBQ0Y7UUFDQSxPQUFPL0w7SUFDVCxHQUFHO1FBQUM5UTtRQUFRMlE7UUFBWTZOO1FBQWdCRDtRQUFnQnRhO1FBQVl3YTtRQUFtQlg7UUFBYTFHO1FBQWdCNVM7UUFBcUJEO1FBQWdCbkU7UUFBTXdZO1FBQTRCcE07UUFBcUJ3SjtRQUF5QjBJO1FBQXdCekY7UUFBb0I0RDtLQUFXO0lBQ2hTLE1BQU04SCxrQkFBa0Jqb0IsOENBQU9BLENBQUM7UUFDOUIsTUFBTW9VLFVBQVU7WUFDZHlOO1lBQ0FsTTtZQUNBclM7WUFDQXdlO1lBQ0FJLG1CQUFtQjtnQkFDakIvZSxXQUFXdWlCO1lBQ2I7WUFDQS9pQjtZQUNBK1g7WUFDQWhYO1lBQ0F3WTtRQUNGO1FBQ0EsT0FBTzlIO0lBQ1QsR0FBRztRQUFDeU47UUFBZ0JsTTtRQUFZclM7UUFBUXdlO1FBQWdCbmY7UUFBVStpQjtRQUF3QmhMO1FBQWdCaFg7UUFBTXdZO0tBQTJCO0lBQzNJLHFCQUFPeGMsMERBQW1CLENBQUN1QyxrQkFBa0JpbUIsUUFBUSxFQUFFO1FBQ3JEbmpCLE9BQU8yZjtJQUNULGlCQUFHaGxCLDBEQUFtQixDQUFDeWlCLGdCQUFnQitGLFFBQVEsRUFBRTtRQUMvQ25qQixPQUFPa2pCO0lBQ1QsaUJBQUd2b0IsMERBQW1CLENBQUMwaUIsY0FBYzhGLFFBQVEsRUFBRTtRQUM3Q25qQixPQUFPaWpCO0lBQ1QsaUJBQUd0b0IsMERBQW1CLENBQUNva0IsdUJBQXVCb0UsUUFBUSxFQUFFO1FBQ3REbmpCLE9BQU9rRjtJQUNULEdBQUdzVywwQkFBWTdnQiwwREFBbUIsQ0FBQ3NqQixjQUFjO1FBQy9DdkosVUFBVSxDQUFDNEssaUJBQWlCLE9BQU8sS0FBSyxJQUFJQSxjQUFjOEQsWUFBWSxNQUFNO0lBQzlFLG1CQUFLem9CLDBEQUFtQixDQUFDcUUsZUFBZTtRQUFFLEdBQUdzZ0IsYUFBYTtRQUN4RG5nQix5QkFBeUJ3aEI7SUFDM0I7SUFFQSxTQUFTSTtRQUNQLE1BQU1zQyxpQ0FBaUMsQ0FBQzlDLGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYWpTLGlCQUFpQixNQUFNO1FBQzVHLE1BQU1nViw2QkFBNkIsT0FBT3JPLGVBQWUsV0FBV0EsV0FBV2QsT0FBTyxLQUFLLFFBQVFjLGVBQWU7UUFDbEgsTUFBTWQsVUFBVTRMLGlCQUFpQixDQUFDc0Qsa0NBQWtDLENBQUNDO1FBRXJFLElBQUksT0FBT3JPLGVBQWUsVUFBVTtZQUNsQyxPQUFPO2dCQUFFLEdBQUdBLFVBQVU7Z0JBQ3BCZDtZQUNGO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xBO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsTUFBTW9QLGNBQWMsV0FBVyxHQUFFM29CLG9EQUFhQSxDQUFDO0FBQy9DLE1BQU00b0IsY0FBYztBQUNwQixNQUFNQyxZQUFZO0FBQ2xCLFNBQVNDLGFBQWE3bEIsSUFBSTtJQUN4QixJQUFJLEVBQ0ZXLEVBQUUsRUFDRjBELElBQUksRUFDSndTLFdBQVcsS0FBSyxFQUNoQmlQLFVBQVUsRUFDWCxHQUFHOWxCO0lBQ0osTUFBTWdPLE1BQU1wUSwrREFBV0EsQ0FBQ2dvQjtJQUN4QixNQUFNLEVBQ0o3UyxVQUFVLEVBQ1ZrTSxjQUFjLEVBQ2R2ZSxNQUFNLEVBQ053ZSxjQUFjLEVBQ2RJLGlCQUFpQixFQUNqQnhILGNBQWMsRUFDZGhYLElBQUksRUFDTCxHQUFHOUQsaURBQVVBLENBQUN1aUI7SUFDZixNQUFNLEVBQ0p3RyxPQUFPSixXQUFXLEVBQ2xCSyxrQkFBa0IsV0FBVyxFQUM3QkMsV0FBVyxDQUFDLEVBQ2IsR0FBR0gsY0FBYyxPQUFPQSxhQUFhLENBQUM7SUFDdkMsTUFBTUksYUFBYSxDQUFDeGxCLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9DLEVBQUUsTUFBTUE7SUFDN0QsTUFBTTBHLFlBQVlySyxpREFBVUEsQ0FBQ2twQixhQUFhaEYseUJBQXlCd0U7SUFDbkUsTUFBTSxDQUFDaGMsTUFBTXljLFdBQVcsR0FBR3BuQiw4REFBVUE7SUFDckMsTUFBTSxDQUFDb1UsZUFBZWlULG9CQUFvQixHQUFHcm5CLDhEQUFVQTtJQUN2RCxNQUFNYSxZQUFZc2Qsc0JBQXNCbkssWUFBWXBTO0lBQ3BELE1BQU0wbEIsVUFBVXpuQixrRUFBY0EsQ0FBQ3lGO0lBQy9CdkYsNkVBQXlCQSxDQUFDO1FBQ3hCZ1osZUFBZTRCLEdBQUcsQ0FBQy9ZLElBQUk7WUFDckJBO1lBQ0FxTjtZQUNBdEU7WUFDQXlKO1lBQ0E5TyxNQUFNZ2lCO1FBQ1I7UUFDQSxPQUFPO1lBQ0wsTUFBTTNjLE9BQU9vTyxlQUFlelMsR0FBRyxDQUFDMUU7WUFFaEMsSUFBSStJLFFBQVFBLEtBQUtzRSxHQUFHLEtBQUtBLEtBQUs7Z0JBQzVCOEosZUFBZWhZLE1BQU0sQ0FBQ2E7WUFDeEI7UUFDRjtJQUNGLEdBQ0E7UUFBQ21YO1FBQWdCblg7S0FBRztJQUNwQixNQUFNMmxCLHFCQUFxQmxwQiw4Q0FBT0EsQ0FBQyxJQUFPO1lBQ3hDMm9CO1lBQ0FFO1lBQ0EsaUJBQWlCcFA7WUFDakIsZ0JBQWdCcVAsY0FBY0gsU0FBU0osY0FBYyxPQUFPclY7WUFDNUQsd0JBQXdCMFY7WUFDeEIsb0JBQW9CMUcsa0JBQWtCL2UsU0FBUztRQUNqRCxJQUFJO1FBQUNzVztRQUFVa1A7UUFBTUU7UUFBVUM7UUFBWUY7UUFBaUIxRyxrQkFBa0IvZSxTQUFTO0tBQUM7SUFDeEYsT0FBTztRQUNMRztRQUNBdWU7UUFDQUM7UUFDQTRHLFlBQVlRO1FBQ1pKO1FBQ0F0bUIsV0FBV2lYLFdBQVd2RyxZQUFZMVE7UUFDbEM4SjtRQUNBNUk7UUFDQXFsQjtRQUNBQztRQUNBL2U7SUFDRjtBQUNGO0FBRUEsU0FBU2tmO0lBQ1AsT0FBT3ZwQixpREFBVUEsQ0FBQ3dpQjtBQUNwQjtBQUVBLE1BQU1nSCxjQUFjO0FBQ3BCLE1BQU1DLDhCQUE4QjtJQUNsQ0MsU0FBUztBQUNYO0FBQ0EsU0FBU0MsYUFBYTNtQixJQUFJO0lBQ3hCLElBQUksRUFDRnFFLElBQUksRUFDSndTLFdBQVcsS0FBSyxFQUNoQmxXLEVBQUUsRUFDRmltQixvQkFBb0IsRUFDckIsR0FBRzVtQjtJQUNKLE1BQU1nTyxNQUFNcFEsK0RBQVdBLENBQUM0b0I7SUFDeEIsTUFBTSxFQUNKOWxCLE1BQU0sRUFDTlgsUUFBUSxFQUNSZSxJQUFJLEVBQ0p3WSwwQkFBMEIsRUFDM0IsR0FBR3RjLGlEQUFVQSxDQUFDdWlCO0lBQ2YsTUFBTXNILFdBQVd4cEIsNkNBQU1BLENBQUM7UUFDdEJ3WjtJQUNGO0lBQ0EsTUFBTWlRLDBCQUEwQnpwQiw2Q0FBTUEsQ0FBQztJQUN2QyxNQUFNd0csT0FBT3hHLDZDQUFNQSxDQUFDO0lBQ3BCLE1BQU0wcEIsYUFBYTFwQiw2Q0FBTUEsQ0FBQztJQUMxQixNQUFNLEVBQ0p3WixVQUFVbVEsc0JBQXNCLEVBQ2hDQyxxQkFBcUIsRUFDckJQLFNBQVNRLHFCQUFxQixFQUMvQixHQUFHO1FBQUUsR0FBR1QsMkJBQTJCO1FBQ2xDLEdBQUdHLG9CQUFvQjtJQUN6QjtJQUNBLE1BQU1yTixNQUFNM2Esa0VBQWNBLENBQUNxb0IseUJBQXlCLE9BQU9BLHdCQUF3QnRtQjtJQUNuRixNQUFNNlosZUFBZXJkLGtEQUFXQSxDQUFDO1FBQy9CLElBQUksQ0FBQzJwQix3QkFBd0J2VixPQUFPLEVBQUU7WUFDcEMscUZBQXFGO1lBQ3JGLGtEQUFrRDtZQUNsRHVWLHdCQUF3QnZWLE9BQU8sR0FBRztZQUNsQztRQUNGO1FBRUEsSUFBSXdWLFdBQVd4VixPQUFPLElBQUksTUFBTTtZQUM5QmtELGFBQWFzUyxXQUFXeFYsT0FBTztRQUNqQztRQUVBd1YsV0FBV3hWLE9BQU8sR0FBR0osV0FBVztZQUM5Qm1JLDJCQUEyQnhXLE1BQU1xa0IsT0FBTyxDQUFDNU4sSUFBSWhJLE9BQU8sSUFBSWdJLElBQUloSSxPQUFPLEdBQUc7Z0JBQUNnSSxJQUFJaEksT0FBTzthQUFDO1lBQ25Gd1YsV0FBV3hWLE9BQU8sR0FBRztRQUN2QixHQUFHMlY7SUFDTCxHQUNBO1FBQUNBO0tBQXNCO0lBQ3ZCLE1BQU16TSxpQkFBaUJGLGtCQUFrQjtRQUN2Q0wsVUFBVU07UUFDVjNELFVBQVVtUSwwQkFBMEIsQ0FBQ3RtQjtJQUN2QztJQUNBLE1BQU1xZCxtQkFBbUI1Z0Isa0RBQVdBLENBQUMsQ0FBQ2lxQixZQUFZQztRQUNoRCxJQUFJLENBQUM1TSxnQkFBZ0I7WUFDbkI7UUFDRjtRQUVBLElBQUk0TSxpQkFBaUI7WUFDbkI1TSxlQUFlNk0sU0FBUyxDQUFDRDtZQUN6QlAsd0JBQXdCdlYsT0FBTyxHQUFHO1FBQ3BDO1FBRUEsSUFBSTZWLFlBQVk7WUFDZDNNLGVBQWVXLE9BQU8sQ0FBQ2dNO1FBQ3pCO0lBQ0YsR0FBRztRQUFDM007S0FBZTtJQUNuQixNQUFNLENBQUN1RCxTQUFTbUksV0FBVyxHQUFHcG5CLDhEQUFVQSxDQUFDZ2Y7SUFDekMsTUFBTXNJLFVBQVV6bkIsa0VBQWNBLENBQUN5RjtJQUMvQnBILGdEQUFTQSxDQUFDO1FBQ1IsSUFBSSxDQUFDd2Qsa0JBQWtCLENBQUN1RCxRQUFRek0sT0FBTyxFQUFFO1lBQ3ZDO1FBQ0Y7UUFFQWtKLGVBQWVILFVBQVU7UUFDekJ3TSx3QkFBd0J2VixPQUFPLEdBQUc7UUFDbENrSixlQUFlVyxPQUFPLENBQUM0QyxRQUFRek0sT0FBTztJQUN4QyxHQUFHO1FBQUN5TTtRQUFTdkQ7S0FBZTtJQUM1QjNiLDZFQUF5QkEsQ0FBQztRQUN4QmlCLFNBQVM7WUFDUEUsTUFBTW1DLE9BQU82ZCxpQkFBaUI7WUFDOUIvVyxTQUFTO2dCQUNQdkk7Z0JBQ0FxTjtnQkFDQTZJO2dCQUNBbk4sTUFBTXNVO2dCQUNObmE7Z0JBQ0FRLE1BQU1naUI7WUFDUjtRQUNGO1FBQ0EsT0FBTyxJQUFNdG1CLFNBQVM7Z0JBQ3BCRSxNQUFNbUMsT0FBTytkLG1CQUFtQjtnQkFDaENuUztnQkFDQXJOO1lBQ0Y7SUFDRixHQUNBO1FBQUNBO0tBQUc7SUFDSjFELGdEQUFTQSxDQUFDO1FBQ1IsSUFBSTRaLGFBQWFnUSxTQUFTdFYsT0FBTyxDQUFDc0YsUUFBUSxFQUFFO1lBQzFDOVcsU0FBUztnQkFDUEUsTUFBTW1DLE9BQU84ZCxvQkFBb0I7Z0JBQ2pDdmY7Z0JBQ0FxTjtnQkFDQTZJO1lBQ0Y7WUFDQWdRLFNBQVN0VixPQUFPLENBQUNzRixRQUFRLEdBQUdBO1FBQzlCO0lBQ0YsR0FBRztRQUFDbFc7UUFBSXFOO1FBQUs2STtRQUFVOVc7S0FBUztJQUNoQyxPQUFPO1FBQ0xXO1FBQ0FtRDtRQUNBMGpCLFFBQVEsQ0FBQ3ptQixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxFQUFFLE1BQU1BO1FBQzlDK0ksTUFBTXNVO1FBQ05sZDtRQUNBcWxCO0lBQ0Y7QUFDRjtBQUVBLFNBQVNxQixpQkFBaUJ4bkIsSUFBSTtJQUM1QixJQUFJLEVBQ0Z5bkIsU0FBUyxFQUNUOUosUUFBUSxFQUNULEdBQUczZDtJQUNKLE1BQU0sQ0FBQzBuQixnQkFBZ0JDLGtCQUFrQixHQUFHenFCLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQ2dNLFNBQVMwZSxXQUFXLEdBQUcxcUIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTTJxQixtQkFBbUJscEIsK0RBQVdBLENBQUNnZjtJQUVyQyxJQUFJLENBQUNBLFlBQVksQ0FBQytKLGtCQUFrQkcsa0JBQWtCO1FBQ3BERixrQkFBa0JFO0lBQ3BCO0lBRUEvb0IsNkVBQXlCQSxDQUFDO1FBQ3hCLElBQUksQ0FBQ29LLFNBQVM7WUFDWjtRQUNGO1FBRUEsTUFBTThFLE1BQU0wWixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWUxWixHQUFHO1FBQ2hFLE1BQU1yTixLQUFLK21CLGtCQUFrQixPQUFPLEtBQUssSUFBSUEsZUFBZWxYLEtBQUssQ0FBQzdQLEVBQUU7UUFFcEUsSUFBSXFOLE9BQU8sUUFBUXJOLE1BQU0sTUFBTTtZQUM3QmduQixrQkFBa0I7WUFDbEI7UUFDRjtRQUVBakQsUUFBUUMsT0FBTyxDQUFDOEMsVUFBVTltQixJQUFJdUksVUFBVTRlLElBQUksQ0FBQztZQUMzQ0gsa0JBQWtCO1FBQ3BCO0lBQ0YsR0FBRztRQUFDRjtRQUFXQztRQUFnQnhlO0tBQVE7SUFDdkMscUJBQU9wTSwwREFBbUIsQ0FBQ0EsdURBQWMsRUFBRSxNQUFNNmdCLFVBQVUrSiwrQkFBaUJscUIsbURBQVlBLENBQUNrcUIsZ0JBQWdCO1FBQ3ZHSyxLQUFLSDtJQUNQLEtBQUs7QUFDUDtBQUVBLE1BQU1JLG1CQUFtQjtJQUN2QjVrQixHQUFHO0lBQ0hDLEdBQUc7SUFDSG1FLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBQ0EsU0FBU3dnQix5QkFBeUJqb0IsSUFBSTtJQUNwQyxJQUFJLEVBQ0YyZCxRQUFRLEVBQ1QsR0FBRzNkO0lBQ0oscUJBQU9sRCwwREFBbUIsQ0FBQ3lpQixnQkFBZ0IrRixRQUFRLEVBQUU7UUFDbkRuakIsT0FBT2tkO0lBQ1QsaUJBQUd2aUIsMERBQW1CLENBQUNva0IsdUJBQXVCb0UsUUFBUSxFQUFFO1FBQ3REbmpCLE9BQU82bEI7SUFDVCxHQUFHcks7QUFDTDtBQUVBLE1BQU11SyxhQUFhO0lBQ2pCdGUsVUFBVTtJQUNWdWUsYUFBYTtBQUNmO0FBRUEsTUFBTUMsb0JBQW9CbkosQ0FBQUE7SUFDeEIsTUFBTW9KLHNCQUFzQjlwQixtRUFBZUEsQ0FBQzBnQjtJQUM1QyxPQUFPb0osc0JBQXNCLHlCQUF5Qi9YO0FBQ3hEO0FBRUEsTUFBTWdZLG9CQUFvQixXQUFXLEdBQUU3cUIsaURBQVVBLENBQUMsQ0FBQ3VDLE1BQU0rbkI7SUFDdkQsSUFBSSxFQUNGUSxFQUFFLEVBQ0Z0SixjQUFjLEVBQ2Q3WCxXQUFXLEVBQ1h1VyxRQUFRLEVBQ1I2SyxTQUFTLEVBQ1Qza0IsSUFBSSxFQUNKNGtCLEtBQUssRUFDTHBoQixTQUFTLEVBQ1RxaEIsYUFBYU4saUJBQWlCLEVBQy9CLEdBQUdwb0I7SUFFSixJQUFJLENBQUM2RCxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBRUEsTUFBTThrQix5QkFBeUJ2aEIsY0FBY0MsWUFBWTtRQUFFLEdBQUdBLFNBQVM7UUFDckVHLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsTUFBTW1oQixTQUFTO1FBQUUsR0FBR1YsVUFBVTtRQUM1QmprQixPQUFPSixLQUFLSSxLQUFLO1FBQ2pCRSxRQUFRTixLQUFLTSxNQUFNO1FBQ25CRCxLQUFLTCxLQUFLSyxHQUFHO1FBQ2JGLE1BQU1ILEtBQUtHLElBQUk7UUFDZnFELFdBQVdwSSxtREFBR0EsQ0FBQzRwQixTQUFTLENBQUNDLFFBQVEsQ0FBQ0g7UUFDbEM1a0IsaUJBQWlCcUQsZUFBZTZYLGlCQUFpQnJiLDJCQUEyQnFiLGdCQUFnQnBiLFFBQVF5TTtRQUNwR29ZLFlBQVksT0FBT0EsZUFBZSxhQUFhQSxXQUFXekosa0JBQWtCeUo7UUFDNUUsR0FBR0QsS0FBSztJQUNWO0lBQ0EscUJBQU8zckIsMERBQW1CLENBQUN5ckIsSUFBSTtRQUM3QkM7UUFDQUMsT0FBT0c7UUFDUGI7SUFDRixHQUFHcEs7QUFDTDtBQUVBLE1BQU1vTCxrQ0FBa0N2bUIsQ0FBQUEsVUFBV3hDLENBQUFBO1FBQ2pELElBQUksRUFDRlUsTUFBTSxFQUNOOGQsV0FBVyxFQUNaLEdBQUd4ZTtRQUNKLE1BQU1ncEIsaUJBQWlCLENBQUM7UUFDeEIsTUFBTSxFQUNKSixNQUFNLEVBQ05KLFNBQVMsRUFDVixHQUFHaG1CO1FBRUosSUFBSW9tQixVQUFVLFFBQVFBLE9BQU9sb0IsTUFBTSxFQUFFO1lBQ25DLEtBQUssTUFBTSxDQUFDc04sS0FBSzdMLE1BQU0sSUFBSWUsT0FBT3VaLE9BQU8sQ0FBQ21NLE9BQU9sb0IsTUFBTSxFQUFHO2dCQUN4RCxJQUFJeUIsVUFBVW1PLFdBQVc7b0JBQ3ZCO2dCQUNGO2dCQUVBMFksY0FBYyxDQUFDaGIsSUFBSSxHQUFHdE4sT0FBT2dKLElBQUksQ0FBQytlLEtBQUssQ0FBQ1EsZ0JBQWdCLENBQUNqYjtnQkFDekR0TixPQUFPZ0osSUFBSSxDQUFDK2UsS0FBSyxDQUFDUyxXQUFXLENBQUNsYixLQUFLN0w7WUFDckM7UUFDRjtRQUVBLElBQUl5bUIsVUFBVSxRQUFRQSxPQUFPcEssV0FBVyxFQUFFO1lBQ3hDLEtBQUssTUFBTSxDQUFDeFEsS0FBSzdMLE1BQU0sSUFBSWUsT0FBT3VaLE9BQU8sQ0FBQ21NLE9BQU9wSyxXQUFXLEVBQUc7Z0JBQzdELElBQUlyYyxVQUFVbU8sV0FBVztvQkFDdkI7Z0JBQ0Y7Z0JBRUFrTyxZQUFZOVUsSUFBSSxDQUFDK2UsS0FBSyxDQUFDUyxXQUFXLENBQUNsYixLQUFLN0w7WUFDMUM7UUFDRjtRQUVBLElBQUlxbUIsYUFBYSxRQUFRQSxVQUFVOW5CLE1BQU0sRUFBRTtZQUN6Q0EsT0FBT2dKLElBQUksQ0FBQ3lmLFNBQVMsQ0FBQzdxQixHQUFHLENBQUNrcUIsVUFBVTluQixNQUFNO1FBQzVDO1FBRUEsSUFBSThuQixhQUFhLFFBQVFBLFVBQVVoSyxXQUFXLEVBQUU7WUFDOUNBLFlBQVk5VSxJQUFJLENBQUN5ZixTQUFTLENBQUM3cUIsR0FBRyxDQUFDa3FCLFVBQVVoSyxXQUFXO1FBQ3REO1FBRUEsT0FBTyxTQUFTaEM7WUFDZCxLQUFLLE1BQU0sQ0FBQ3hPLEtBQUs3TCxNQUFNLElBQUllLE9BQU91WixPQUFPLENBQUN1TSxnQkFBaUI7Z0JBQ3pEdG9CLE9BQU9nSixJQUFJLENBQUMrZSxLQUFLLENBQUNTLFdBQVcsQ0FBQ2xiLEtBQUs3TDtZQUNyQztZQUVBLElBQUlxbUIsYUFBYSxRQUFRQSxVQUFVOW5CLE1BQU0sRUFBRTtnQkFDekNBLE9BQU9nSixJQUFJLENBQUN5ZixTQUFTLENBQUNDLE1BQU0sQ0FBQ1osVUFBVTluQixNQUFNO1lBQy9DO1FBQ0Y7SUFDRjtBQUVBLE1BQU0yb0IsMEJBQTBCeG9CLENBQUFBO0lBQzlCLElBQUksRUFDRndHLFdBQVcsRUFDVGliLE9BQU8sRUFDUGdILEtBQUssRUFDTixFQUNGLEdBQUd6b0I7SUFDSixPQUFPO1FBQUM7WUFDTndHLFdBQVdwSSxtREFBR0EsQ0FBQzRwQixTQUFTLENBQUNDLFFBQVEsQ0FBQ3hHO1FBQ3BDO1FBQUc7WUFDRGpiLFdBQVdwSSxtREFBR0EsQ0FBQzRwQixTQUFTLENBQUNDLFFBQVEsQ0FBQ1E7UUFDcEM7S0FBRTtBQUNKO0FBRUEsTUFBTUMsb0NBQW9DO0lBQ3hDQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsV0FBV0w7SUFDWE0sYUFBYSxXQUFXLEdBQUVaLGdDQUFnQztRQUN4REgsUUFBUTtZQUNObG9CLFFBQVE7Z0JBQ05rcEIsU0FBUztZQUNYO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsaUJBQWlCN29CLEtBQUs7SUFDN0IsSUFBSSxFQUNGOFgsTUFBTSxFQUNOaEIsY0FBYyxFQUNkNVMsbUJBQW1CLEVBQ25Ca2Esc0JBQXNCLEVBQ3ZCLEdBQUdwZTtJQUNKLE9BQU9uQyw0REFBUUEsQ0FBQyxDQUFDOEIsSUFBSStJO1FBQ25CLElBQUlvUCxXQUFXLE1BQU07WUFDbkI7UUFDRjtRQUVBLE1BQU1nUixrQkFBa0JoUyxlQUFlelMsR0FBRyxDQUFDMUU7UUFFM0MsSUFBSSxDQUFDbXBCLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTXpZLGFBQWF5WSxnQkFBZ0JwZ0IsSUFBSSxDQUFDNkgsT0FBTztRQUUvQyxJQUFJLENBQUNGLFlBQVk7WUFDZjtRQUNGO1FBRUEsTUFBTTBZLGlCQUFpQnJNLGtCQUFrQmhVO1FBRXpDLElBQUksQ0FBQ3FnQixnQkFBZ0I7WUFDbkI7UUFDRjtRQUVBLE1BQU0sRUFDSjFpQixTQUFTLEVBQ1YsR0FBR3ZKLDZEQUFTQSxDQUFDNEwsTUFBTU4sZ0JBQWdCLENBQUNNO1FBQ3JDLE1BQU1sQixrQkFBa0JOLGVBQWViO1FBRXZDLElBQUksQ0FBQ21CLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTWlmLFlBQVksT0FBTzNPLFdBQVcsYUFBYUEsU0FBU2tSLDJCQUEyQmxSO1FBQ3JGekwsdUJBQXVCZ0UsWUFBWStOLHVCQUF1QjdlLFNBQVMsQ0FBQytNLE9BQU87UUFDM0UsT0FBT21hLFVBQVU7WUFDZi9tQixRQUFRO2dCQUNOQztnQkFDQTBELE1BQU15bEIsZ0JBQWdCemxCLElBQUk7Z0JBQzFCcUYsTUFBTTJIO2dCQUNOeE4sTUFBTXViLHVCQUF1QjdlLFNBQVMsQ0FBQytNLE9BQU8sQ0FBQytEO1lBQ2pEO1lBQ0F5RztZQUNBMEcsYUFBYTtnQkFDWDlVO2dCQUNBN0YsTUFBTXViLHVCQUF1QlosV0FBVyxDQUFDbFIsT0FBTyxDQUFDeWM7WUFDbkQ7WUFDQTdrQjtZQUNBa2E7WUFDQS9YLFdBQVdtQjtRQUNiO0lBQ0Y7QUFDRjtBQUVBLFNBQVN3aEIsMkJBQTJCeG5CLE9BQU87SUFDekMsTUFBTSxFQUNKZ25CLFFBQVEsRUFDUkMsTUFBTSxFQUNORSxXQUFXLEVBQ1hELFNBQVMsRUFDVixHQUFHO1FBQUUsR0FBR0gsaUNBQWlDO1FBQ3hDLEdBQUcvbUIsT0FBTztJQUNaO0lBQ0EsT0FBT3RCLENBQUFBO1FBQ0wsSUFBSSxFQUNGUixNQUFNLEVBQ044ZCxXQUFXLEVBQ1huWCxTQUFTLEVBQ1QsR0FBRzRpQixNQUNKLEdBQUcvb0I7UUFFSixJQUFJLENBQUNzb0IsVUFBVTtZQUNiLGdEQUFnRDtZQUNoRDtRQUNGO1FBRUEsTUFBTXhhLFFBQVE7WUFDWjVMLEdBQUdvYixZQUFZM2EsSUFBSSxDQUFDRyxJQUFJLEdBQUd0RCxPQUFPbUQsSUFBSSxDQUFDRyxJQUFJO1lBQzNDWCxHQUFHbWIsWUFBWTNhLElBQUksQ0FBQ0ssR0FBRyxHQUFHeEQsT0FBT21ELElBQUksQ0FBQ0ssR0FBRztRQUMzQztRQUNBLE1BQU1nbUIsUUFBUTtZQUNaMWlCLFFBQVFILFVBQVVHLE1BQU0sS0FBSyxJQUFJOUcsT0FBT21ELElBQUksQ0FBQ0ksS0FBSyxHQUFHb0QsVUFBVUcsTUFBTSxHQUFHZ1gsWUFBWTNhLElBQUksQ0FBQ0ksS0FBSyxHQUFHO1lBQ2pHd0QsUUFBUUosVUFBVUksTUFBTSxLQUFLLElBQUkvRyxPQUFPbUQsSUFBSSxDQUFDTSxNQUFNLEdBQUdrRCxVQUFVSSxNQUFNLEdBQUcrVyxZQUFZM2EsSUFBSSxDQUFDTSxNQUFNLEdBQUc7UUFDckc7UUFDQSxNQUFNZ21CLGlCQUFpQjtZQUNyQi9tQixHQUFHaUUsVUFBVWpFLENBQUMsR0FBRzRMLE1BQU01TCxDQUFDO1lBQ3hCQyxHQUFHZ0UsVUFBVWhFLENBQUMsR0FBRzJMLE1BQU0zTCxDQUFDO1lBQ3hCLEdBQUc2bUIsS0FBSztRQUNWO1FBQ0EsTUFBTUUscUJBQXFCVixVQUFVO1lBQUUsR0FBR08sSUFBSTtZQUM1Q3ZwQjtZQUNBOGQ7WUFDQW5YLFdBQVc7Z0JBQ1RpYixTQUFTamI7Z0JBQ1RpaUIsT0FBT2E7WUFDVDtRQUNGO1FBQ0EsTUFBTSxDQUFDRSxjQUFjLEdBQUdEO1FBQ3hCLE1BQU1FLGVBQWVGLGtCQUFrQixDQUFDQSxtQkFBbUJ4bkIsTUFBTSxHQUFHLEVBQUU7UUFFdEUsSUFBSTJVLEtBQUtDLFNBQVMsQ0FBQzZTLG1CQUFtQjlTLEtBQUtDLFNBQVMsQ0FBQzhTLGVBQWU7WUFDbEUscUZBQXFGO1lBQ3JGO1FBQ0Y7UUFFQSxNQUFNOU4sVUFBVW1OLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVk7WUFDekRqcEI7WUFDQThkO1lBQ0EsR0FBR3lMLElBQUk7UUFDVDtRQUNBLE1BQU14QyxZQUFZakosWUFBWTlVLElBQUksQ0FBQzZnQixPQUFPLENBQUNILG9CQUFvQjtZQUM3RFo7WUFDQUM7WUFDQWUsTUFBTTtRQUNSO1FBQ0EsT0FBTyxJQUFJOUYsUUFBUUMsQ0FBQUE7WUFDakI4QyxVQUFVZ0QsUUFBUSxHQUFHO2dCQUNuQmpPLFdBQVcsT0FBTyxLQUFLLElBQUlBO2dCQUMzQm1JO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFJM1csTUFBTTtBQUNWLFNBQVMwYyxPQUFPL3BCLEVBQUU7SUFDaEIsT0FBT3ZELDhDQUFPQSxDQUFDO1FBQ2IsSUFBSXVELE1BQU0sTUFBTTtZQUNkO1FBQ0Y7UUFFQXFOO1FBQ0EsT0FBT0E7SUFDVCxHQUFHO1FBQUNyTjtLQUFHO0FBQ1Q7QUFFQSxNQUFNZ3FCLGNBQWMsV0FBVyxHQUFFN3RCLGlEQUFVLENBQUNrRCxDQUFBQTtJQUMxQyxJQUFJLEVBQ0ZvSCxjQUFjLEtBQUssRUFDbkJ1VyxRQUFRLEVBQ1JpTixlQUFlQyxtQkFBbUIsRUFDbENwQyxLQUFLLEVBQ0xDLFVBQVUsRUFDVjlILFNBQVMsRUFDVGtLLGlCQUFpQixLQUFLLEVBQ3RCdEMsU0FBUyxFQUNUdUMsU0FBUyxHQUFHLEVBQ2IsR0FBRy9xQjtJQUNKLE1BQU0sRUFDSmlmLGNBQWMsRUFDZHZlLE1BQU0sRUFDTndlLGNBQWMsRUFDZEMsaUJBQWlCLEVBQ2pCckgsY0FBYyxFQUNkNVMsbUJBQW1CLEVBQ25Cc1osV0FBVyxFQUNYMWQsSUFBSSxFQUNKc2Usc0JBQXNCLEVBQ3RCbFMsbUJBQW1CLEVBQ25Cd0osdUJBQXVCLEVBQ3ZCNkcsVUFBVSxFQUNYLEdBQUdnSjtJQUNKLE1BQU1sZixZQUFZckssaURBQVVBLENBQUNra0I7SUFDN0IsTUFBTWxULE1BQU0wYyxPQUFPaHFCLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU9DLEVBQUU7SUFDdEQsTUFBTXFxQixvQkFBb0JySyxlQUFlQyxXQUFXO1FBQ2xEM0I7UUFDQXZlO1FBQ0F3ZTtRQUNBQztRQUNBcUUsa0JBQWtCaEYsWUFBWTNhLElBQUk7UUFDbEMvQztRQUNBZ2pCLGlCQUFpQnRGLFlBQVkzYSxJQUFJO1FBQ2pDcUo7UUFDQXdKO1FBQ0FyUDtRQUNBa1c7SUFDRjtJQUNBLE1BQU0zQixjQUFjOUIsZ0JBQWdCb0Y7SUFDcEMsTUFBTTBMLGdCQUFnQmYsaUJBQWlCO1FBQ3JDL1EsUUFBUStSO1FBQ1IvUztRQUNBNVM7UUFDQWthO0lBQ0YsSUFBSSw0RkFBNEY7SUFDaEcsNEVBQTRFO0lBRTVFLE1BQU0ySSxNQUFNbk0sY0FBYzRDLFlBQVlQLE1BQU0sR0FBRzNOO0lBQy9DLHFCQUFPeFQsMERBQW1CLENBQUNtckIsMEJBQTBCLG9CQUFNbnJCLDBEQUFtQixDQUFDMHFCLGtCQUFrQjtRQUMvRkMsV0FBV21EO0lBQ2IsR0FBR2xxQixVQUFVc04sb0JBQU1sUiwwREFBbUIsQ0FBQ3dyQixtQkFBbUI7UUFDeER0YSxLQUFLQTtRQUNMck4sSUFBSUQsT0FBT0MsRUFBRTtRQUNib25CLEtBQUtBO1FBQ0xRLElBQUl1QztRQUNKN0wsZ0JBQWdCQTtRQUNoQjdYLGFBQWFBO1FBQ2JvaEIsV0FBV0E7UUFDWEUsWUFBWUE7UUFDWjdrQixNQUFNK1g7UUFDTjZNLE9BQU87WUFDTHNDO1lBQ0EsR0FBR3RDLEtBQUs7UUFDVjtRQUNBcGhCLFdBQVcyakI7SUFDYixHQUFHck4sWUFBWTtBQUNqQjtBQUV3akIsQ0FDeGpCLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3BheWxvYWQtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9jb3JlL2Rpc3QvY29yZS5lc20uanM/OTgxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIHVzZVJlZiwgdXNlUmVkdWNlciwgbWVtbywgY2xvbmVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB9IGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyB1c2VVbmlxdWVJZCwgZ2V0RXZlbnRDb29yZGluYXRlcywgZ2V0V2luZG93LCBpc0RvY3VtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NWR0VsZW1lbnQsIGNhblVzZURPTSwgaXNXaW5kb3csIGlzTm9kZSwgZ2V0T3duZXJEb2N1bWVudCwgYWRkLCBpc0tleWJvYXJkRXZlbnQsIHN1YnRyYWN0LCB1c2VMYXp5TWVtbywgdXNlSW50ZXJ2YWwsIHVzZVByZXZpb3VzLCB1c2VMYXRlc3RWYWx1ZSwgdXNlRXZlbnQsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QsIHVzZU5vZGVSZWYsIGZpbmRGaXJzdEZvY3VzYWJsZU5vZGUsIENTUyB9IGZyb20gJ0BkbmQta2l0L3V0aWxpdGllcyc7XG5pbXBvcnQgeyB1c2VBbm5vdW5jZW1lbnQsIEhpZGRlblRleHQsIExpdmVSZWdpb24gfSBmcm9tICdAZG5kLWtpdC9hY2Nlc3NpYmlsaXR5JztcblxuY29uc3QgRG5kTW9uaXRvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gdXNlRG5kTW9uaXRvcihsaXN0ZW5lcikge1xuICBjb25zdCByZWdpc3Rlckxpc3RlbmVyID0gdXNlQ29udGV4dChEbmRNb25pdG9yQ29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZWdpc3Rlckxpc3RlbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZURuZE1vbml0b3IgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIGNoaWxkcmVuIG9mIDxEbmRDb250ZXh0PicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gcmVnaXN0ZXJMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbbGlzdGVuZXIsIHJlZ2lzdGVyTGlzdGVuZXJdKTtcbn1cblxuZnVuY3Rpb24gdXNlRG5kTW9uaXRvclByb3ZpZGVyKCkge1xuICBjb25zdCBbbGlzdGVuZXJzXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBTZXQoKSk7XG4gIGNvbnN0IHJlZ2lzdGVyTGlzdGVuZXIgPSB1c2VDYWxsYmFjayhsaXN0ZW5lciA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9LCBbbGlzdGVuZXJzXSk7XG4gIGNvbnN0IGRpc3BhdGNoID0gdXNlQ2FsbGJhY2soX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHR5cGUsXG4gICAgICBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgIHZhciBfbGlzdGVuZXIkdHlwZTtcblxuICAgICAgcmV0dXJuIChfbGlzdGVuZXIkdHlwZSA9IGxpc3RlbmVyW3R5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX2xpc3RlbmVyJHR5cGUuY2FsbChsaXN0ZW5lciwgZXZlbnQpO1xuICAgIH0pO1xuICB9LCBbbGlzdGVuZXJzXSk7XG4gIHJldHVybiBbZGlzcGF0Y2gsIHJlZ2lzdGVyTGlzdGVuZXJdO1xufVxuXG5jb25zdCBkZWZhdWx0U2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zID0ge1xuICBkcmFnZ2FibGU6IFwiXFxuICAgIFRvIHBpY2sgdXAgYSBkcmFnZ2FibGUgaXRlbSwgcHJlc3MgdGhlIHNwYWNlIGJhci5cXG4gICAgV2hpbGUgZHJhZ2dpbmcsIHVzZSB0aGUgYXJyb3cga2V5cyB0byBtb3ZlIHRoZSBpdGVtLlxcbiAgICBQcmVzcyBzcGFjZSBhZ2FpbiB0byBkcm9wIHRoZSBpdGVtIGluIGl0cyBuZXcgcG9zaXRpb24sIG9yIHByZXNzIGVzY2FwZSB0byBjYW5jZWwuXFxuICBcIlxufTtcbmNvbnN0IGRlZmF1bHRBbm5vdW5jZW1lbnRzID0ge1xuICBvbkRyYWdTdGFydChfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZVxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBcIlBpY2tlZCB1cCBkcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiLlwiO1xuICB9LFxuXG4gIG9uRHJhZ092ZXIoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgb3ZlclxuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmIChvdmVyKSB7XG4gICAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBtb3ZlZCBvdmVyIGRyb3BwYWJsZSBhcmVhIFwiICsgb3Zlci5pZCArIFwiLlwiO1xuICAgIH1cblxuICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgaXMgbm8gbG9uZ2VyIG92ZXIgYSBkcm9wcGFibGUgYXJlYS5cIjtcbiAgfSxcblxuICBvbkRyYWdFbmQoX3JlZjMpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgb3ZlclxuICAgIH0gPSBfcmVmMztcblxuICAgIGlmIChvdmVyKSB7XG4gICAgICByZXR1cm4gXCJEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkIG92ZXIgZHJvcHBhYmxlIGFyZWEgXCIgKyBvdmVyLmlkO1xuICAgIH1cblxuICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgd2FzIGRyb3BwZWQuXCI7XG4gIH0sXG5cbiAgb25EcmFnQ2FuY2VsKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZVxuICAgIH0gPSBfcmVmNDtcbiAgICByZXR1cm4gXCJEcmFnZ2luZyB3YXMgY2FuY2VsbGVkLiBEcmFnZ2FibGUgaXRlbSBcIiArIGFjdGl2ZS5pZCArIFwiIHdhcyBkcm9wcGVkLlwiO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIEFjY2Vzc2liaWxpdHkoX3JlZikge1xuICBsZXQge1xuICAgIGFubm91bmNlbWVudHMgPSBkZWZhdWx0QW5ub3VuY2VtZW50cyxcbiAgICBjb250YWluZXIsXG4gICAgaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQsXG4gICAgc2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zID0gZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9uc1xuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGFubm91bmNlLFxuICAgIGFubm91bmNlbWVudFxuICB9ID0gdXNlQW5ub3VuY2VtZW50KCk7XG4gIGNvbnN0IGxpdmVSZWdpb25JZCA9IHVzZVVuaXF1ZUlkKFwiRG5kTGl2ZVJlZ2lvblwiKTtcbiAgY29uc3QgW21vdW50ZWQsIHNldE1vdW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE1vdW50ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcbiAgdXNlRG5kTW9uaXRvcih1c2VNZW1vKCgpID0+ICh7XG4gICAgb25EcmFnU3RhcnQoX3JlZjIpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZVxuICAgICAgfSA9IF9yZWYyO1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdTdGFydCh7XG4gICAgICAgIGFjdGl2ZVxuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBvbkRyYWdNb3ZlKF9yZWYzKSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmMztcblxuICAgICAgaWYgKGFubm91bmNlbWVudHMub25EcmFnTW92ZSkge1xuICAgICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ01vdmUoe1xuICAgICAgICAgIGFjdGl2ZSxcbiAgICAgICAgICBvdmVyXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25EcmFnT3ZlcihfcmVmNCkge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjQ7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ092ZXIoe1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgb25EcmFnRW5kKF9yZWY1KSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmNTtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnRW5kKHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uRHJhZ0NhbmNlbChfcmVmNikge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9ID0gX3JlZjY7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ0NhbmNlbCh7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSkpO1xuICAgIH1cblxuICB9KSwgW2Fubm91bmNlLCBhbm5vdW5jZW1lbnRzXSkpO1xuXG4gIGlmICghbW91bnRlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgbWFya3VwID0gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChIaWRkZW5UZXh0LCB7XG4gICAgaWQ6IGhpZGRlblRleHREZXNjcmliZWRCeUlkLFxuICAgIHZhbHVlOiBzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMuZHJhZ2dhYmxlXG4gIH0pLCBSZWFjdC5jcmVhdGVFbGVtZW50KExpdmVSZWdpb24sIHtcbiAgICBpZDogbGl2ZVJlZ2lvbklkLFxuICAgIGFubm91bmNlbWVudDogYW5ub3VuY2VtZW50XG4gIH0pKTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IGNyZWF0ZVBvcnRhbChtYXJrdXAsIGNvbnRhaW5lcikgOiBtYXJrdXA7XG59XG5cbnZhciBBY3Rpb247XG5cbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIEFjdGlvbltcIkRyYWdTdGFydFwiXSA9IFwiZHJhZ1N0YXJ0XCI7XG4gIEFjdGlvbltcIkRyYWdNb3ZlXCJdID0gXCJkcmFnTW92ZVwiO1xuICBBY3Rpb25bXCJEcmFnRW5kXCJdID0gXCJkcmFnRW5kXCI7XG4gIEFjdGlvbltcIkRyYWdDYW5jZWxcIl0gPSBcImRyYWdDYW5jZWxcIjtcbiAgQWN0aW9uW1wiRHJhZ092ZXJcIl0gPSBcImRyYWdPdmVyXCI7XG4gIEFjdGlvbltcIlJlZ2lzdGVyRHJvcHBhYmxlXCJdID0gXCJyZWdpc3RlckRyb3BwYWJsZVwiO1xuICBBY3Rpb25bXCJTZXREcm9wcGFibGVEaXNhYmxlZFwiXSA9IFwic2V0RHJvcHBhYmxlRGlzYWJsZWRcIjtcbiAgQWN0aW9uW1wiVW5yZWdpc3RlckRyb3BwYWJsZVwiXSA9IFwidW5yZWdpc3RlckRyb3BwYWJsZVwiO1xufSkoQWN0aW9uIHx8IChBY3Rpb24gPSB7fSkpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdXNlU2Vuc29yKHNlbnNvciwgb3B0aW9ucykge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgIHNlbnNvcixcbiAgICBvcHRpb25zOiBvcHRpb25zICE9IG51bGwgPyBvcHRpb25zIDoge31cbiAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3NlbnNvciwgb3B0aW9uc10pO1xufVxuXG5mdW5jdGlvbiB1c2VTZW5zb3JzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc2Vuc29ycyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzZW5zb3JzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gWy4uLnNlbnNvcnNdLmZpbHRlcihzZW5zb3IgPT4gc2Vuc29yICE9IG51bGwpLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFsuLi5zZW5zb3JzXSk7XG59XG5cbmNvbnN0IGRlZmF1bHRDb29yZGluYXRlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgeDogMCxcbiAgeTogMFxufSk7XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICovXG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW4ocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDEueCAtIHAyLngsIDIpICsgTWF0aC5wb3cocDEueSAtIHAyLnksIDIpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVUcmFuc2Zvcm1PcmlnaW4oZXZlbnQsIHJlY3QpIHtcbiAgY29uc3QgZXZlbnRDb29yZGluYXRlcyA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuXG4gIGlmICghZXZlbnRDb29yZGluYXRlcykge1xuICAgIHJldHVybiAnMCAwJztcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybU9yaWdpbiA9IHtcbiAgICB4OiAoZXZlbnRDb29yZGluYXRlcy54IC0gcmVjdC5sZWZ0KSAvIHJlY3Qud2lkdGggKiAxMDAsXG4gICAgeTogKGV2ZW50Q29vcmRpbmF0ZXMueSAtIHJlY3QudG9wKSAvIHJlY3QuaGVpZ2h0ICogMTAwXG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1PcmlnaW4ueCArIFwiJSBcIiArIHRyYW5zZm9ybU9yaWdpbi55ICsgXCIlXCI7XG59XG5cbi8qKlxyXG4gKiBTb3J0IGNvbGxpc2lvbnMgZnJvbSBzbWFsbGVzdCB0byBncmVhdGVzdCB2YWx1ZVxyXG4gKi9cbmZ1bmN0aW9uIHNvcnRDb2xsaXNpb25zQXNjKF9yZWYsIF9yZWYyKSB7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGFcbiAgICB9XG4gIH0gPSBfcmVmO1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBiXG4gICAgfVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiBhIC0gYjtcbn1cbi8qKlxyXG4gKiBTb3J0IGNvbGxpc2lvbnMgZnJvbSBncmVhdGVzdCB0byBzbWFsbGVzdCB2YWx1ZVxyXG4gKi9cblxuZnVuY3Rpb24gc29ydENvbGxpc2lvbnNEZXNjKF9yZWYzLCBfcmVmNCkge1xuICBsZXQge1xuICAgIGRhdGE6IHtcbiAgICAgIHZhbHVlOiBhXG4gICAgfVxuICB9ID0gX3JlZjM7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGJcbiAgICB9XG4gIH0gPSBfcmVmNDtcbiAgcmV0dXJuIGIgLSBhO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBjb3JuZXJzIG9mIGEgZ2l2ZW4gcmVjdGFuZ2xlOlxyXG4gKiBbVG9wTGVmdCB7eCwgeX0sIFRvcFJpZ2h0IHt4LCB5fSwgQm90dG9tTGVmdCB7eCwgeX0sIEJvdHRvbVJpZ2h0IHt4LCB5fV1cclxuICovXG5cbmZ1bmN0aW9uIGNvcm5lcnNPZlJlY3RhbmdsZShfcmVmNSkge1xuICBsZXQge1xuICAgIGxlZnQsXG4gICAgdG9wLFxuICAgIGhlaWdodCxcbiAgICB3aWR0aFxuICB9ID0gX3JlZjU7XG4gIHJldHVybiBbe1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wXG4gIH0sIHtcbiAgICB4OiBsZWZ0ICsgd2lkdGgsXG4gICAgeTogdG9wXG4gIH0sIHtcbiAgICB4OiBsZWZ0LFxuICAgIHk6IHRvcCArIGhlaWdodFxuICB9LCB7XG4gICAgeDogbGVmdCArIHdpZHRoLFxuICAgIHk6IHRvcCArIGhlaWdodFxuICB9XTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0Q29sbGlzaW9uKGNvbGxpc2lvbnMsIHByb3BlcnR5KSB7XG4gIGlmICghY29sbGlzaW9ucyB8fCBjb2xsaXNpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgW2ZpcnN0Q29sbGlzaW9uXSA9IGNvbGxpc2lvbnM7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGZpcnN0Q29sbGlzaW9uW3Byb3BlcnR5XSA6IGZpcnN0Q29sbGlzaW9uO1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBvZiBhIGdpdmVuIENsaWVudFJlY3RcclxuICovXG5cbmZ1bmN0aW9uIGNlbnRlck9mUmVjdGFuZ2xlKHJlY3QsIGxlZnQsIHRvcCkge1xuICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7XG4gICAgbGVmdCA9IHJlY3QubGVmdDtcbiAgfVxuXG4gIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgIHRvcCA9IHJlY3QudG9wO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBsZWZ0ICsgcmVjdC53aWR0aCAqIDAuNSxcbiAgICB5OiB0b3AgKyByZWN0LmhlaWdodCAqIDAuNVxuICB9O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNsb3Nlc3QgcmVjdGFuZ2xlcyBmcm9tIGFuIGFycmF5IG9mIHJlY3RhbmdsZXMgdG8gdGhlIGNlbnRlciBvZiBhIGdpdmVuXHJcbiAqIHJlY3RhbmdsZS5cclxuICovXG5cblxuY29uc3QgY2xvc2VzdENlbnRlciA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY2VudGVyUmVjdCA9IGNlbnRlck9mUmVjdGFuZ2xlKGNvbGxpc2lvblJlY3QsIGNvbGxpc2lvblJlY3QubGVmdCwgY29sbGlzaW9uUmVjdC50b3ApO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCBkaXN0QmV0d2VlbiA9IGRpc3RhbmNlQmV0d2VlbihjZW50ZXJPZlJlY3RhbmdsZShyZWN0KSwgY2VudGVyUmVjdCk7XG4gICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICB2YWx1ZTogZGlzdEJldHdlZW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0FzYyk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgY2xvc2VzdCByZWN0YW5nbGVzIGZyb20gYW4gYXJyYXkgb2YgcmVjdGFuZ2xlcyB0byB0aGUgY29ybmVycyBvZlxyXG4gKiBhbm90aGVyIHJlY3RhbmdsZS5cclxuICovXG5cbmNvbnN0IGNsb3Nlc3RDb3JuZXJzID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgY29sbGlzaW9uUmVjdCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBjb3JuZXJzID0gY29ybmVyc09mUmVjdGFuZ2xlKGNvbGxpc2lvblJlY3QpO1xuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCByZWN0Q29ybmVycyA9IGNvcm5lcnNPZlJlY3RhbmdsZShyZWN0KTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IGNvcm5lcnMucmVkdWNlKChhY2N1bXVsYXRvciwgY29ybmVyLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyBkaXN0YW5jZUJldHdlZW4ocmVjdENvcm5lcnNbaW5kZXhdLCBjb3JuZXIpO1xuICAgICAgfSwgMCk7XG4gICAgICBjb25zdCBlZmZlY3RpdmVEaXN0YW5jZSA9IE51bWJlcigoZGlzdGFuY2VzIC8gNCkudG9GaXhlZCg0KSk7XG4gICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICB2YWx1ZTogZWZmZWN0aXZlRGlzdGFuY2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0FzYyk7XG59O1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgaW50ZXJzZWN0aW5nIHJlY3RhbmdsZSBhcmVhIGJldHdlZW4gdHdvIHJlY3RhbmdsZXNcclxuICovXG5cbmZ1bmN0aW9uIGdldEludGVyc2VjdGlvblJhdGlvKGVudHJ5LCB0YXJnZXQpIHtcbiAgY29uc3QgdG9wID0gTWF0aC5tYXgodGFyZ2V0LnRvcCwgZW50cnkudG9wKTtcbiAgY29uc3QgbGVmdCA9IE1hdGgubWF4KHRhcmdldC5sZWZ0LCBlbnRyeS5sZWZ0KTtcbiAgY29uc3QgcmlnaHQgPSBNYXRoLm1pbih0YXJnZXQubGVmdCArIHRhcmdldC53aWR0aCwgZW50cnkubGVmdCArIGVudHJ5LndpZHRoKTtcbiAgY29uc3QgYm90dG9tID0gTWF0aC5taW4odGFyZ2V0LnRvcCArIHRhcmdldC5oZWlnaHQsIGVudHJ5LnRvcCArIGVudHJ5LmhlaWdodCk7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcbiAgICBjb25zdCB0YXJnZXRBcmVhID0gdGFyZ2V0LndpZHRoICogdGFyZ2V0LmhlaWdodDtcbiAgICBjb25zdCBlbnRyeUFyZWEgPSBlbnRyeS53aWR0aCAqIGVudHJ5LmhlaWdodDtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25BcmVhID0gd2lkdGggKiBoZWlnaHQ7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uUmF0aW8gPSBpbnRlcnNlY3Rpb25BcmVhIC8gKHRhcmdldEFyZWEgKyBlbnRyeUFyZWEgLSBpbnRlcnNlY3Rpb25BcmVhKTtcbiAgICByZXR1cm4gTnVtYmVyKGludGVyc2VjdGlvblJhdGlvLnRvRml4ZWQoNCkpO1xuICB9IC8vIFJlY3RhbmdsZXMgZG8gbm90IG92ZXJsYXAsIG9yIG92ZXJsYXAgaGFzIGFuIGFyZWEgb2YgemVybyAoZWRnZS9jb3JuZXIgb3ZlcmxhcClcblxuXG4gIHJldHVybiAwO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJlY3RhbmdsZXMgdGhhdCBoYXMgdGhlIGdyZWF0ZXN0IGludGVyc2VjdGlvbiBhcmVhIHdpdGggYSBnaXZlblxyXG4gKiByZWN0YW5nbGUgaW4gYW4gYXJyYXkgb2YgcmVjdGFuZ2xlcy5cclxuICovXG5cbmNvbnN0IHJlY3RJbnRlcnNlY3Rpb24gPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBjb2xsaXNpb25SZWN0LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRyb3BwYWJsZUNvbnRhaW5lciBvZiBkcm9wcGFibGVDb250YWluZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gZHJvcHBhYmxlQ29udGFpbmVyO1xuICAgIGNvbnN0IHJlY3QgPSBkcm9wcGFibGVSZWN0cy5nZXQoaWQpO1xuXG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvID0gZ2V0SW50ZXJzZWN0aW9uUmF0aW8ocmVjdCwgY29sbGlzaW9uUmVjdCk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgICB2YWx1ZTogaW50ZXJzZWN0aW9uUmF0aW9cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNEZXNjKTtcbn07XG5cbi8qKlxyXG4gKiBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBib3VuZGluZyByZWN0YW5nbGVcclxuICovXG5cbmZ1bmN0aW9uIGlzUG9pbnRXaXRoaW5SZWN0KHBvaW50LCByZWN0KSB7XG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB0b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJvdHRvbSAmJiBsZWZ0IDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSByaWdodDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSByZWN0YW5nbGVzIHRoYXQgdGhlIHBvaW50ZXIgaXMgaG92ZXJpbmcgb3ZlclxyXG4gKi9cblxuXG5jb25zdCBwb2ludGVyV2l0aGluID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBwb2ludGVyQ29vcmRpbmF0ZXNcbiAgfSA9IF9yZWY7XG5cbiAgaWYgKCFwb2ludGVyQ29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjb2xsaXNpb25zID0gW107XG5cbiAgZm9yIChjb25zdCBkcm9wcGFibGVDb250YWluZXIgb2YgZHJvcHBhYmxlQ29udGFpbmVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkXG4gICAgfSA9IGRyb3BwYWJsZUNvbnRhaW5lcjtcbiAgICBjb25zdCByZWN0ID0gZHJvcHBhYmxlUmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0ICYmIGlzUG9pbnRXaXRoaW5SZWN0KHBvaW50ZXJDb29yZGluYXRlcywgcmVjdCkpIHtcbiAgICAgIC8qIFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gYSBzaW5nbGUgcmVjdGFuZ2xlIGludGVyc2VjdGluZ1xyXG4gICAgICAgKiB3aXRoIHRoZSBwb2ludGVyIGNvb3JkaW5hdGVzLiBJbiBvcmRlciB0byBzb3J0IHRoZVxyXG4gICAgICAgKiBjb2xsaWRpbmcgcmVjdGFuZ2xlcywgd2UgbWVhc3VyZSB0aGUgZGlzdGFuY2UgYmV0d2VlblxyXG4gICAgICAgKiB0aGUgcG9pbnRlciBhbmQgdGhlIGNvcm5lcnMgb2YgdGhlIGludGVyc2VjdGluZyByZWN0YW5nbGVcclxuICAgICAgICovXG4gICAgICBjb25zdCBjb3JuZXJzID0gY29ybmVyc09mUmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgY29uc3QgZGlzdGFuY2VzID0gY29ybmVycy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjb3JuZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgZGlzdGFuY2VCZXR3ZWVuKHBvaW50ZXJDb29yZGluYXRlcywgY29ybmVyKTtcbiAgICAgIH0sIDApO1xuICAgICAgY29uc3QgZWZmZWN0aXZlRGlzdGFuY2UgPSBOdW1iZXIoKGRpc3RhbmNlcyAvIDQpLnRvRml4ZWQoNCkpO1xuICAgICAgY29sbGlzaW9ucy5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBkcm9wcGFibGVDb250YWluZXIsXG4gICAgICAgICAgdmFsdWU6IGVmZmVjdGl2ZURpc3RhbmNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb2xsaXNpb25zLnNvcnQoc29ydENvbGxpc2lvbnNBc2MpO1xufTtcblxuZnVuY3Rpb24gYWRqdXN0U2NhbGUodHJhbnNmb3JtLCByZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIHsgLi4udHJhbnNmb3JtLFxuICAgIHNjYWxlWDogcmVjdDEgJiYgcmVjdDIgPyByZWN0MS53aWR0aCAvIHJlY3QyLndpZHRoIDogMSxcbiAgICBzY2FsZVk6IHJlY3QxICYmIHJlY3QyID8gcmVjdDEuaGVpZ2h0IC8gcmVjdDIuaGVpZ2h0IDogMVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0RGVsdGEocmVjdDEsIHJlY3QyKSB7XG4gIHJldHVybiByZWN0MSAmJiByZWN0MiA/IHtcbiAgICB4OiByZWN0MS5sZWZ0IC0gcmVjdDIubGVmdCxcbiAgICB5OiByZWN0MS50b3AgLSByZWN0Mi50b3BcbiAgfSA6IGRlZmF1bHRDb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVjdEFkanVzdG1lbnRGbihtb2RpZmllcikge1xuICByZXR1cm4gZnVuY3Rpb24gYWRqdXN0Q2xpZW50UmVjdChyZWN0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFkanVzdG1lbnRzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFkanVzdG1lbnRzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRqdXN0bWVudHMucmVkdWNlKChhY2MsIGFkanVzdG1lbnQpID0+ICh7IC4uLmFjYyxcbiAgICAgIHRvcDogYWNjLnRvcCArIG1vZGlmaWVyICogYWRqdXN0bWVudC55LFxuICAgICAgYm90dG9tOiBhY2MuYm90dG9tICsgbW9kaWZpZXIgKiBhZGp1c3RtZW50LnksXG4gICAgICBsZWZ0OiBhY2MubGVmdCArIG1vZGlmaWVyICogYWRqdXN0bWVudC54LFxuICAgICAgcmlnaHQ6IGFjYy5yaWdodCArIG1vZGlmaWVyICogYWRqdXN0bWVudC54XG4gICAgfSksIHsgLi4ucmVjdFxuICAgIH0pO1xuICB9O1xufVxuY29uc3QgZ2V0QWRqdXN0ZWRSZWN0ID0gLyojX19QVVJFX18qL2NyZWF0ZVJlY3RBZGp1c3RtZW50Rm4oMSk7XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBpZiAodHJhbnNmb3JtLnN0YXJ0c1dpdGgoJ21hdHJpeDNkKCcpKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtQXJyYXkgPSB0cmFuc2Zvcm0uc2xpY2UoOSwgLTEpLnNwbGl0KC8sIC8pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiArdHJhbnNmb3JtQXJyYXlbMTJdLFxuICAgICAgeTogK3RyYW5zZm9ybUFycmF5WzEzXSxcbiAgICAgIHNjYWxlWDogK3RyYW5zZm9ybUFycmF5WzBdLFxuICAgICAgc2NhbGVZOiArdHJhbnNmb3JtQXJyYXlbNV1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHRyYW5zZm9ybS5zdGFydHNXaXRoKCdtYXRyaXgoJykpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1BcnJheSA9IHRyYW5zZm9ybS5zbGljZSg3LCAtMSkuc3BsaXQoLywgLyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICt0cmFuc2Zvcm1BcnJheVs0XSxcbiAgICAgIHk6ICt0cmFuc2Zvcm1BcnJheVs1XSxcbiAgICAgIHNjYWxlWDogK3RyYW5zZm9ybUFycmF5WzBdLFxuICAgICAgc2NhbGVZOiArdHJhbnNmb3JtQXJyYXlbM11cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0ocmVjdCwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgY29uc3QgcGFyc2VkVHJhbnNmb3JtID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcblxuICBpZiAoIXBhcnNlZFRyYW5zZm9ybSkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHNjYWxlWCxcbiAgICBzY2FsZVksXG4gICAgeDogdHJhbnNsYXRlWCxcbiAgICB5OiB0cmFuc2xhdGVZXG4gIH0gPSBwYXJzZWRUcmFuc2Zvcm07XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgLSB0cmFuc2xhdGVYIC0gKDEgLSBzY2FsZVgpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4pO1xuICBjb25zdCB5ID0gcmVjdC50b3AgLSB0cmFuc2xhdGVZIC0gKDEgLSBzY2FsZVkpICogcGFyc2VGbG9hdCh0cmFuc2Zvcm1PcmlnaW4uc2xpY2UodHJhbnNmb3JtT3JpZ2luLmluZGV4T2YoJyAnKSArIDEpKTtcbiAgY29uc3QgdyA9IHNjYWxlWCA/IHJlY3Qud2lkdGggLyBzY2FsZVggOiByZWN0LndpZHRoO1xuICBjb25zdCBoID0gc2NhbGVZID8gcmVjdC5oZWlnaHQgLyBzY2FsZVkgOiByZWN0LmhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGgsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgdyxcbiAgICBib3R0b206IHkgKyBoLFxuICAgIGxlZnQ6IHhcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGlnbm9yZVRyYW5zZm9ybTogZmFsc2Vcbn07XG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgfVxuXG4gIGxldCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBpZiAob3B0aW9ucy5pZ25vcmVUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgICB9ID0gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICByZWN0ID0gaW52ZXJzZVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBUaGUgQ2xpZW50UmVjdCByZXR1cm5lZCBieSB0aGlzIG1ldGhvZCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgaXQgbWVhc3VyZXMuXHJcbiAqXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChlbGVtZW50LCB7XG4gICAgaWdub3JlVHJhbnNmb3JtOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3Qgd2lkdGggPSBlbGVtZW50LmlubmVyV2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuaW5uZXJIZWlnaHQ7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IHdpZHRoLFxuICAgIGJvdHRvbTogaGVpZ2h0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0ZpeGVkKG5vZGUsIGNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKGNvbXB1dGVkU3R5bGUgPT09IHZvaWQgMCkge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRXaW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgfVxuXG4gIHJldHVybiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnO1xufVxuXG5mdW5jdGlvbiBpc1Njcm9sbGFibGUoZWxlbWVudCwgY29tcHV0ZWRTdHlsZSkge1xuICBpZiAoY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgY29tcHV0ZWRTdHlsZSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB9XG5cbiAgY29uc3Qgb3ZlcmZsb3dSZWdleCA9IC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvO1xuICBjb25zdCBwcm9wZXJ0aWVzID0gWydvdmVyZmxvdycsICdvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ107XG4gIHJldHVybiBwcm9wZXJ0aWVzLnNvbWUocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBvdmVyZmxvd1JlZ2V4LnRlc3QodmFsdWUpIDogZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQsIGxpbWl0KSB7XG4gIGNvbnN0IHNjcm9sbFBhcmVudHMgPSBbXTtcblxuICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlKSB7XG4gICAgaWYgKGxpbWl0ICE9IG51bGwgJiYgc2Nyb2xsUGFyZW50cy5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5zY3JvbGxpbmdFbGVtZW50ICE9IG51bGwgJiYgIXNjcm9sbFBhcmVudHMuaW5jbHVkZXMobm9kZS5zY3JvbGxpbmdFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5wdXNoKG5vZGUuc2Nyb2xsaW5nRWxlbWVudCk7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQobm9kZSkgfHwgaXNTVkdFbGVtZW50KG5vZGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsUGFyZW50cy5pbmNsdWRlcyhub2RlKSkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKG5vZGUgIT09IGVsZW1lbnQpIHtcbiAgICAgIGlmIChpc1Njcm9sbGFibGUobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0ZpeGVkKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBbZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3JdID0gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlLCAxKTtcbiAgcmV0dXJuIGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yICE9IG51bGwgPyBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFjYW5Vc2VET00gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0RvY3VtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQgPT09IGdldE93bmVyRG9jdW1lbnQoZWxlbWVudCkuc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFhDb29yZGluYXRlKGVsZW1lbnQpIHtcbiAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsWDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxZQ29vcmRpbmF0ZShlbGVtZW50KSB7XG4gIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5zY3JvbGxUb3A7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxDb29yZGluYXRlcyhlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZ2V0U2Nyb2xsWENvb3JkaW5hdGUoZWxlbWVudCksXG4gICAgeTogZ2V0U2Nyb2xsWUNvb3JkaW5hdGUoZWxlbWVudClcbiAgfTtcbn1cblxudmFyIERpcmVjdGlvbjtcblxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcbiAgRGlyZWN0aW9uW0RpcmVjdGlvbltcIkZvcndhcmRcIl0gPSAxXSA9IFwiRm9yd2FyZFwiO1xuICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSAtMV0gPSBcIkJhY2t3YXJkXCI7XG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFjYW5Vc2VET00gfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudCA9PT0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsaW5nQ29udGFpbmVyKSB7XG4gIGNvbnN0IG1pblNjcm9sbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KHNjcm9sbGluZ0NvbnRhaW5lcikgPyB7XG4gICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoXG4gIH0gOiB7XG4gICAgaGVpZ2h0OiBzY3JvbGxpbmdDb250YWluZXIuY2xpZW50SGVpZ2h0LFxuICAgIHdpZHRoOiBzY3JvbGxpbmdDb250YWluZXIuY2xpZW50V2lkdGhcbiAgfTtcbiAgY29uc3QgbWF4U2Nyb2xsID0ge1xuICAgIHg6IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxXaWR0aCAtIGRpbWVuc2lvbnMud2lkdGgsXG4gICAgeTogc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbEhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0XG4gIH07XG4gIGNvbnN0IGlzVG9wID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA8PSBtaW5TY3JvbGwueTtcbiAgY29uc3QgaXNMZWZ0ID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbExlZnQgPD0gbWluU2Nyb2xsLng7XG4gIGNvbnN0IGlzQm90dG9tID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcCA+PSBtYXhTY3JvbGwueTtcbiAgY29uc3QgaXNSaWdodCA9IHNjcm9sbGluZ0NvbnRhaW5lci5zY3JvbGxMZWZ0ID49IG1heFNjcm9sbC54O1xuICByZXR1cm4ge1xuICAgIGlzVG9wLFxuICAgIGlzTGVmdCxcbiAgICBpc0JvdHRvbSxcbiAgICBpc1JpZ2h0LFxuICAgIG1heFNjcm9sbCxcbiAgICBtaW5TY3JvbGxcbiAgfTtcbn1cblxuY29uc3QgZGVmYXVsdFRocmVzaG9sZCA9IHtcbiAgeDogMC4yLFxuICB5OiAwLjJcbn07XG5mdW5jdGlvbiBnZXRTY3JvbGxEaXJlY3Rpb25BbmRTcGVlZChzY3JvbGxDb250YWluZXIsIHNjcm9sbENvbnRhaW5lclJlY3QsIF9yZWYsIGFjY2VsZXJhdGlvbiwgdGhyZXNob2xkUGVyY2VudGFnZSkge1xuICBsZXQge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9ID0gX3JlZjtcblxuICBpZiAoYWNjZWxlcmF0aW9uID09PSB2b2lkIDApIHtcbiAgICBhY2NlbGVyYXRpb24gPSAxMDtcbiAgfVxuXG4gIGlmICh0aHJlc2hvbGRQZXJjZW50YWdlID09PSB2b2lkIDApIHtcbiAgICB0aHJlc2hvbGRQZXJjZW50YWdlID0gZGVmYXVsdFRocmVzaG9sZDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBpc1RvcCxcbiAgICBpc0JvdHRvbSxcbiAgICBpc0xlZnQsXG4gICAgaXNSaWdodFxuICB9ID0gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsQ29udGFpbmVyKTtcbiAgY29uc3QgZGlyZWN0aW9uID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBjb25zdCBzcGVlZCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgY29uc3QgdGhyZXNob2xkID0ge1xuICAgIGhlaWdodDogc2Nyb2xsQ29udGFpbmVyUmVjdC5oZWlnaHQgKiB0aHJlc2hvbGRQZXJjZW50YWdlLnksXG4gICAgd2lkdGg6IHNjcm9sbENvbnRhaW5lclJlY3Qud2lkdGggKiB0aHJlc2hvbGRQZXJjZW50YWdlLnhcbiAgfTtcblxuICBpZiAoIWlzVG9wICYmIHRvcCA8PSBzY3JvbGxDb250YWluZXJSZWN0LnRvcCArIHRocmVzaG9sZC5oZWlnaHQpIHtcbiAgICAvLyBTY3JvbGwgVXBcbiAgICBkaXJlY3Rpb24ueSA9IERpcmVjdGlvbi5CYWNrd2FyZDtcbiAgICBzcGVlZC55ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QudG9wICsgdGhyZXNob2xkLmhlaWdodCAtIHRvcCkgLyB0aHJlc2hvbGQuaGVpZ2h0KTtcbiAgfSBlbHNlIGlmICghaXNCb3R0b20gJiYgYm90dG9tID49IHNjcm9sbENvbnRhaW5lclJlY3QuYm90dG9tIC0gdGhyZXNob2xkLmhlaWdodCkge1xuICAgIC8vIFNjcm9sbCBEb3duXG4gICAgZGlyZWN0aW9uLnkgPSBEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICBzcGVlZC55ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QuYm90dG9tIC0gdGhyZXNob2xkLmhlaWdodCAtIGJvdHRvbSkgLyB0aHJlc2hvbGQuaGVpZ2h0KTtcbiAgfVxuXG4gIGlmICghaXNSaWdodCAmJiByaWdodCA+PSBzY3JvbGxDb250YWluZXJSZWN0LnJpZ2h0IC0gdGhyZXNob2xkLndpZHRoKSB7XG4gICAgLy8gU2Nyb2xsIFJpZ2h0XG4gICAgZGlyZWN0aW9uLnggPSBEaXJlY3Rpb24uRm9yd2FyZDtcbiAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uICogTWF0aC5hYnMoKHNjcm9sbENvbnRhaW5lclJlY3QucmlnaHQgLSB0aHJlc2hvbGQud2lkdGggLSByaWdodCkgLyB0aHJlc2hvbGQud2lkdGgpO1xuICB9IGVsc2UgaWYgKCFpc0xlZnQgJiYgbGVmdCA8PSBzY3JvbGxDb250YWluZXJSZWN0LmxlZnQgKyB0aHJlc2hvbGQud2lkdGgpIHtcbiAgICAvLyBTY3JvbGwgTGVmdFxuICAgIGRpcmVjdGlvbi54ID0gRGlyZWN0aW9uLkJhY2t3YXJkO1xuICAgIHNwZWVkLnggPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicygoc2Nyb2xsQ29udGFpbmVyUmVjdC5sZWZ0ICsgdGhyZXNob2xkLndpZHRoIC0gbGVmdCkgLyB0aHJlc2hvbGQud2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaXJlY3Rpb24sXG4gICAgc3BlZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsRWxlbWVudFJlY3QoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlubmVyV2lkdGgsXG4gICAgICBpbm5lckhlaWdodFxuICAgIH0gPSB3aW5kb3c7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogaW5uZXJXaWR0aCxcbiAgICAgIGJvdHRvbTogaW5uZXJIZWlnaHQsXG4gICAgICB3aWR0aDogaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbVxuICB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib3R0b20sXG4gICAgd2lkdGg6IGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgaGVpZ2h0OiBlbGVtZW50LmNsaWVudEhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxPZmZzZXRzKHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVBbmNlc3RvcnMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICByZXR1cm4gYWRkKGFjYywgZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMobm9kZSkpO1xuICB9LCBkZWZhdWx0Q29vcmRpbmF0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWE9mZnNldChzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlQW5jZXN0b3JzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgcmV0dXJuIGFjYyArIGdldFNjcm9sbFhDb29yZGluYXRlKG5vZGUpO1xuICB9LCAwKTtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFlPZmZzZXQoc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICByZXR1cm4gc2Nyb2xsYWJsZUFuY2VzdG9ycy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIHJldHVybiBhY2MgKyBnZXRTY3JvbGxZQ29vcmRpbmF0ZShub2RlKTtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3SWZOZWVkZWQoZWxlbWVudCwgbWVhc3VyZSkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGdldENsaWVudFJlY3Q7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH0gPSBtZWFzdXJlKGVsZW1lbnQpO1xuICBjb25zdCBmaXJzdFNjcm9sbGFibGVBbmNlc3RvciA9IGdldEZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKGVsZW1lbnQpO1xuXG4gIGlmICghZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoYm90dG9tIDw9IDAgfHwgcmlnaHQgPD0gMCB8fCB0b3AgPj0gd2luZG93LmlubmVySGVpZ2h0IHx8IGxlZnQgPj0gd2luZG93LmlubmVyV2lkdGgpIHtcbiAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiAnY2VudGVyJyxcbiAgICAgIGlubGluZTogJ2NlbnRlcidcbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBwcm9wZXJ0aWVzID0gW1sneCcsIFsnbGVmdCcsICdyaWdodCddLCBnZXRTY3JvbGxYT2Zmc2V0XSwgWyd5JywgWyd0b3AnLCAnYm90dG9tJ10sIGdldFNjcm9sbFlPZmZzZXRdXTtcbmNsYXNzIFJlY3Qge1xuICBjb25zdHJ1Y3RvcihyZWN0LCBlbGVtZW50KSB7XG4gICAgdGhpcy5yZWN0ID0gdm9pZCAwO1xuICAgIHRoaXMud2lkdGggPSB2b2lkIDA7XG4gICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7XG4gICAgdGhpcy50b3AgPSB2b2lkIDA7XG4gICAgdGhpcy5ib3R0b20gPSB2b2lkIDA7XG4gICAgdGhpcy5yaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmxlZnQgPSB2b2lkIDA7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9ycyA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnMoZWxlbWVudCk7XG4gICAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IGdldFNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7XG4gICAgdGhpcy5yZWN0ID0geyAuLi5yZWN0XG4gICAgfTtcbiAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yIChjb25zdCBbYXhpcywga2V5cywgZ2V0U2Nyb2xsT2Zmc2V0XSBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXRzID0gZ2V0U2Nyb2xsT2Zmc2V0KHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0c0RlbHRsYSA9IHNjcm9sbE9mZnNldHNbYXhpc10gLSBjdXJyZW50T2Zmc2V0cztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3Rba2V5XSArIHNjcm9sbE9mZnNldHNEZWx0bGE7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVjdCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxufVxuXG5jbGFzcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuXG4gICAgdGhpcy5yZW1vdmVBbGwgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgICAgdmFyIF90aGlzJHRhcmdldDtcblxuICAgICAgICByZXR1cm4gKF90aGlzJHRhcmdldCA9IHRoaXMudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoLi4ubGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgYWRkKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyR0YXJnZXQyO1xuXG4gICAgKF90aGlzJHRhcmdldDIgPSB0aGlzLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goW2V2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclRhcmdldCh0YXJnZXQpIHtcbiAgLy8gSWYgdGhlIGBldmVudC50YXJnZXRgIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudCBldmVudHMgd2lsbCBzdGlsbCBiZSB0YXJnZXRlZFxuICAvLyBhdCBpdCwgYW5kIGhlbmNlIHdvbid0IGFsd2F5cyBidWJibGUgdXAgdG8gdGhlIHdpbmRvdyBvciBkb2N1bWVudCBhbnltb3JlLlxuICAvLyBJZiB0aGVyZSBpcyBhbnkgcmlzayBvZiBhbiBlbGVtZW50IGJlaW5nIHJlbW92ZWQgd2hpbGUgaXQgaXMgYmVpbmcgZHJhZ2dlZCxcbiAgLy8gdGhlIGJlc3QgcHJhY3RpY2UgaXMgdG8gYXR0YWNoIHRoZSBldmVudCBsaXN0ZW5lcnMgZGlyZWN0bHkgdG8gdGhlIHRhcmdldC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0XG4gIGNvbnN0IHtcbiAgICBFdmVudFRhcmdldFxuICB9ID0gZ2V0V2luZG93KHRhcmdldCk7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBFdmVudFRhcmdldCA/IHRhcmdldCA6IGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gaGFzRXhjZWVkZWREaXN0YW5jZShkZWx0YSwgbWVhc3VyZW1lbnQpIHtcbiAgY29uc3QgZHggPSBNYXRoLmFicyhkZWx0YS54KTtcbiAgY29uc3QgZHkgPSBNYXRoLmFicyhkZWx0YS55KTtcblxuICBpZiAodHlwZW9mIG1lYXN1cmVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiogMiArIGR5ICoqIDIpID4gbWVhc3VyZW1lbnQ7XG4gIH1cblxuICBpZiAoJ3gnIGluIG1lYXN1cmVtZW50ICYmICd5JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeCA+IG1lYXN1cmVtZW50LnggJiYgZHkgPiBtZWFzdXJlbWVudC55O1xuICB9XG5cbiAgaWYgKCd4JyBpbiBtZWFzdXJlbWVudCkge1xuICAgIHJldHVybiBkeCA+IG1lYXN1cmVtZW50Lng7XG4gIH1cblxuICBpZiAoJ3knIGluIG1lYXN1cmVtZW50KSB7XG4gICAgcmV0dXJuIGR5ID4gbWVhc3VyZW1lbnQueTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEV2ZW50TmFtZTtcblxuKGZ1bmN0aW9uIChFdmVudE5hbWUpIHtcbiAgRXZlbnROYW1lW1wiQ2xpY2tcIl0gPSBcImNsaWNrXCI7XG4gIEV2ZW50TmFtZVtcIkRyYWdTdGFydFwiXSA9IFwiZHJhZ3N0YXJ0XCI7XG4gIEV2ZW50TmFtZVtcIktleWRvd25cIl0gPSBcImtleWRvd25cIjtcbiAgRXZlbnROYW1lW1wiQ29udGV4dE1lbnVcIl0gPSBcImNvbnRleHRtZW51XCI7XG4gIEV2ZW50TmFtZVtcIlJlc2l6ZVwiXSA9IFwicmVzaXplXCI7XG4gIEV2ZW50TmFtZVtcIlNlbGVjdGlvbkNoYW5nZVwiXSA9IFwic2VsZWN0aW9uY2hhbmdlXCI7XG4gIEV2ZW50TmFtZVtcIlZpc2liaWxpdHlDaGFuZ2VcIl0gPSBcInZpc2liaWxpdHljaGFuZ2VcIjtcbn0pKEV2ZW50TmFtZSB8fCAoRXZlbnROYW1lID0ge30pKTtcblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIEtleWJvYXJkQ29kZTtcblxuKGZ1bmN0aW9uIChLZXlib2FyZENvZGUpIHtcbiAgS2V5Ym9hcmRDb2RlW1wiU3BhY2VcIl0gPSBcIlNwYWNlXCI7XG4gIEtleWJvYXJkQ29kZVtcIkRvd25cIl0gPSBcIkFycm93RG93blwiO1xuICBLZXlib2FyZENvZGVbXCJSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xuICBLZXlib2FyZENvZGVbXCJMZWZ0XCJdID0gXCJBcnJvd0xlZnRcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiVXBcIl0gPSBcIkFycm93VXBcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiRXNjXCJdID0gXCJFc2NhcGVcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiRW50ZXJcIl0gPSBcIkVudGVyXCI7XG59KShLZXlib2FyZENvZGUgfHwgKEtleWJvYXJkQ29kZSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRLZXlib2FyZENvZGVzID0ge1xuICBzdGFydDogW0tleWJvYXJkQ29kZS5TcGFjZSwgS2V5Ym9hcmRDb2RlLkVudGVyXSxcbiAgY2FuY2VsOiBbS2V5Ym9hcmRDb2RlLkVzY10sXG4gIGVuZDogW0tleWJvYXJkQ29kZS5TcGFjZSwgS2V5Ym9hcmRDb2RlLkVudGVyXVxufTtcbmNvbnN0IGRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIgPSAoZXZlbnQsIF9yZWYpID0+IHtcbiAgbGV0IHtcbiAgICBjdXJyZW50Q29vcmRpbmF0ZXNcbiAgfSA9IF9yZWY7XG5cbiAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgY2FzZSBLZXlib2FyZENvZGUuUmlnaHQ6XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHg6IGN1cnJlbnRDb29yZGluYXRlcy54ICsgMjVcbiAgICAgIH07XG5cbiAgICBjYXNlIEtleWJvYXJkQ29kZS5MZWZ0OlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB4OiBjdXJyZW50Q29vcmRpbmF0ZXMueCAtIDI1XG4gICAgICB9O1xuXG4gICAgY2FzZSBLZXlib2FyZENvZGUuRG93bjpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeTogY3VycmVudENvb3JkaW5hdGVzLnkgKyAyNVxuICAgICAgfTtcblxuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlVwOlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB5OiBjdXJyZW50Q29vcmRpbmF0ZXMueSAtIDI1XG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmNsYXNzIEtleWJvYXJkU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b1Njcm9sbEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzID0gdm9pZCAwO1xuICAgIHRoaXMubGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBldmVudDoge1xuICAgICAgICB0YXJnZXRcbiAgICAgIH1cbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRPd25lckRvY3VtZW50KHRhcmdldCkpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRXaW5kb3codGFyZ2V0KSk7XG4gICAgdGhpcy5oYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDYW5jZWwgPSB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXR0YWNoKCk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuUmVzaXplLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5WaXNpYmlsaXR5Q2hhbmdlLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmxpc3RlbmVycy5hZGQoRXZlbnROYW1lLktleWRvd24sIHRoaXMuaGFuZGxlS2V5RG93bikpO1xuICB9XG5cbiAgaGFuZGxlU3RhcnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIG9uU3RhcnRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBjb25zdCBub2RlID0gYWN0aXZlTm9kZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAobm9kZSkge1xuICAgICAgc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChub2RlKTtcbiAgICB9XG5cbiAgICBvblN0YXJ0KGRlZmF1bHRDb29yZGluYXRlcyk7XG4gIH1cblxuICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGlzS2V5Ym9hcmRFdmVudChldmVudCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBvcHRpb25zXG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5Ym9hcmRDb2RlcyA9IGRlZmF1bHRLZXlib2FyZENvZGVzLFxuICAgICAgICBjb29yZGluYXRlR2V0dGVyID0gZGVmYXVsdEtleWJvYXJkQ29vcmRpbmF0ZUdldHRlcixcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3IgPSAnc21vb3RoJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvZGVcbiAgICAgIH0gPSBldmVudDtcblxuICAgICAgaWYgKGtleWJvYXJkQ29kZXMuZW5kLmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRW5kKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5Ym9hcmRDb2Rlcy5jYW5jZWwuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVDYW5jZWwoZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGlzaW9uUmVjdFxuICAgICAgfSA9IGNvbnRleHQuY3VycmVudDtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb29yZGluYXRlcyA9IGNvbGxpc2lvblJlY3QgPyB7XG4gICAgICAgIHg6IGNvbGxpc2lvblJlY3QubGVmdCxcbiAgICAgICAgeTogY29sbGlzaW9uUmVjdC50b3BcbiAgICAgIH0gOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG5cbiAgICAgIGlmICghdGhpcy5yZWZlcmVuY2VDb29yZGluYXRlcykge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzID0gY3VycmVudENvb3JkaW5hdGVzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdDb29yZGluYXRlcyA9IGNvb3JkaW5hdGVHZXR0ZXIoZXZlbnQsIHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LmN1cnJlbnQsXG4gICAgICAgIGN1cnJlbnRDb29yZGluYXRlc1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChuZXdDb29yZGluYXRlcykge1xuICAgICAgICBjb25zdCBjb29yZGluYXRlc0RlbHRhID0gc3VidHJhY3QobmV3Q29vcmRpbmF0ZXMsIGN1cnJlbnRDb29yZGluYXRlcyk7XG4gICAgICAgIGNvbnN0IHNjcm9sbERlbHRhID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9yc1xuICAgICAgICB9ID0gY29udGV4dC5jdXJyZW50O1xuXG4gICAgICAgIGZvciAoY29uc3Qgc2Nyb2xsQ29udGFpbmVyIG9mIHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5jb2RlO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlzVG9wLFxuICAgICAgICAgICAgaXNSaWdodCxcbiAgICAgICAgICAgIGlzTGVmdCxcbiAgICAgICAgICAgIGlzQm90dG9tLFxuICAgICAgICAgICAgbWF4U2Nyb2xsLFxuICAgICAgICAgICAgbWluU2Nyb2xsXG4gICAgICAgICAgfSA9IGdldFNjcm9sbFBvc2l0aW9uKHNjcm9sbENvbnRhaW5lcik7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudFJlY3QgPSBnZXRTY3JvbGxFbGVtZW50UmVjdChzY3JvbGxDb250YWluZXIpO1xuICAgICAgICAgIGNvbnN0IGNsYW1wZWRDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICAgIHg6IE1hdGgubWluKGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ID8gc2Nyb2xsRWxlbWVudFJlY3QucmlnaHQgLSBzY3JvbGxFbGVtZW50UmVjdC53aWR0aCAvIDIgOiBzY3JvbGxFbGVtZW50UmVjdC5yaWdodCwgTWF0aC5tYXgoZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgPyBzY3JvbGxFbGVtZW50UmVjdC5sZWZ0IDogc2Nyb2xsRWxlbWVudFJlY3QubGVmdCArIHNjcm9sbEVsZW1lbnRSZWN0LndpZHRoIC8gMiwgbmV3Q29vcmRpbmF0ZXMueCkpLFxuICAgICAgICAgICAgeTogTWF0aC5taW4oZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biA/IHNjcm9sbEVsZW1lbnRSZWN0LmJvdHRvbSAtIHNjcm9sbEVsZW1lbnRSZWN0LmhlaWdodCAvIDIgOiBzY3JvbGxFbGVtZW50UmVjdC5ib3R0b20sIE1hdGgubWF4KGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxFbGVtZW50UmVjdC50b3AgOiBzY3JvbGxFbGVtZW50UmVjdC50b3AgKyBzY3JvbGxFbGVtZW50UmVjdC5oZWlnaHQgLyAyLCBuZXdDb29yZGluYXRlcy55KSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IGNhblNjcm9sbFggPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCAmJiAhaXNSaWdodCB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5MZWZ0ICYmICFpc0xlZnQ7XG4gICAgICAgICAgY29uc3QgY2FuU2Nyb2xsWSA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gJiYgIWlzQm90dG9tIHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlVwICYmICFpc1RvcDtcblxuICAgICAgICAgIGlmIChjYW5TY3JvbGxYICYmIGNsYW1wZWRDb29yZGluYXRlcy54ICE9PSBuZXdDb29yZGluYXRlcy54KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxDb29yZGluYXRlcyA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICsgY29vcmRpbmF0ZXNEZWx0YS54O1xuICAgICAgICAgICAgY29uc3QgY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ICYmIG5ld1Njcm9sbENvb3JkaW5hdGVzIDw9IG1heFNjcm9sbC54IHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkxlZnQgJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPj0gbWluU2Nyb2xsLng7XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzICYmICFjb29yZGluYXRlc0RlbHRhLnkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgY29vcmRpbmF0ZXMsIHRoZSBzY3JvbGwgYWRqdXN0bWVudCBhbG9uZSB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgLy8gbG9naWMgdG8gYXV0by1kZXRlY3QgdGhlIG5ldyBjb250YWluZXIgd2UgYXJlIG92ZXJcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBuZXdTY3JvbGxDb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC0gbmV3U2Nyb2xsQ29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS54ID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgPyBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIG1heFNjcm9sbC54IDogc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSBtaW5TY3JvbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjcm9sbERlbHRhLngpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAtc2Nyb2xsRGVsdGEueCxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2FuU2Nyb2xsWSAmJiBjbGFtcGVkQ29vcmRpbmF0ZXMueSAhPT0gbmV3Q29vcmRpbmF0ZXMueSkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wICsgY29vcmRpbmF0ZXNEZWx0YS55O1xuICAgICAgICAgICAgY29uc3QgY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcyA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPD0gbWF4U2Nyb2xsLnkgfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuVXAgJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPj0gbWluU2Nyb2xsLnk7XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzICYmICFjb29yZGluYXRlc0RlbHRhLngpIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgY29vcmRpbmF0ZXMsIHRoZSBzY3JvbGwgYWRqdXN0bWVudCBhbG9uZSB3aWxsIHRyaWdnZXJcbiAgICAgICAgICAgICAgLy8gbG9naWMgdG8gYXV0by1kZXRlY3QgdGhlIG5ldyBjb250YWluZXIgd2UgYXJlIG92ZXJcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvKHtcbiAgICAgICAgICAgICAgICB0b3A6IG5ld1Njcm9sbENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS55ID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIG5ld1Njcm9sbENvb3JkaW5hdGVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEueSA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkRvd24gPyBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gbWF4U2Nyb2xsLnkgOiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gbWluU2Nyb2xsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JvbGxEZWx0YS55KSB7XG4gICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxCeSh7XG4gICAgICAgICAgICAgICAgdG9wOiAtc2Nyb2xsRGVsdGEueSxcbiAgICAgICAgICAgICAgICBiZWhhdmlvcjogc2Nyb2xsQmVoYXZpb3JcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZShldmVudCwgYWRkKHN1YnRyYWN0KG5ld0Nvb3JkaW5hdGVzLCB0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzKSwgc2Nyb2xsRGVsdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVNb3ZlKGV2ZW50LCBjb29yZGluYXRlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTW92ZVxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgb25Nb3ZlKGNvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUVuZChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRW5kXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIG9uRW5kKCk7XG4gIH1cblxuICBoYW5kbGVDYW5jZWwoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkNhbmNlbCgpO1xuICB9XG5cbiAgZGV0YWNoKCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLnJlbW92ZUFsbCgpO1xuICB9XG5cbn1cbktleWJvYXJkU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvbktleURvd24nLFxuICBoYW5kbGVyOiAoZXZlbnQsIF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGtleWJvYXJkQ29kZXMgPSBkZWZhdWx0S2V5Ym9hcmRDb2RlcyxcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBhY3RpdmVcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3Qge1xuICAgICAgY29kZVxuICAgIH0gPSBldmVudC5uYXRpdmVFdmVudDtcblxuICAgIGlmIChrZXlib2FyZENvZGVzLnN0YXJ0LmluY2x1ZGVzKGNvZGUpKSB7XG4gICAgICBjb25zdCBhY3RpdmF0b3IgPSBhY3RpdmUuYWN0aXZhdG9yTm9kZS5jdXJyZW50O1xuXG4gICAgICBpZiAoYWN0aXZhdG9yICYmIGV2ZW50LnRhcmdldCAhPT0gYWN0aXZhdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9uQWN0aXZhdGlvbiA9PSBudWxsID8gdm9pZCAwIDogb25BY3RpdmF0aW9uKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50Lm5hdGl2ZUV2ZW50XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufV07XG5cbmZ1bmN0aW9uIGlzRGlzdGFuY2VDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY29uc3RyYWludCAmJiAnZGlzdGFuY2UnIGluIGNvbnN0cmFpbnQpO1xufVxuXG5mdW5jdGlvbiBpc0RlbGF5Q29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIHJldHVybiBCb29sZWFuKGNvbnN0cmFpbnQgJiYgJ2RlbGF5JyBpbiBjb25zdHJhaW50KTtcbn1cblxuY2xhc3MgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMsIGV2ZW50cywgbGlzdGVuZXJUYXJnZXQpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXM7XG5cbiAgICBpZiAobGlzdGVuZXJUYXJnZXQgPT09IHZvaWQgMCkge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBnZXRFdmVudExpc3RlbmVyVGFyZ2V0KHByb3BzLmV2ZW50LnRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhpcy5wcm9wcyA9IHZvaWQgMDtcbiAgICB0aGlzLmV2ZW50cyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dG9TY3JvbGxFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmRvY3VtZW50ID0gdm9pZCAwO1xuICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbml0aWFsQ29vcmRpbmF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gdm9pZCAwO1xuICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuZXZlbnRzID0gZXZlbnRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50XG4gICAgfSA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgdGhpcy5kb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KTtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyh0aGlzLmRvY3VtZW50KTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG5ldyBMaXN0ZW5lcnMobGlzdGVuZXJUYXJnZXQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhnZXRXaW5kb3codGFyZ2V0KSk7XG4gICAgdGhpcy5pbml0aWFsQ29vcmRpbmF0ZXMgPSAoX2dldEV2ZW50Q29vcmRpbmF0ZXMgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSkgIT0gbnVsbCA/IF9nZXRFdmVudENvb3JkaW5hdGVzIDogZGVmYXVsdENvb3JkaW5hdGVzO1xuICAgIHRoaXMuaGFuZGxlU3RhcnQgPSB0aGlzLmhhbmRsZVN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVNb3ZlID0gdGhpcy5oYW5kbGVNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVFbmQgPSB0aGlzLmhhbmRsZUVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlQ2FuY2VsID0gdGhpcy5oYW5kbGVDYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUtleWRvd24gPSB0aGlzLmhhbmRsZUtleWRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24gPSB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmF0dGFjaCgpO1xuICB9XG5cbiAgYXR0YWNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50cyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhY3RpdmF0aW9uQ29uc3RyYWludFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGV2ZW50cy5tb3ZlLm5hbWUsIHRoaXMuaGFuZGxlTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoZXZlbnRzLmVuZC5uYW1lLCB0aGlzLmhhbmRsZUVuZCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5SZXNpemUsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLkRyYWdTdGFydCwgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuVmlzaWJpbGl0eUNoYW5nZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuQ29udGV4dE1lbnUsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuS2V5ZG93biwgdGhpcy5oYW5kbGVLZXlkb3duKTtcblxuICAgIGlmIChhY3RpdmF0aW9uQ29uc3RyYWludCkge1xuICAgICAgaWYgKGlzRGlzdGFuY2VDb25zdHJhaW50KGFjdGl2YXRpb25Db25zdHJhaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlbGF5Q29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlU3RhcnQsIGFjdGl2YXRpb25Db25zdHJhaW50LmRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlU3RhcnQoKTtcbiAgfVxuXG4gIGRldGFjaCgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5yZW1vdmVBbGwoKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5yZW1vdmVBbGwoKTsgLy8gV2FpdCB1bnRpbCB0aGUgbmV4dCBldmVudCBsb29wIGJlZm9yZSByZW1vdmluZyBkb2N1bWVudCBsaXN0ZW5lcnNcbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHdlIGxpc3RlbiBmb3IgYGNsaWNrYCBhbmQgYHNlbGVjdGlvbmAgZXZlbnRzIG9uIHRoZSBkb2N1bWVudFxuXG4gICAgc2V0VGltZW91dCh0aGlzLmRvY3VtZW50TGlzdGVuZXJzLnJlbW92ZUFsbCwgNTApO1xuXG4gICAgaWYgKHRoaXMudGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVN0YXJ0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluaXRpYWxDb29yZGluYXRlc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uU3RhcnRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmIChpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGVkID0gdHJ1ZTsgLy8gU3RvcCBwcm9wYWdhdGlvbiBvZiBjbGljayBldmVudHMgb25jZSBhY3RpdmF0aW9uIGNvbnN0cmFpbnRzIGFyZSBtZXRcblxuICAgICAgdGhpcy5kb2N1bWVudExpc3RlbmVycy5hZGQoRXZlbnROYW1lLkNsaWNrLCBzdG9wUHJvcGFnYXRpb24sIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSk7IC8vIFJlbW92ZSBhbnkgdGV4dCBzZWxlY3Rpb24gZnJvbSB0aGUgZG9jdW1lbnRcblxuICAgICAgdGhpcy5yZW1vdmVUZXh0U2VsZWN0aW9uKCk7IC8vIFByZXZlbnQgZnVydGhlciB0ZXh0IHNlbGVjdGlvbiB3aGlsZSBkcmFnZ2luZ1xuXG4gICAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuU2VsZWN0aW9uQ2hhbmdlLCB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24pO1xuICAgICAgb25TdGFydChpbml0aWFsQ29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgX2dldEV2ZW50Q29vcmRpbmF0ZXMyO1xuXG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZhdGVkLFxuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzLFxuICAgICAgcHJvcHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBvbk1vdmUsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFjdGl2YXRpb25Db25zdHJhaW50XG4gICAgICB9XG4gICAgfSA9IHByb3BzO1xuXG4gICAgaWYgKCFpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb29yZGluYXRlcyA9IChfZ2V0RXZlbnRDb29yZGluYXRlczIgPSBnZXRFdmVudENvb3JkaW5hdGVzKGV2ZW50KSkgIT0gbnVsbCA/IF9nZXRFdmVudENvb3JkaW5hdGVzMiA6IGRlZmF1bHRDb29yZGluYXRlcztcbiAgICBjb25zdCBkZWx0YSA9IHN1YnRyYWN0KGluaXRpYWxDb29yZGluYXRlcywgY29vcmRpbmF0ZXMpO1xuXG4gICAgaWYgKCFhY3RpdmF0ZWQgJiYgYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIC8vIENvbnN0cmFpbnQgdmFsaWRhdGlvblxuICAgICAgaWYgKGlzRGVsYXlDb25zdHJhaW50KGFjdGl2YXRpb25Db25zdHJhaW50KSkge1xuICAgICAgICBpZiAoaGFzRXhjZWVkZWREaXN0YW5jZShkZWx0YSwgYWN0aXZhdGlvbkNvbnN0cmFpbnQudG9sZXJhbmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXN0YW5jZUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uQ29uc3RyYWludC50b2xlcmFuY2UgIT0gbnVsbCAmJiBoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC50b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlQ2FuY2VsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRXhjZWVkZWREaXN0YW5jZShkZWx0YSwgYWN0aXZhdGlvbkNvbnN0cmFpbnQuZGlzdGFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU3RhcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBvbk1vdmUoY29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaGFuZGxlRW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRW5kXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkVuZCgpO1xuICB9XG5cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQ2FuY2VsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy5kZXRhY2goKTtcbiAgICBvbkNhbmNlbCgpO1xuICB9XG5cbiAgaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSBLZXlib2FyZENvZGUuRXNjKSB7XG4gICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzJGRvY3VtZW50JGdldFNlbDtcblxuICAgIChfdGhpcyRkb2N1bWVudCRnZXRTZWwgPSB0aGlzLmRvY3VtZW50LmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZG9jdW1lbnQkZ2V0U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICB9XG5cbn1cblxuY29uc3QgZXZlbnRzID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ3BvaW50ZXJtb3ZlJ1xuICB9LFxuICBlbmQ6IHtcbiAgICBuYW1lOiAncG9pbnRlcnVwJ1xuICB9XG59O1xuY2xhc3MgUG9pbnRlclNlbnNvciBleHRlbmRzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRcbiAgICB9ID0gcHJvcHM7IC8vIFBvaW50ZXIgZXZlbnRzIHN0b3AgZmlyaW5nIGlmIHRoZSB0YXJnZXQgaXMgdW5tb3VudGVkIHdoaWxlIGRyYWdnaW5nXG4gICAgLy8gVGhlcmVmb3JlIHdlIGF0dGFjaCBsaXN0ZW5lcnMgdG8gdGhlIG93bmVyIGRvY3VtZW50IGluc3RlYWRcblxuICAgIGNvbnN0IGxpc3RlbmVyVGFyZ2V0ID0gZ2V0T3duZXJEb2N1bWVudChldmVudC50YXJnZXQpO1xuICAgIHN1cGVyKHByb3BzLCBldmVudHMsIGxpc3RlbmVyVGFyZ2V0KTtcbiAgfVxuXG59XG5Qb2ludGVyU2Vuc29yLmFjdGl2YXRvcnMgPSBbe1xuICBldmVudE5hbWU6ICdvblBvaW50ZXJEb3duJyxcbiAgaGFuZGxlcjogKF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoIWV2ZW50LmlzUHJpbWFyeSB8fCBldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvbkFjdGl2YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWN0aXZhdGlvbih7XG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XTtcblxuY29uc3QgZXZlbnRzJDEgPSB7XG4gIG1vdmU6IHtcbiAgICBuYW1lOiAnbW91c2Vtb3ZlJ1xuICB9LFxuICBlbmQ6IHtcbiAgICBuYW1lOiAnbW91c2V1cCdcbiAgfVxufTtcbnZhciBNb3VzZUJ1dHRvbjtcblxuKGZ1bmN0aW9uIChNb3VzZUJ1dHRvbikge1xuICBNb3VzZUJ1dHRvbltNb3VzZUJ1dHRvbltcIlJpZ2h0Q2xpY2tcIl0gPSAyXSA9IFwiUmlnaHRDbGlja1wiO1xufSkoTW91c2VCdXR0b24gfHwgKE1vdXNlQnV0dG9uID0ge30pKTtcblxuY2xhc3MgTW91c2VTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzLCBldmVudHMkMSwgZ2V0T3duZXJEb2N1bWVudChwcm9wcy5ldmVudC50YXJnZXQpKTtcbiAgfVxuXG59XG5Nb3VzZVNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25Nb3VzZURvd24nLFxuICBoYW5kbGVyOiAoX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIG9uQWN0aXZhdGlvblxuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmIChldmVudC5idXR0b24gPT09IE1vdXNlQnV0dG9uLlJpZ2h0Q2xpY2spIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBvbkFjdGl2YXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWN0aXZhdGlvbih7XG4gICAgICBldmVudFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XTtcblxuY29uc3QgZXZlbnRzJDIgPSB7XG4gIG1vdmU6IHtcbiAgICBuYW1lOiAndG91Y2htb3ZlJ1xuICB9LFxuICBlbmQ6IHtcbiAgICBuYW1lOiAndG91Y2hlbmQnXG4gIH1cbn07XG5jbGFzcyBUb3VjaFNlbnNvciBleHRlbmRzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMsIGV2ZW50cyQyKTtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cCgpIHtcbiAgICAvLyBBZGRpbmcgYSBub24tY2FwdHVyZSBhbmQgbm9uLXBhc3NpdmUgYHRvdWNobW92ZWAgbGlzdGVuZXIgaW4gb3JkZXJcbiAgICAvLyB0byBmb3JjZSBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgY2FsbHMgdG8gd29yayBpbiBkeW5hbWljYWxseSBhZGRlZFxuICAgIC8vIHRvdWNobW92ZSBldmVudCBoYW5kbGVycy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgaU9TIFNhZmFyaS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMkMi5tb3ZlLm5hbWUsIG5vb3AsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHMkMi5tb3ZlLm5hbWUsIG5vb3ApO1xuICAgIH07IC8vIFdlIGNyZWF0ZSBhIG5ldyBoYW5kbGVyIGJlY2F1c2UgdGhlIHRlYXJkb3duIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2Vuc29yXG4gICAgLy8gY291bGQgcmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lciBpZiB3ZSB1c2UgYSByZWZlcmVudGlhbGx5IGVxdWFsIGxpc3RlbmVyLlxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIH1cblxufVxuVG91Y2hTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uVG91Y2hTdGFydCcsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdWNoZXNcbiAgICB9ID0gZXZlbnQ7XG5cbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbnZhciBBdXRvU2Nyb2xsQWN0aXZhdG9yO1xuXG4oZnVuY3Rpb24gKEF1dG9TY3JvbGxBY3RpdmF0b3IpIHtcbiAgQXV0b1Njcm9sbEFjdGl2YXRvcltBdXRvU2Nyb2xsQWN0aXZhdG9yW1wiUG9pbnRlclwiXSA9IDBdID0gXCJQb2ludGVyXCI7XG4gIEF1dG9TY3JvbGxBY3RpdmF0b3JbQXV0b1Njcm9sbEFjdGl2YXRvcltcIkRyYWdnYWJsZVJlY3RcIl0gPSAxXSA9IFwiRHJhZ2dhYmxlUmVjdFwiO1xufSkoQXV0b1Njcm9sbEFjdGl2YXRvciB8fCAoQXV0b1Njcm9sbEFjdGl2YXRvciA9IHt9KSk7XG5cbnZhciBUcmF2ZXJzYWxPcmRlcjtcblxuKGZ1bmN0aW9uIChUcmF2ZXJzYWxPcmRlcikge1xuICBUcmF2ZXJzYWxPcmRlcltUcmF2ZXJzYWxPcmRlcltcIlRyZWVPcmRlclwiXSA9IDBdID0gXCJUcmVlT3JkZXJcIjtcbiAgVHJhdmVyc2FsT3JkZXJbVHJhdmVyc2FsT3JkZXJbXCJSZXZlcnNlZFRyZWVPcmRlclwiXSA9IDFdID0gXCJSZXZlcnNlZFRyZWVPcmRlclwiO1xufSkoVHJhdmVyc2FsT3JkZXIgfHwgKFRyYXZlcnNhbE9yZGVyID0ge30pKTtcblxuZnVuY3Rpb24gdXNlQXV0b1Njcm9sbGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhY2NlbGVyYXRpb24sXG4gICAgYWN0aXZhdG9yID0gQXV0b1Njcm9sbEFjdGl2YXRvci5Qb2ludGVyLFxuICAgIGNhblNjcm9sbCxcbiAgICBkcmFnZ2luZ1JlY3QsXG4gICAgZW5hYmxlZCxcbiAgICBpbnRlcnZhbCA9IDUsXG4gICAgb3JkZXIgPSBUcmF2ZXJzYWxPcmRlci5UcmVlT3JkZXIsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgZGVsdGEsXG4gICAgdGhyZXNob2xkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzY3JvbGxJbnRlbnQgPSB1c2VTY3JvbGxJbnRlbnQoe1xuICAgIGRlbHRhLFxuICAgIGRpc2FibGVkOiAhZW5hYmxlZFxuICB9KTtcbiAgY29uc3QgW3NldEF1dG9TY3JvbGxJbnRlcnZhbCwgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWxdID0gdXNlSW50ZXJ2YWwoKTtcbiAgY29uc3Qgc2Nyb2xsU3BlZWQgPSB1c2VSZWYoe1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsRGlyZWN0aW9uID0gdXNlUmVmKHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSk7XG4gIGNvbnN0IHJlY3QgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGl2YXRvcikge1xuICAgICAgY2FzZSBBdXRvU2Nyb2xsQWN0aXZhdG9yLlBvaW50ZXI6XG4gICAgICAgIHJldHVybiBwb2ludGVyQ29vcmRpbmF0ZXMgPyB7XG4gICAgICAgICAgdG9wOiBwb2ludGVyQ29vcmRpbmF0ZXMueSxcbiAgICAgICAgICBib3R0b206IHBvaW50ZXJDb29yZGluYXRlcy55LFxuICAgICAgICAgIGxlZnQ6IHBvaW50ZXJDb29yZGluYXRlcy54LFxuICAgICAgICAgIHJpZ2h0OiBwb2ludGVyQ29vcmRpbmF0ZXMueFxuICAgICAgICB9IDogbnVsbDtcblxuICAgICAgY2FzZSBBdXRvU2Nyb2xsQWN0aXZhdG9yLkRyYWdnYWJsZVJlY3Q6XG4gICAgICAgIHJldHVybiBkcmFnZ2luZ1JlY3Q7XG4gICAgfVxuICB9LCBbYWN0aXZhdG9yLCBkcmFnZ2luZ1JlY3QsIHBvaW50ZXJDb29yZGluYXRlc10pO1xuICBjb25zdCBzY3JvbGxDb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGF1dG9TY3JvbGwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoIXNjcm9sbENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBzY3JvbGxTcGVlZC5jdXJyZW50LnggKiBzY3JvbGxEaXJlY3Rpb24uY3VycmVudC54O1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbFNwZWVkLmN1cnJlbnQueSAqIHNjcm9sbERpcmVjdGlvbi5jdXJyZW50Lnk7XG4gICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc29ydGVkU2Nyb2xsYWJsZUFuY2VzdG9ycyA9IHVzZU1lbW8oKCkgPT4gb3JkZXIgPT09IFRyYXZlcnNhbE9yZGVyLlRyZWVPcmRlciA/IFsuLi5zY3JvbGxhYmxlQW5jZXN0b3JzXS5yZXZlcnNlKCkgOiBzY3JvbGxhYmxlQW5jZXN0b3JzLCBbb3JkZXIsIHNjcm9sbGFibGVBbmNlc3RvcnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXNjcm9sbGFibGVBbmNlc3RvcnMubGVuZ3RoIHx8ICFyZWN0KSB7XG4gICAgICBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc2Nyb2xsQ29udGFpbmVyIG9mIHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgICAgIGlmICgoY2FuU2Nyb2xsID09IG51bGwgPyB2b2lkIDAgOiBjYW5TY3JvbGwoc2Nyb2xsQ29udGFpbmVyKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHNjcm9sbGFibGVBbmNlc3RvcnMuaW5kZXhPZihzY3JvbGxDb250YWluZXIpO1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVjdCA9IHNjcm9sbGFibGVBbmNlc3RvclJlY3RzW2luZGV4XTtcblxuICAgICAgaWYgKCFzY3JvbGxDb250YWluZXJSZWN0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc3BlZWRcbiAgICAgIH0gPSBnZXRTY3JvbGxEaXJlY3Rpb25BbmRTcGVlZChzY3JvbGxDb250YWluZXIsIHNjcm9sbENvbnRhaW5lclJlY3QsIHJlY3QsIGFjY2VsZXJhdGlvbiwgdGhyZXNob2xkKTtcblxuICAgICAgZm9yIChjb25zdCBheGlzIG9mIFsneCcsICd5J10pIHtcbiAgICAgICAgaWYgKCFzY3JvbGxJbnRlbnRbYXhpc11bZGlyZWN0aW9uW2F4aXNdXSkge1xuICAgICAgICAgIHNwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICBkaXJlY3Rpb25bYXhpc10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVlZC54ID4gMCB8fCBzcGVlZC55ID4gMCkge1xuICAgICAgICBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCgpO1xuICAgICAgICBzY3JvbGxDb250YWluZXJSZWYuY3VycmVudCA9IHNjcm9sbENvbnRhaW5lcjtcbiAgICAgICAgc2V0QXV0b1Njcm9sbEludGVydmFsKGF1dG9TY3JvbGwsIGludGVydmFsKTtcbiAgICAgICAgc2Nyb2xsU3BlZWQuY3VycmVudCA9IHNwZWVkO1xuICAgICAgICBzY3JvbGxEaXJlY3Rpb24uY3VycmVudCA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjcm9sbFNwZWVkLmN1cnJlbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbYWNjZWxlcmF0aW9uLCBhdXRvU2Nyb2xsLCBjYW5TY3JvbGwsIGNsZWFyQXV0b1Njcm9sbEludGVydmFsLCBlbmFibGVkLCBpbnRlcnZhbCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeShyZWN0KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeShzY3JvbGxJbnRlbnQpLCBzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwsIHNjcm9sbGFibGVBbmNlc3RvcnMsIHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMsIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIEpTT04uc3RyaW5naWZ5KHRocmVzaG9sZCldKTtcbn1cbmNvbnN0IGRlZmF1bHRTY3JvbGxJbnRlbnQgPSB7XG4gIHg6IHtcbiAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogZmFsc2UsXG4gICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogZmFsc2VcbiAgfSxcbiAgeToge1xuICAgIFtEaXJlY3Rpb24uQmFja3dhcmRdOiBmYWxzZSxcbiAgICBbRGlyZWN0aW9uLkZvcndhcmRdOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiB1c2VTY3JvbGxJbnRlbnQoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBkZWx0YSxcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHByZXZpb3VzRGVsdGEgPSB1c2VQcmV2aW91cyhkZWx0YSk7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhwcmV2aW91c0ludGVudCA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFwcmV2aW91c0RlbHRhIHx8ICFwcmV2aW91c0ludGVudCkge1xuICAgICAgLy8gUmVzZXQgc2Nyb2xsIGludGVudCB0cmFja2luZyB3aGVuIGF1dG8tc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG4gICAgICByZXR1cm4gZGVmYXVsdFNjcm9sbEludGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB7XG4gICAgICB4OiBNYXRoLnNpZ24oZGVsdGEueCAtIHByZXZpb3VzRGVsdGEueCksXG4gICAgICB5OiBNYXRoLnNpZ24oZGVsdGEueSAtIHByZXZpb3VzRGVsdGEueSlcbiAgICB9OyAvLyBLZWVwIHRyYWNrIG9mIHRoZSB1c2VyIGludGVudCB0byBzY3JvbGwgaW4gZWFjaCBkaXJlY3Rpb24gZm9yIGJvdGggYXhpc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IHByZXZpb3VzSW50ZW50LnhbRGlyZWN0aW9uLkJhY2t3YXJkXSB8fCBkaXJlY3Rpb24ueCA9PT0gLTEsXG4gICAgICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IHByZXZpb3VzSW50ZW50LnhbRGlyZWN0aW9uLkZvcndhcmRdIHx8IGRpcmVjdGlvbi54ID09PSAxXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogcHJldmlvdXNJbnRlbnQueVtEaXJlY3Rpb24uQmFja3dhcmRdIHx8IGRpcmVjdGlvbi55ID09PSAtMSxcbiAgICAgICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogcHJldmlvdXNJbnRlbnQueVtEaXJlY3Rpb24uRm9yd2FyZF0gfHwgZGlyZWN0aW9uLnkgPT09IDFcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGRlbHRhLCBwcmV2aW91c0RlbHRhXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNhY2hlZE5vZGUoZHJhZ2dhYmxlTm9kZXMsIGlkKSB7XG4gIGNvbnN0IGRyYWdnYWJsZU5vZGUgPSBpZCAhPT0gbnVsbCA/IGRyYWdnYWJsZU5vZGVzLmdldChpZCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5vZGUgPSBkcmFnZ2FibGVOb2RlID8gZHJhZ2dhYmxlTm9kZS5ub2RlLmN1cnJlbnQgOiBudWxsO1xuICByZXR1cm4gdXNlTGF6eU1lbW8oY2FjaGVkTm9kZSA9PiB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICBpZiAoaWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gSW4gc29tZSBjYXNlcywgdGhlIGRyYWdnYWJsZSBub2RlIGNhbiB1bm1vdW50IHdoaWxlIGRyYWdnaW5nXG4gICAgLy8gVGhpcyBpcyB0aGUgY2FzZSBmb3IgdmlydHVhbGl6ZWQgbGlzdHMuIEluIHRob3NlIHNpdHVhdGlvbnMsXG4gICAgLy8gd2UgZmFsbCBiYWNrIHRvIHRoZSBsYXN0IGtub3duIHZhbHVlIGZvciB0aGF0IG5vZGUuXG5cblxuICAgIHJldHVybiAoX3JlZiA9IG5vZGUgIT0gbnVsbCA/IG5vZGUgOiBjYWNoZWROb2RlKSAhPSBudWxsID8gX3JlZiA6IG51bGw7XG4gIH0sIFtub2RlLCBpZF0pO1xufVxuXG5mdW5jdGlvbiB1c2VDb21iaW5lQWN0aXZhdG9ycyhzZW5zb3JzLCBnZXRTeW50aGV0aWNIYW5kbGVyKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHNlbnNvcnMucmVkdWNlKChhY2N1bXVsYXRvciwgc2Vuc29yKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2Vuc29yOiBTZW5zb3JcbiAgICB9ID0gc2Vuc29yO1xuICAgIGNvbnN0IHNlbnNvckFjdGl2YXRvcnMgPSBTZW5zb3IuYWN0aXZhdG9ycy5tYXAoYWN0aXZhdG9yID0+ICh7XG4gICAgICBldmVudE5hbWU6IGFjdGl2YXRvci5ldmVudE5hbWUsXG4gICAgICBoYW5kbGVyOiBnZXRTeW50aGV0aWNIYW5kbGVyKGFjdGl2YXRvci5oYW5kbGVyLCBzZW5zb3IpXG4gICAgfSkpO1xuICAgIHJldHVybiBbLi4uYWNjdW11bGF0b3IsIC4uLnNlbnNvckFjdGl2YXRvcnNdO1xuICB9LCBbXSksIFtzZW5zb3JzLCBnZXRTeW50aGV0aWNIYW5kbGVyXSk7XG59XG5cbnZhciBNZWFzdXJpbmdTdHJhdGVneTtcblxuKGZ1bmN0aW9uIChNZWFzdXJpbmdTdHJhdGVneSkge1xuICBNZWFzdXJpbmdTdHJhdGVneVtNZWFzdXJpbmdTdHJhdGVneVtcIkFsd2F5c1wiXSA9IDBdID0gXCJBbHdheXNcIjtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJCZWZvcmVEcmFnZ2luZ1wiXSA9IDFdID0gXCJCZWZvcmVEcmFnZ2luZ1wiO1xuICBNZWFzdXJpbmdTdHJhdGVneVtNZWFzdXJpbmdTdHJhdGVneVtcIldoaWxlRHJhZ2dpbmdcIl0gPSAyXSA9IFwiV2hpbGVEcmFnZ2luZ1wiO1xufSkoTWVhc3VyaW5nU3RyYXRlZ3kgfHwgKE1lYXN1cmluZ1N0cmF0ZWd5ID0ge30pKTtcblxudmFyIE1lYXN1cmluZ0ZyZXF1ZW5jeTtcblxuKGZ1bmN0aW9uIChNZWFzdXJpbmdGcmVxdWVuY3kpIHtcbiAgTWVhc3VyaW5nRnJlcXVlbmN5W1wiT3B0aW1pemVkXCJdID0gXCJvcHRpbWl6ZWRcIjtcbn0pKE1lYXN1cmluZ0ZyZXF1ZW5jeSB8fCAoTWVhc3VyaW5nRnJlcXVlbmN5ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFZhbHVlID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZU1lYXN1cmluZyhjb250YWluZXJzLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgZHJhZ2dpbmcsXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIGNvbmZpZ1xuICB9ID0gX3JlZjtcbiAgY29uc3QgW3F1ZXVlLCBzZXRRdWV1ZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qge1xuICAgIGZyZXF1ZW5jeSxcbiAgICBtZWFzdXJlLFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGNvbnRhaW5lcnNSZWYgPSB1c2VSZWYoY29udGFpbmVycyk7XG4gIGNvbnN0IGRpc2FibGVkID0gaXNEaXNhYmxlZCgpO1xuICBjb25zdCBkaXNhYmxlZFJlZiA9IHVzZUxhdGVzdFZhbHVlKGRpc2FibGVkKTtcbiAgY29uc3QgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoaWRzKSB7XG4gICAgaWYgKGlkcyA9PT0gdm9pZCAwKSB7XG4gICAgICBpZHMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFF1ZXVlKHZhbHVlID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWUuY29uY2F0KGlkcy5maWx0ZXIoaWQgPT4gIXZhbHVlLmluY2x1ZGVzKGlkKSkpO1xuICAgIH0pO1xuICB9LCBbZGlzYWJsZWRSZWZdKTtcbiAgY29uc3QgdGltZW91dElkID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBkcm9wcGFibGVSZWN0cyA9IHVzZUxhenlNZW1vKHByZXZpb3VzVmFsdWUgPT4ge1xuICAgIGlmIChkaXNhYmxlZCAmJiAhZHJhZ2dpbmcpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFwcmV2aW91c1ZhbHVlIHx8IHByZXZpb3VzVmFsdWUgPT09IGRlZmF1bHRWYWx1ZSB8fCBjb250YWluZXJzUmVmLmN1cnJlbnQgIT09IGNvbnRhaW5lcnMgfHwgcXVldWUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuXG4gICAgICBmb3IgKGxldCBjb250YWluZXIgb2YgY29udGFpbmVycykge1xuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1ZXVlICYmIHF1ZXVlLmxlbmd0aCA+IDAgJiYgIXF1ZXVlLmluY2x1ZGVzKGNvbnRhaW5lci5pZCkgJiYgY29udGFpbmVyLnJlY3QuY3VycmVudCkge1xuICAgICAgICAgIC8vIFRoaXMgY29udGFpbmVyIGRvZXMgbm90IG5lZWQgdG8gYmUgcmUtbWVhc3VyZWRcbiAgICAgICAgICBtYXAuc2V0KGNvbnRhaW5lci5pZCwgY29udGFpbmVyLnJlY3QuY3VycmVudCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gY29udGFpbmVyLm5vZGUuY3VycmVudDtcbiAgICAgICAgY29uc3QgcmVjdCA9IG5vZGUgPyBuZXcgUmVjdChtZWFzdXJlKG5vZGUpLCBub2RlKSA6IG51bGw7XG4gICAgICAgIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQgPSByZWN0O1xuXG4gICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgbWFwLnNldChjb250YWluZXIuaWQsIHJlY3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gIH0sIFtjb250YWluZXJzLCBxdWV1ZSwgZHJhZ2dpbmcsIGRpc2FibGVkLCBtZWFzdXJlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29udGFpbmVyc1JlZi5jdXJyZW50ID0gY29udGFpbmVycztcbiAgfSwgW2NvbnRhaW5lcnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycygpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkcmFnZ2luZywgZGlzYWJsZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocXVldWUgJiYgcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgc2V0UXVldWUobnVsbCk7XG4gICAgfVxuICB9LCAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW0pTT04uc3RyaW5naWZ5KHF1ZXVlKV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCB0eXBlb2YgZnJlcXVlbmN5ICE9PSAnbnVtYmVyJyB8fCB0aW1lb3V0SWQuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVvdXRJZC5jdXJyZW50ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycygpO1xuICAgICAgdGltZW91dElkLmN1cnJlbnQgPSBudWxsO1xuICAgIH0sIGZyZXF1ZW5jeSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2ZyZXF1ZW5jeSwgZGlzYWJsZWQsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLCAuLi5kZXBlbmRlbmNpZXNdKTtcbiAgcmV0dXJuIHtcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBtZWFzdXJpbmdTY2hlZHVsZWQ6IHF1ZXVlICE9IG51bGxcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Rpc2FibGVkKCkge1xuICAgIHN3aXRjaCAoc3RyYXRlZ3kpIHtcbiAgICAgIGNhc2UgTWVhc3VyaW5nU3RyYXRlZ3kuQWx3YXlzOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNhc2UgTWVhc3VyaW5nU3RyYXRlZ3kuQmVmb3JlRHJhZ2dpbmc6XG4gICAgICAgIHJldHVybiBkcmFnZ2luZztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICFkcmFnZ2luZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlSW5pdGlhbFZhbHVlKHZhbHVlLCBjb21wdXRlRm4pIHtcbiAgcmV0dXJuIHVzZUxhenlNZW1vKHByZXZpb3VzVmFsdWUgPT4ge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c1ZhbHVlKSB7XG4gICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZW9mIGNvbXB1dGVGbiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXB1dGVGbih2YWx1ZSkgOiB2YWx1ZTtcbiAgfSwgW2NvbXB1dGVGbiwgdmFsdWVdKTtcbn1cblxuZnVuY3Rpb24gdXNlSW5pdGlhbFJlY3Qobm9kZSwgbWVhc3VyZSkge1xuICByZXR1cm4gdXNlSW5pdGlhbFZhbHVlKG5vZGUsIG1lYXN1cmUpO1xufVxuXG4vKipcclxuICogUmV0dXJucyBhIG5ldyBNdXRhdGlvbk9ic2VydmVyIGluc3RhbmNlLlxyXG4gKiBJZiBgTXV0YXRpb25PYnNlcnZlcmAgaXMgdW5kZWZpbmVkIGluIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQsIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbk9ic2VydmVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjYWxsYmFjayxcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjtcbiAgY29uc3QgaGFuZGxlTXV0YXRpb25zID0gdXNlRXZlbnQoY2FsbGJhY2spO1xuICBjb25zdCBtdXRhdGlvbk9ic2VydmVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgTXV0YXRpb25PYnNlcnZlclxuICAgIH0gPSB3aW5kb3c7XG4gICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9ucyk7XG4gIH0sIFtoYW5kbGVNdXRhdGlvbnMsIGRpc2FibGVkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IG11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbbXV0YXRpb25PYnNlcnZlcl0pO1xuICByZXR1cm4gbXV0YXRpb25PYnNlcnZlcjtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgUmVzaXplT2JzZXJ2ZXIgaW5zdGFuY2UgYm91bmQgdG8gdGhlIGBvblJlc2l6ZWAgY2FsbGJhY2suXHJcbiAqIElmIGBSZXNpemVPYnNlcnZlcmAgaXMgdW5kZWZpbmVkIGluIHRoZSBleGVjdXRpb24gZW52aXJvbm1lbnQsIHJldHVybnMgYHVuZGVmaW5lZGAuXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2ssXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IHVzZUV2ZW50KGNhbGxiYWNrKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5SZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgUmVzaXplT2JzZXJ2ZXJcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoaGFuZGxlUmVzaXplKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZGlzYWJsZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW3Jlc2l6ZU9ic2VydmVyXSk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdE1lYXN1cmUoZWxlbWVudCkge1xuICByZXR1cm4gbmV3IFJlY3QoZ2V0Q2xpZW50UmVjdChlbGVtZW50KSwgZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY3QoZWxlbWVudCwgbWVhc3VyZSwgZmFsbGJhY2tSZWN0KSB7XG4gIGlmIChtZWFzdXJlID09PSB2b2lkIDApIHtcbiAgICBtZWFzdXJlID0gZGVmYXVsdE1lYXN1cmU7XG4gIH1cblxuICBjb25zdCBbcmVjdCwgbWVhc3VyZVJlY3RdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBudWxsKTtcbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrKHJlY29yZHMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0gPSByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5jb250YWlucyhlbGVtZW50KSkge1xuICAgICAgICAgIG1lYXN1cmVSZWN0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrOiBtZWFzdXJlUmVjdFxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgbWVhc3VyZVJlY3QoKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50XSk7XG4gIHJldHVybiByZWN0O1xuXG4gIGZ1bmN0aW9uIHJlZHVjZXIoY3VycmVudFJlY3QpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmlzQ29ubmVjdGVkID09PSBmYWxzZSkge1xuICAgICAgdmFyIF9yZWY7XG5cbiAgICAgIC8vIEZhbGwgYmFjayB0byBsYXN0IHJlY3Qgd2UgbWVhc3VyZWQgaWYgdGhlIGVsZW1lbnQgaXNcbiAgICAgIC8vIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIERPTS5cbiAgICAgIHJldHVybiAoX3JlZiA9IGN1cnJlbnRSZWN0ICE9IG51bGwgPyBjdXJyZW50UmVjdCA6IGZhbGxiYWNrUmVjdCkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1JlY3QgPSBtZWFzdXJlKGVsZW1lbnQpO1xuXG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KGN1cnJlbnRSZWN0KSA9PT0gSlNPTi5zdHJpbmdpZnkobmV3UmVjdCkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50UmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VSZWN0RGVsdGEocmVjdCkge1xuICBjb25zdCBpbml0aWFsUmVjdCA9IHVzZUluaXRpYWxWYWx1ZShyZWN0KTtcbiAgcmV0dXJuIGdldFJlY3REZWx0YShyZWN0LCBpbml0aWFsUmVjdCk7XG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSQxID0gW107XG5mdW5jdGlvbiB1c2VTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNOb2RlID0gdXNlUmVmKG5vZGUpO1xuICBjb25zdCBhbmNlc3RvcnMgPSB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUkMTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSAmJiBwcmV2aW91c1ZhbHVlICE9PSBkZWZhdWx0VmFsdWUkMSAmJiBub2RlICYmIHByZXZpb3VzTm9kZS5jdXJyZW50ICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gcHJldmlvdXNOb2RlLmN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSk7XG4gIH0sIFtub2RlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJldmlvdXNOb2RlLmN1cnJlbnQgPSBub2RlO1xuICB9LCBbbm9kZV0pO1xuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JvbGxPZmZzZXRzKGVsZW1lbnRzKSB7XG4gIGNvbnN0IFtzY3JvbGxDb29yZGluYXRlcywgc2V0U2Nyb2xsQ29vcmRpbmF0ZXNdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZFbGVtZW50cyA9IHVzZVJlZihlbGVtZW50cyk7IC8vIFRvLWRvOiBUaHJvdHRsZSB0aGUgaGFuZGxlU2Nyb2xsIGNhbGxiYWNrXG5cbiAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSBnZXRTY3JvbGxhYmxlRWxlbWVudChldmVudC50YXJnZXQpO1xuXG4gICAgaWYgKCFzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0U2Nyb2xsQ29vcmRpbmF0ZXMoc2Nyb2xsQ29vcmRpbmF0ZXMgPT4ge1xuICAgICAgaWYgKCFzY3JvbGxDb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsQ29vcmRpbmF0ZXMuc2V0KHNjcm9sbGluZ0VsZW1lbnQsIGdldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbGluZ0VsZW1lbnQpKTtcbiAgICAgIHJldHVybiBuZXcgTWFwKHNjcm9sbENvb3JkaW5hdGVzKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzRWxlbWVudHMgPSBwcmV2RWxlbWVudHMuY3VycmVudDtcblxuICAgIGlmIChlbGVtZW50cyAhPT0gcHJldmlvdXNFbGVtZW50cykge1xuICAgICAgY2xlYW51cChwcmV2aW91c0VsZW1lbnRzKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFtzY3JvbGxhYmxlRWxlbWVudCwgZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMoc2Nyb2xsYWJsZUVsZW1lbnQpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5ICE9IG51bGwpO1xuICAgICAgc2V0U2Nyb2xsQ29vcmRpbmF0ZXMoZW50cmllcy5sZW5ndGggPyBuZXcgTWFwKGVudHJpZXMpIDogbnVsbCk7XG4gICAgICBwcmV2RWxlbWVudHMuY3VycmVudCA9IGVsZW1lbnRzO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKGVsZW1lbnRzKTtcbiAgICAgIGNsZWFudXAocHJldmlvdXNFbGVtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxhYmxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbaGFuZGxlU2Nyb2xsLCBlbGVtZW50c10pO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNjcm9sbENvb3JkaW5hdGVzID8gQXJyYXkuZnJvbShzY3JvbGxDb29yZGluYXRlcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIGNvb3JkaW5hdGVzKSA9PiBhZGQoYWNjLCBjb29yZGluYXRlcyksIGRlZmF1bHRDb29yZGluYXRlcykgOiBnZXRTY3JvbGxPZmZzZXRzKGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdENvb3JkaW5hdGVzO1xuICB9LCBbZWxlbWVudHMsIHNjcm9sbENvb3JkaW5hdGVzXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzLCBkZXBlbmRlbmNpZXMpIHtcbiAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgZGVwZW5kZW5jaWVzID0gW107XG4gIH1cblxuICBjb25zdCBpbml0aWFsU2Nyb2xsT2Zmc2V0cyA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID0gbnVsbDtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBkZXBlbmRlbmNpZXMpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhc1Njcm9sbE9mZnNldHMgPSBzY3JvbGxPZmZzZXRzICE9PSBkZWZhdWx0Q29vcmRpbmF0ZXM7XG5cbiAgICBpZiAoaGFzU2Nyb2xsT2Zmc2V0cyAmJiAhaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCkge1xuICAgICAgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCA9IHNjcm9sbE9mZnNldHM7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNTY3JvbGxPZmZzZXRzICYmIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3Njcm9sbE9mZnNldHNdKTtcbiAgcmV0dXJuIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPyBzdWJ0cmFjdChzY3JvbGxPZmZzZXRzLCBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50KSA6IGRlZmF1bHRDb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gdXNlU2Vuc29yU2V0dXAoc2Vuc29ycykge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FuVXNlRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGVhcmRvd25GbnMgPSBzZW5zb3JzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHNlbnNvclxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gc2Vuc29yLnNldHVwID09IG51bGwgPyB2b2lkIDAgOiBzZW5zb3Iuc2V0dXAoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB0ZWFyZG93biBvZiB0ZWFyZG93bkZucykge1xuICAgICAgICB0ZWFyZG93biA9PSBudWxsID8gdm9pZCAwIDogdGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBUTy1ETzogU2Vuc29ycyBsZW5ndGggY291bGQgdGhlb3JldGljYWxseSBjaGFuZ2Ugd2hpY2ggd291bGQgbm90IGJlIGEgdmFsaWQgZGVwZW5kZW5jeVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHNlbnNvcnMubWFwKF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgc2Vuc29yXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiBzZW5zb3I7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gdXNlU3ludGhldGljTGlzdGVuZXJzKGxpc3RlbmVycywgaWQpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBsaXN0ZW5lcnMucmVkdWNlKChhY2MsIF9yZWYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgaGFuZGxlclxuICAgICAgfSA9IF9yZWY7XG5cbiAgICAgIGFjY1tldmVudE5hbWVdID0gZXZlbnQgPT4ge1xuICAgICAgICBoYW5kbGVyKGV2ZW50LCBpZCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfSwgW2xpc3RlbmVycywgaWRdKTtcbn1cblxuZnVuY3Rpb24gdXNlV2luZG93UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGVsZW1lbnQgPyBnZXRXaW5kb3dDbGllbnRSZWN0KGVsZW1lbnQpIDogbnVsbCwgW2VsZW1lbnRdKTtcbn1cblxuY29uc3QgZGVmYXVsdFZhbHVlJDIgPSBbXTtcbmZ1bmN0aW9uIHVzZVJlY3RzKGVsZW1lbnRzLCBtZWFzdXJlKSB7XG4gIGlmIChtZWFzdXJlID09PSB2b2lkIDApIHtcbiAgICBtZWFzdXJlID0gZ2V0Q2xpZW50UmVjdDtcbiAgfVxuXG4gIGNvbnN0IFtmaXJzdEVsZW1lbnRdID0gZWxlbWVudHM7XG4gIGNvbnN0IHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZWN0KGZpcnN0RWxlbWVudCA/IGdldFdpbmRvdyhmaXJzdEVsZW1lbnQpIDogbnVsbCk7XG4gIGNvbnN0IFtyZWN0cywgbWVhc3VyZVJlY3RzXSA9IHVzZVJlZHVjZXIocmVkdWNlciwgZGVmYXVsdFZhbHVlJDIpO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogbWVhc3VyZVJlY3RzXG4gIH0pO1xuXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwICYmIHJlY3RzID09PSBkZWZhdWx0VmFsdWUkMikge1xuICAgIG1lYXN1cmVSZWN0cygpO1xuICB9XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG1lYXN1cmVSZWN0cygpO1xuICAgIH1cbiAgfSwgW2VsZW1lbnRzXSk7XG4gIHJldHVybiByZWN0cztcblxuICBmdW5jdGlvbiByZWR1Y2VyKCkge1xuICAgIGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlJDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzLm1hcChlbGVtZW50ID0+IGlzRG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpID8gd2luZG93UmVjdCA6IG5ldyBSZWN0KG1lYXN1cmUoZWxlbWVudCksIGVsZW1lbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZWFzdXJhYmxlTm9kZShub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgY29uc3QgZmlyc3RDaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGZpcnN0Q2hpbGQpID8gZmlyc3RDaGlsZCA6IG5vZGU7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWdPdmVybGF5TWVhc3VyaW5nKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBtZWFzdXJlXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbcmVjdCwgc2V0UmVjdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gdXNlQ2FsbGJhY2soZW50cmllcyA9PiB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9IG9mIGVudHJpZXMpIHtcbiAgICAgIGlmIChpc0hUTUxFbGVtZW50KHRhcmdldCkpIHtcbiAgICAgICAgc2V0UmVjdChyZWN0ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdSZWN0ID0gbWVhc3VyZSh0YXJnZXQpO1xuICAgICAgICAgIHJldHVybiByZWN0ID8geyAuLi5yZWN0LFxuICAgICAgICAgICAgd2lkdGg6IG5ld1JlY3Qud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5ld1JlY3QuaGVpZ2h0XG4gICAgICAgICAgfSA6IG5ld1JlY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sIFttZWFzdXJlXSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrOiBoYW5kbGVSZXNpemVcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZU5vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhlbGVtZW50ID0+IHtcbiAgICBjb25zdCBub2RlID0gZ2V0TWVhc3VyYWJsZU5vZGUoZWxlbWVudCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShub2RlKTtcbiAgICB9XG5cbiAgICBzZXRSZWN0KG5vZGUgPyBtZWFzdXJlKG5vZGUpIDogbnVsbCk7XG4gIH0sIFttZWFzdXJlLCByZXNpemVPYnNlcnZlcl0pO1xuICBjb25zdCBbbm9kZVJlZiwgc2V0UmVmXSA9IHVzZU5vZGVSZWYoaGFuZGxlTm9kZUNoYW5nZSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgbm9kZVJlZixcbiAgICByZWN0LFxuICAgIHNldFJlZlxuICB9KSwgW3JlY3QsIG5vZGVSZWYsIHNldFJlZl0pO1xufVxuXG5jb25zdCBkZWZhdWx0U2Vuc29ycyA9IFt7XG4gIHNlbnNvcjogUG9pbnRlclNlbnNvcixcbiAgb3B0aW9uczoge31cbn0sIHtcbiAgc2Vuc29yOiBLZXlib2FyZFNlbnNvcixcbiAgb3B0aW9uczoge31cbn1dO1xuY29uc3QgZGVmYXVsdERhdGEgPSB7XG4gIGN1cnJlbnQ6IHt9XG59O1xuY29uc3QgZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24gPSB7XG4gIGRyYWdnYWJsZToge1xuICAgIG1lYXN1cmU6IGdldFRyYW5zZm9ybUFnbm9zdGljQ2xpZW50UmVjdFxuICB9LFxuICBkcm9wcGFibGU6IHtcbiAgICBtZWFzdXJlOiBnZXRUcmFuc2Zvcm1BZ25vc3RpY0NsaWVudFJlY3QsXG4gICAgc3RyYXRlZ3k6IE1lYXN1cmluZ1N0cmF0ZWd5LldoaWxlRHJhZ2dpbmcsXG4gICAgZnJlcXVlbmN5OiBNZWFzdXJpbmdGcmVxdWVuY3kuT3B0aW1pemVkXG4gIH0sXG4gIGRyYWdPdmVybGF5OiB7XG4gICAgbWVhc3VyZTogZ2V0Q2xpZW50UmVjdFxuICB9XG59O1xuXG5jbGFzcyBEcm9wcGFibGVDb250YWluZXJzTWFwIGV4dGVuZHMgTWFwIHtcbiAgZ2V0KGlkKSB7XG4gICAgdmFyIF9zdXBlciRnZXQ7XG5cbiAgICByZXR1cm4gaWQgIT0gbnVsbCA/IChfc3VwZXIkZ2V0ID0gc3VwZXIuZ2V0KGlkKSkgIT0gbnVsbCA/IF9zdXBlciRnZXQgOiB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB0b0FycmF5KCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMudmFsdWVzKCkpO1xuICB9XG5cbiAgZ2V0RW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZmlsdGVyKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgZGlzYWJsZWRcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIGdldE5vZGVGb3IoaWQpIHtcbiAgICB2YXIgX3RoaXMkZ2V0JG5vZGUkY3VycmVuLCBfdGhpcyRnZXQ7XG5cbiAgICByZXR1cm4gKF90aGlzJGdldCRub2RlJGN1cnJlbiA9IChfdGhpcyRnZXQgPSB0aGlzLmdldChpZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRnZXQubm9kZS5jdXJyZW50KSAhPSBudWxsID8gX3RoaXMkZ2V0JG5vZGUkY3VycmVuIDogdW5kZWZpbmVkO1xuICB9XG5cbn1cblxuY29uc3QgZGVmYXVsdFB1YmxpY0NvbnRleHQgPSB7XG4gIGFjdGl2YXRvckV2ZW50OiBudWxsLFxuICBhY3RpdmU6IG51bGwsXG4gIGFjdGl2ZU5vZGU6IG51bGwsXG4gIGFjdGl2ZU5vZGVSZWN0OiBudWxsLFxuICBjb2xsaXNpb25zOiBudWxsLFxuICBjb250YWluZXJOb2RlUmVjdDogbnVsbCxcbiAgZHJhZ2dhYmxlTm9kZXM6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGRyb3BwYWJsZVJlY3RzOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBkcm9wcGFibGVDb250YWluZXJzOiAvKiNfX1BVUkVfXyovbmV3IERyb3BwYWJsZUNvbnRhaW5lcnNNYXAoKSxcbiAgb3ZlcjogbnVsbCxcbiAgZHJhZ092ZXJsYXk6IHtcbiAgICBub2RlUmVmOiB7XG4gICAgICBjdXJyZW50OiBudWxsXG4gICAgfSxcbiAgICByZWN0OiBudWxsLFxuICAgIHNldFJlZjogbm9vcFxuICB9LFxuICBzY3JvbGxhYmxlQW5jZXN0b3JzOiBbXSxcbiAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHM6IFtdLFxuICBtZWFzdXJpbmdDb25maWd1cmF0aW9uOiBkZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnM6IG5vb3AsXG4gIHdpbmRvd1JlY3Q6IG51bGwsXG4gIG1lYXN1cmluZ1NjaGVkdWxlZDogZmFsc2Vcbn07XG5jb25zdCBkZWZhdWx0SW50ZXJuYWxDb250ZXh0ID0ge1xuICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgYWN0aXZhdG9yczogW10sXG4gIGFjdGl2ZTogbnVsbCxcbiAgYWN0aXZlTm9kZVJlY3Q6IG51bGwsXG4gIGFyaWFEZXNjcmliZWRCeUlkOiB7XG4gICAgZHJhZ2dhYmxlOiAnJ1xuICB9LFxuICBkaXNwYXRjaDogbm9vcCxcbiAgZHJhZ2dhYmxlTm9kZXM6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIG92ZXI6IG51bGwsXG4gIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzOiBub29wXG59O1xuY29uc3QgSW50ZXJuYWxDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZGVmYXVsdEludGVybmFsQ29udGV4dCk7XG5jb25zdCBQdWJsaWNDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZGVmYXVsdFB1YmxpY0NvbnRleHQpO1xuXG5mdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiB7XG4gICAgICBhY3RpdmU6IG51bGwsXG4gICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIG5vZGVzOiBuZXcgTWFwKCksXG4gICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcHBhYmxlOiB7XG4gICAgICBjb250YWluZXJzOiBuZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcCgpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIEFjdGlvbi5EcmFnU3RhcnQ6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgZHJhZ2dhYmxlOiB7IC4uLnN0YXRlLmRyYWdnYWJsZSxcbiAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IGFjdGlvbi5pbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgYWN0aXZlOiBhY3Rpb24uYWN0aXZlXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICBjYXNlIEFjdGlvbi5EcmFnTW92ZTpcbiAgICAgIGlmICghc3RhdGUuZHJhZ2dhYmxlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBkcmFnZ2FibGU6IHsgLi4uc3RhdGUuZHJhZ2dhYmxlLFxuICAgICAgICAgIHRyYW5zbGF0ZToge1xuICAgICAgICAgICAgeDogYWN0aW9uLmNvb3JkaW5hdGVzLnggLSBzdGF0ZS5kcmFnZ2FibGUuaW5pdGlhbENvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICB5OiBhY3Rpb24uY29vcmRpbmF0ZXMueSAtIHN0YXRlLmRyYWdnYWJsZS5pbml0aWFsQ29vcmRpbmF0ZXMueVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLkRyYWdFbmQ6XG4gICAgY2FzZSBBY3Rpb24uRHJhZ0NhbmNlbDpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBkcmFnZ2FibGU6IHsgLi4uc3RhdGUuZHJhZ2dhYmxlLFxuICAgICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBBY3Rpb24uUmVnaXN0ZXJEcm9wcGFibGU6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbGVtZW50XG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5zZXQoaWQsIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICBkcm9wcGFibGU6IHsgLi4uc3RhdGUuZHJvcHBhYmxlLFxuICAgICAgICAgICAgY29udGFpbmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgQWN0aW9uLlNldERyb3BwYWJsZURpc2FibGVkOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZWxlbWVudCB8fCBrZXkgIT09IGVsZW1lbnQua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5zZXQoaWQsIHsgLi4uZWxlbWVudCxcbiAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIEFjdGlvbi5VbnJlZ2lzdGVyRHJvcHBhYmxlOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAga2V5XG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZWxlbWVudCB8fCBrZXkgIT09IGVsZW1lbnQua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5kZWxldGUoaWQpO1xuICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICBkcm9wcGFibGU6IHsgLi4uc3RhdGUuZHJvcHBhYmxlLFxuICAgICAgICAgICAgY29udGFpbmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBSZXN0b3JlRm9jdXMoX3JlZikge1xuICBsZXQge1xuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGRyYWdnYWJsZU5vZGVzXG4gIH0gPSB1c2VDb250ZXh0KEludGVybmFsQ29udGV4dCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZhdG9yRXZlbnQgPSB1c2VQcmV2aW91cyhhY3RpdmF0b3JFdmVudCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlSWQgPSB1c2VQcmV2aW91cyhhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZCk7IC8vIFJlc3RvcmUga2V5Ym9hcmQgZm9jdXMgb24gdGhlIGFjdGl2YXRvciBub2RlXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2YXRvckV2ZW50ICYmIHByZXZpb3VzQWN0aXZhdG9yRXZlbnQgJiYgcHJldmlvdXNBY3RpdmVJZCAhPSBudWxsKSB7XG4gICAgICBpZiAoIWlzS2V5Ym9hcmRFdmVudChwcmV2aW91c0FjdGl2YXRvckV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBwcmV2aW91c0FjdGl2YXRvckV2ZW50LnRhcmdldCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RvcmUgZm9jdXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KHByZXZpb3VzQWN0aXZlSWQpO1xuXG4gICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2YXRvck5vZGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBkcmFnZ2FibGVOb2RlO1xuXG4gICAgICBpZiAoIWFjdGl2YXRvck5vZGUuY3VycmVudCAmJiAhbm9kZS5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFthY3RpdmF0b3JOb2RlLmN1cnJlbnQsIG5vZGUuY3VycmVudF0pIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZU5vZGUgPSBmaW5kRmlyc3RGb2N1c2FibGVOb2RlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGZvY3VzYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIGZvY3VzYWJsZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYWN0aXZhdG9yRXZlbnQsIGRpc2FibGVkLCBkcmFnZ2FibGVOb2RlcywgcHJldmlvdXNBY3RpdmVJZCwgcHJldmlvdXNBY3RpdmF0b3JFdmVudF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgdHJhbnNmb3JtLFxuICAgIC4uLmFyZ3NcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBtb2RpZmllcnMgIT0gbnVsbCAmJiBtb2RpZmllcnMubGVuZ3RoID8gbW9kaWZpZXJzLnJlZHVjZSgoYWNjdW11bGF0b3IsIG1vZGlmaWVyKSA9PiB7XG4gICAgcmV0dXJuIG1vZGlmaWVyKHtcbiAgICAgIHRyYW5zZm9ybTogYWNjdW11bGF0b3IsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0sIHRyYW5zZm9ybSkgOiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24oY29uZmlnKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dhYmxlOiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnZ2FibGUpXG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHsgLi4uZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJvcHBhYmxlLFxuICAgICAgLi4uKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyb3BwYWJsZSlcbiAgICB9LFxuICAgIGRyYWdPdmVybGF5OiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdPdmVybGF5LFxuICAgICAgLi4uKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyYWdPdmVybGF5KVxuICAgIH1cbiAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2NvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyYWdnYWJsZSwgY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJvcHBhYmxlLCBjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnT3ZlcmxheV0pO1xufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWN0aXZlTm9kZSxcbiAgICBtZWFzdXJlLFxuICAgIGluaXRpYWxSZWN0LFxuICAgIGNvbmZpZyA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGluaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gdHlwZW9mIGNvbmZpZyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgIHg6IGNvbmZpZyxcbiAgICB5OiBjb25maWdcbiAgfSA6IGNvbmZpZztcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSAheCAmJiAheTtcblxuICAgIGlmIChkaXNhYmxlZCB8fCAhYWN0aXZlTm9kZSkge1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsaXplZC5jdXJyZW50IHx8ICFpbml0aWFsUmVjdCkge1xuICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGxheW91dCBzaGlmdCBzY3JvbGwgY29tcGVuc2F0aW9uIHdhcyBhbHJlYWR5IGF0dGVtcHRlZFxuICAgICAgLy8gb3IgaWYgdGhlcmUgaXMgbm8gaW5pdGlhbFJlY3QgdG8gY29tcGFyZSB0by5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCB0aGUgbW9zdCB1cCB0byBkYXRlIG5vZGUgcmVmIGZvciB0aGUgYWN0aXZlIGRyYWdnYWJsZVxuXG5cbiAgICBjb25zdCBub2RlID0gYWN0aXZlTm9kZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlTm9kZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIFJldHVybiBlYXJseSBpZiB0aGVyZSBpcyBubyBhdHRhY2hlZCBub2RlIHJlZiBvciBpZiB0aGUgbm9kZSBpc1xuICAgICAgLy8gZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY3QgPSBtZWFzdXJlKG5vZGUpO1xuICAgIGNvbnN0IHJlY3REZWx0YSA9IGdldFJlY3REZWx0YShyZWN0LCBpbml0aWFsUmVjdCk7XG5cbiAgICBpZiAoIXgpIHtcbiAgICAgIHJlY3REZWx0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXkpIHtcbiAgICAgIHJlY3REZWx0YS55ID0gMDtcbiAgICB9IC8vIE9ubHkgcGVyZm9ybSBsYXlvdXQgc2hpZnQgc2Nyb2xsIGNvbXBlbnNhdGlvbiBvbmNlXG5cblxuICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgaWYgKE1hdGguYWJzKHJlY3REZWx0YS54KSA+IDAgfHwgTWF0aC5hYnMocmVjdERlbHRhLnkpID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3Rvcihub2RlKTtcblxuICAgICAgaWYgKGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKSB7XG4gICAgICAgIGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yLnNjcm9sbEJ5KHtcbiAgICAgICAgICB0b3A6IHJlY3REZWx0YS55LFxuICAgICAgICAgIGxlZnQ6IHJlY3REZWx0YS54XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2FjdGl2ZU5vZGUsIHgsIHksIGluaXRpYWxSZWN0LCBtZWFzdXJlXSk7XG59XG5cbmNvbnN0IEFjdGl2ZURyYWdnYWJsZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh7IC4uLmRlZmF1bHRDb29yZGluYXRlcyxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn0pO1xudmFyIFN0YXR1cztcblxuKGZ1bmN0aW9uIChTdGF0dXMpIHtcbiAgU3RhdHVzW1N0YXR1c1tcIlVuaW5pdGlhbGl6ZWRcIl0gPSAwXSA9IFwiVW5pbml0aWFsaXplZFwiO1xuICBTdGF0dXNbU3RhdHVzW1wiSW5pdGlhbGl6aW5nXCJdID0gMV0gPSBcIkluaXRpYWxpemluZ1wiO1xuICBTdGF0dXNbU3RhdHVzW1wiSW5pdGlhbGl6ZWRcIl0gPSAyXSA9IFwiSW5pdGlhbGl6ZWRcIjtcbn0pKFN0YXR1cyB8fCAoU3RhdHVzID0ge30pKTtcblxuY29uc3QgRG5kQ29udGV4dCA9IC8qI19fUFVSRV9fKi9tZW1vKGZ1bmN0aW9uIERuZENvbnRleHQoX3JlZikge1xuICB2YXIgX3NlbnNvckNvbnRleHQkY3VycmVuLCBfZHJhZ092ZXJsYXkkbm9kZVJlZiQsIF9kcmFnT3ZlcmxheSRyZWN0LCBfb3ZlciRyZWN0O1xuXG4gIGxldCB7XG4gICAgaWQsXG4gICAgYWNjZXNzaWJpbGl0eSxcbiAgICBhdXRvU2Nyb2xsID0gdHJ1ZSxcbiAgICBjaGlsZHJlbixcbiAgICBzZW5zb3JzID0gZGVmYXVsdFNlbnNvcnMsXG4gICAgY29sbGlzaW9uRGV0ZWN0aW9uID0gcmVjdEludGVyc2VjdGlvbixcbiAgICBtZWFzdXJpbmcsXG4gICAgbW9kaWZpZXJzLFxuICAgIC4uLnByb3BzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzdG9yZSA9IHVzZVJlZHVjZXIocmVkdWNlciwgdW5kZWZpbmVkLCBnZXRJbml0aWFsU3RhdGUpO1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHN0b3JlO1xuICBjb25zdCBbZGlzcGF0Y2hNb25pdG9yRXZlbnQsIHJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyXSA9IHVzZURuZE1vbml0b3JQcm92aWRlcigpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gdXNlU3RhdGUoU3RhdHVzLlVuaW5pdGlhbGl6ZWQpO1xuICBjb25zdCBpc0luaXRpYWxpemVkID0gc3RhdHVzID09PSBTdGF0dXMuSW5pdGlhbGl6ZWQ7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGU6IHtcbiAgICAgIGFjdGl2ZTogYWN0aXZlSWQsXG4gICAgICBub2RlczogZHJhZ2dhYmxlTm9kZXMsXG4gICAgICB0cmFuc2xhdGVcbiAgICB9LFxuICAgIGRyb3BwYWJsZToge1xuICAgICAgY29udGFpbmVyczogZHJvcHBhYmxlQ29udGFpbmVyc1xuICAgIH1cbiAgfSA9IHN0YXRlO1xuICBjb25zdCBub2RlID0gYWN0aXZlSWQgPyBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlSWQpIDogbnVsbDtcbiAgY29uc3QgYWN0aXZlUmVjdHMgPSB1c2VSZWYoe1xuICAgIGluaXRpYWw6IG51bGwsXG4gICAgdHJhbnNsYXRlZDogbnVsbFxuICB9KTtcbiAgY29uc3QgYWN0aXZlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9ub2RlJGRhdGE7XG5cbiAgICByZXR1cm4gYWN0aXZlSWQgIT0gbnVsbCA/IHtcbiAgICAgIGlkOiBhY3RpdmVJZCxcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgZm9yIHRoZSBhY3RpdmUgbm9kZSB0byB1bm1vdW50IHdoaWxlIGRyYWdnaW5nXG4gICAgICBkYXRhOiAoX25vZGUkZGF0YSA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUuZGF0YSkgIT0gbnVsbCA/IF9ub2RlJGRhdGEgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHJlY3Q6IGFjdGl2ZVJlY3RzXG4gICAgfSA6IG51bGw7XG4gIH0sIFthY3RpdmVJZCwgbm9kZV0pO1xuICBjb25zdCBhY3RpdmVSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFthY3RpdmVTZW5zb3IsIHNldEFjdGl2ZVNlbnNvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2FjdGl2YXRvckV2ZW50LCBzZXRBY3RpdmF0b3JFdmVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgbGF0ZXN0UHJvcHMgPSB1c2VMYXRlc3RWYWx1ZShwcm9wcywgT2JqZWN0LnZhbHVlcyhwcm9wcykpO1xuICBjb25zdCBkcmFnZ2FibGVEZXNjcmliZWRCeUlkID0gdXNlVW5pcXVlSWQoXCJEbmREZXNjcmliZWRCeVwiLCBpZCk7XG4gIGNvbnN0IGVuYWJsZWREcm9wcGFibGVDb250YWluZXJzID0gdXNlTWVtbygoKSA9PiBkcm9wcGFibGVDb250YWluZXJzLmdldEVuYWJsZWQoKSwgW2Ryb3BwYWJsZUNvbnRhaW5lcnNdKTtcbiAgY29uc3QgbWVhc3VyaW5nQ29uZmlndXJhdGlvbiA9IHVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24obWVhc3VyaW5nKTtcbiAgY29uc3Qge1xuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgIG1lYXN1cmluZ1NjaGVkdWxlZFxuICB9ID0gdXNlRHJvcHBhYmxlTWVhc3VyaW5nKGVuYWJsZWREcm9wcGFibGVDb250YWluZXJzLCB7XG4gICAgZHJhZ2dpbmc6IGlzSW5pdGlhbGl6ZWQsXG4gICAgZGVwZW5kZW5jaWVzOiBbdHJhbnNsYXRlLngsIHRyYW5zbGF0ZS55XSxcbiAgICBjb25maWc6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJvcHBhYmxlXG4gIH0pO1xuICBjb25zdCBhY3RpdmVOb2RlID0gdXNlQ2FjaGVkTm9kZShkcmFnZ2FibGVOb2RlcywgYWN0aXZlSWQpO1xuICBjb25zdCBhY3RpdmF0aW9uQ29vcmRpbmF0ZXMgPSB1c2VNZW1vKCgpID0+IGFjdGl2YXRvckV2ZW50ID8gZ2V0RXZlbnRDb29yZGluYXRlcyhhY3RpdmF0b3JFdmVudCkgOiBudWxsLCBbYWN0aXZhdG9yRXZlbnRdKTtcbiAgY29uc3QgYXV0b1Njcm9sbE9wdGlvbnMgPSBnZXRBdXRvU2Nyb2xsZXJPcHRpb25zKCk7XG4gIGNvbnN0IGluaXRpYWxBY3RpdmVOb2RlUmVjdCA9IHVzZUluaXRpYWxSZWN0KGFjdGl2ZU5vZGUsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUpO1xuICB1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbih7XG4gICAgYWN0aXZlTm9kZTogYWN0aXZlSWQgPyBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlSWQpIDogbnVsbCxcbiAgICBjb25maWc6IGF1dG9TY3JvbGxPcHRpb25zLmxheW91dFNoaWZ0Q29tcGVuc2F0aW9uLFxuICAgIGluaXRpYWxSZWN0OiBpbml0aWFsQWN0aXZlTm9kZVJlY3QsXG4gICAgbWVhc3VyZTogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUubWVhc3VyZVxuICB9KTtcbiAgY29uc3QgYWN0aXZlTm9kZVJlY3QgPSB1c2VSZWN0KGFjdGl2ZU5vZGUsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUsIGluaXRpYWxBY3RpdmVOb2RlUmVjdCk7XG4gIGNvbnN0IGNvbnRhaW5lck5vZGVSZWN0ID0gdXNlUmVjdChhY3RpdmVOb2RlID8gYWN0aXZlTm9kZS5wYXJlbnRFbGVtZW50IDogbnVsbCk7XG4gIGNvbnN0IHNlbnNvckNvbnRleHQgPSB1c2VSZWYoe1xuICAgIGFjdGl2YXRvckV2ZW50OiBudWxsLFxuICAgIGFjdGl2ZTogbnVsbCxcbiAgICBhY3RpdmVOb2RlLFxuICAgIGNvbGxpc2lvblJlY3Q6IG51bGwsXG4gICAgY29sbGlzaW9uczogbnVsbCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBkcmFnZ2luZ05vZGU6IG51bGwsXG4gICAgZHJhZ2dpbmdOb2RlUmVjdDogbnVsbCxcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIG92ZXI6IG51bGwsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yczogW10sXG4gICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGU6IG51bGxcbiAgfSk7XG4gIGNvbnN0IG92ZXJOb2RlID0gZHJvcHBhYmxlQ29udGFpbmVycy5nZXROb2RlRm9yKChfc2Vuc29yQ29udGV4dCRjdXJyZW4gPSBzZW5zb3JDb250ZXh0LmN1cnJlbnQub3ZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZW5zb3JDb250ZXh0JGN1cnJlbi5pZCk7XG4gIGNvbnN0IGRyYWdPdmVybGF5ID0gdXNlRHJhZ092ZXJsYXlNZWFzdXJpbmcoe1xuICAgIG1lYXN1cmU6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ092ZXJsYXkubWVhc3VyZVxuICB9KTsgLy8gVXNlIHRoZSByZWN0IG9mIHRoZSBkcmFnIG92ZXJsYXkgaWYgaXQgaXMgbW91bnRlZFxuXG4gIGNvbnN0IGRyYWdnaW5nTm9kZSA9IChfZHJhZ092ZXJsYXkkbm9kZVJlZiQgPSBkcmFnT3ZlcmxheS5ub2RlUmVmLmN1cnJlbnQpICE9IG51bGwgPyBfZHJhZ092ZXJsYXkkbm9kZVJlZiQgOiBhY3RpdmVOb2RlO1xuICBjb25zdCBkcmFnZ2luZ05vZGVSZWN0ID0gaXNJbml0aWFsaXplZCA/IChfZHJhZ092ZXJsYXkkcmVjdCA9IGRyYWdPdmVybGF5LnJlY3QpICE9IG51bGwgPyBfZHJhZ092ZXJsYXkkcmVjdCA6IGFjdGl2ZU5vZGVSZWN0IDogbnVsbDtcbiAgY29uc3QgdXNlc0RyYWdPdmVybGF5ID0gQm9vbGVhbihkcmFnT3ZlcmxheS5ub2RlUmVmLmN1cnJlbnQgJiYgZHJhZ092ZXJsYXkucmVjdCk7IC8vIFRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBwcmV2aW91cyBhbmQgbmV3IHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2FibGUgbm9kZVxuICAvLyBpcyBvbmx5IHJlbGV2YW50IHdoZW4gdGhlcmUgaXMgbm8gZHJhZyBvdmVybGF5XG5cbiAgY29uc3Qgbm9kZVJlY3REZWx0YSA9IHVzZVJlY3REZWx0YSh1c2VzRHJhZ092ZXJsYXkgPyBudWxsIDogYWN0aXZlTm9kZVJlY3QpOyAvLyBHZXQgdGhlIHdpbmRvdyByZWN0IG9mIHRoZSBkcmFnZ2luZyBub2RlXG5cbiAgY29uc3Qgd2luZG93UmVjdCA9IHVzZVdpbmRvd1JlY3QoZHJhZ2dpbmdOb2RlID8gZ2V0V2luZG93KGRyYWdnaW5nTm9kZSkgOiBudWxsKTsgLy8gR2V0IHNjcm9sbGFibGUgYW5jZXN0b3JzIG9mIHRoZSBkcmFnZ2luZyBub2RlXG5cbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9ycyA9IHVzZVNjcm9sbGFibGVBbmNlc3RvcnMoaXNJbml0aWFsaXplZCA/IG92ZXJOb2RlICE9IG51bGwgPyBvdmVyTm9kZSA6IGFjdGl2ZU5vZGUgOiBudWxsKTtcbiAgY29uc3Qgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMgPSB1c2VSZWN0cyhzY3JvbGxhYmxlQW5jZXN0b3JzKTsgLy8gQXBwbHkgbW9kaWZpZXJzXG5cbiAgY29uc3QgbW9kaWZpZWRUcmFuc2xhdGUgPSBhcHBseU1vZGlmaWVycyhtb2RpZmllcnMsIHtcbiAgICB0cmFuc2Zvcm06IHtcbiAgICAgIHg6IHRyYW5zbGF0ZS54IC0gbm9kZVJlY3REZWx0YS54LFxuICAgICAgeTogdHJhbnNsYXRlLnkgLSBub2RlUmVjdERlbHRhLnksXG4gICAgICBzY2FsZVg6IDEsXG4gICAgICBzY2FsZVk6IDFcbiAgICB9LFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBjb250YWluZXJOb2RlUmVjdCxcbiAgICBkcmFnZ2luZ05vZGVSZWN0LFxuICAgIG92ZXI6IHNlbnNvckNvbnRleHQuY3VycmVudC5vdmVyLFxuICAgIG92ZXJsYXlOb2RlUmVjdDogZHJhZ092ZXJsYXkucmVjdCxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgIHdpbmRvd1JlY3RcbiAgfSk7XG4gIGNvbnN0IHBvaW50ZXJDb29yZGluYXRlcyA9IGFjdGl2YXRpb25Db29yZGluYXRlcyA/IGFkZChhY3RpdmF0aW9uQ29vcmRpbmF0ZXMsIHRyYW5zbGF0ZSkgOiBudWxsO1xuICBjb25zdCBzY3JvbGxPZmZzZXRzID0gdXNlU2Nyb2xsT2Zmc2V0cyhzY3JvbGxhYmxlQW5jZXN0b3JzKTsgLy8gUmVwcmVzZW50cyB0aGUgc2Nyb2xsIGRlbHRhIHNpbmNlIGRyYWdnaW5nIHdhcyBpbml0aWF0ZWRcblxuICBjb25zdCBzY3JvbGxBZGp1c3RtZW50ID0gdXNlU2Nyb2xsT2Zmc2V0c0RlbHRhKHNjcm9sbE9mZnNldHMpOyAvLyBSZXByZXNlbnRzIHRoZSBzY3JvbGwgZGVsdGEgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgYWN0aXZlIG5vZGUgcmVjdCB3YXMgbWVhc3VyZWRcblxuICBjb25zdCBhY3RpdmVOb2RlU2Nyb2xsRGVsdGEgPSB1c2VTY3JvbGxPZmZzZXRzRGVsdGEoc2Nyb2xsT2Zmc2V0cywgW2FjdGl2ZU5vZGVSZWN0XSk7XG4gIGNvbnN0IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlID0gYWRkKG1vZGlmaWVkVHJhbnNsYXRlLCBzY3JvbGxBZGp1c3RtZW50KTtcbiAgY29uc3QgY29sbGlzaW9uUmVjdCA9IGRyYWdnaW5nTm9kZVJlY3QgPyBnZXRBZGp1c3RlZFJlY3QoZHJhZ2dpbmdOb2RlUmVjdCwgbW9kaWZpZWRUcmFuc2xhdGUpIDogbnVsbDtcbiAgY29uc3QgY29sbGlzaW9ucyA9IGFjdGl2ZSAmJiBjb2xsaXNpb25SZWN0ID8gY29sbGlzaW9uRGV0ZWN0aW9uKHtcbiAgICBhY3RpdmUsXG4gICAgY29sbGlzaW9uUmVjdCxcbiAgICBkcm9wcGFibGVSZWN0cyxcbiAgICBkcm9wcGFibGVDb250YWluZXJzOiBlbmFibGVkRHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBwb2ludGVyQ29vcmRpbmF0ZXNcbiAgfSkgOiBudWxsO1xuICBjb25zdCBvdmVySWQgPSBnZXRGaXJzdENvbGxpc2lvbihjb2xsaXNpb25zLCAnaWQnKTtcbiAgY29uc3QgW292ZXIsIHNldE92ZXJdID0gdXNlU3RhdGUobnVsbCk7IC8vIFdoZW4gdGhlcmUgaXMgbm8gZHJhZyBvdmVybGF5IHVzZWQsIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlXG4gIC8vIHdpbmRvdyBzY3JvbGwgZGVsdGFcblxuICBjb25zdCBhcHBsaWVkVHJhbnNsYXRlID0gdXNlc0RyYWdPdmVybGF5ID8gbW9kaWZpZWRUcmFuc2xhdGUgOiBhZGQobW9kaWZpZWRUcmFuc2xhdGUsIGFjdGl2ZU5vZGVTY3JvbGxEZWx0YSk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IGFkanVzdFNjYWxlKGFwcGxpZWRUcmFuc2xhdGUsIChfb3ZlciRyZWN0ID0gb3ZlciA9PSBudWxsID8gdm9pZCAwIDogb3Zlci5yZWN0KSAhPSBudWxsID8gX292ZXIkcmVjdCA6IG51bGwsIGFjdGl2ZU5vZGVSZWN0KTtcbiAgY29uc3QgaW5zdGFudGlhdGVTZW5zb3IgPSB1c2VDYWxsYmFjaygoZXZlbnQsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNlbnNvcjogU2Vuc29yLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmIChhY3RpdmVSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChhY3RpdmVSZWYuY3VycmVudCk7XG5cbiAgICBpZiAoIWFjdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0b3JFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIGNvbnN0IHNlbnNvckluc3RhbmNlID0gbmV3IFNlbnNvcih7XG4gICAgICBhY3RpdmU6IGFjdGl2ZVJlZi5jdXJyZW50LFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGV2ZW50OiBhY3RpdmF0b3JFdmVudCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICAvLyBTZW5zb3JzIG5lZWQgdG8gYmUgaW5zdGFudGlhdGVkIHdpdGggcmVmcyBmb3IgYXJndW1lbnRzIHRoYXQgY2hhbmdlIG92ZXIgdGltZVxuICAgICAgLy8gb3RoZXJ3aXNlIHRoZXkgYXJlIGZyb3plbiBpbiB0aW1lIHdpdGggdGhlIHN0YWxlIGFyZ3VtZW50c1xuICAgICAgY29udGV4dDogc2Vuc29yQ29udGV4dCxcblxuICAgICAgb25TdGFydChpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhY3RpdmVSZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRyYWdnYWJsZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlTm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvbkRyYWdTdGFydFxuICAgICAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRhdGE6IGRyYWdnYWJsZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHJlY3Q6IGFjdGl2ZVJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgb25EcmFnU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICBzZXRTdGF0dXMoU3RhdHVzLkluaXRpYWxpemluZyk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogQWN0aW9uLkRyYWdTdGFydCxcbiAgICAgICAgICAgIGluaXRpYWxDb29yZGluYXRlcyxcbiAgICAgICAgICAgIGFjdGl2ZTogaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnb25EcmFnU3RhcnQnLFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvbk1vdmUoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IEFjdGlvbi5EcmFnTW92ZSxcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIG9uRW5kOiBjcmVhdGVIYW5kbGVyKEFjdGlvbi5EcmFnRW5kKSxcbiAgICAgIG9uQ2FuY2VsOiBjcmVhdGVIYW5kbGVyKEFjdGlvbi5EcmFnQ2FuY2VsKVxuICAgIH0pO1xuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIHNldEFjdGl2ZVNlbnNvcihzZW5zb3JJbnN0YW5jZSk7XG4gICAgICBzZXRBY3RpdmF0b3JFdmVudChldmVudC5uYXRpdmVFdmVudCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKHR5cGUpIHtcbiAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgb3ZlcixcbiAgICAgICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgICAgICB9ID0gc2Vuc29yQ29udGV4dC5jdXJyZW50O1xuICAgICAgICBsZXQgZXZlbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChhY3RpdmUgJiYgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYW5jZWxEcm9wXG4gICAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlLFxuICAgICAgICAgICAgY29sbGlzaW9ucyxcbiAgICAgICAgICAgIGRlbHRhOiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG92ZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IEFjdGlvbi5EcmFnRW5kICYmIHR5cGVvZiBjYW5jZWxEcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRDYW5jZWwgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2FuY2VsRHJvcChldmVudCkpO1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2FuY2VsKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBBY3Rpb24uRHJhZ0NhbmNlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0U3RhdHVzKFN0YXR1cy5VbmluaXRpYWxpemVkKTtcbiAgICAgICAgICBzZXRPdmVyKG51bGwpO1xuICAgICAgICAgIHNldEFjdGl2ZVNlbnNvcihudWxsKTtcbiAgICAgICAgICBzZXRBY3RpdmF0b3JFdmVudChudWxsKTtcbiAgICAgICAgICBjb25zdCBldmVudE5hbWUgPSB0eXBlID09PSBBY3Rpb24uRHJhZ0VuZCA/ICdvbkRyYWdFbmQnIDogJ29uRHJhZ0NhbmNlbCc7XG5cbiAgICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBsYXRlc3RQcm9wcy5jdXJyZW50W2V2ZW50TmFtZV07XG4gICAgICAgICAgICBoYW5kbGVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGRpc3BhdGNoTW9uaXRvckV2ZW50KHtcbiAgICAgICAgICAgICAgdHlwZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkcmFnZ2FibGVOb2Rlc10pO1xuICBjb25zdCBiaW5kQWN0aXZhdG9yVG9TZW5zb3JJbnN0YW50aWF0b3IgPSB1c2VDYWxsYmFjaygoaGFuZGxlciwgc2Vuc29yKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCwgYWN0aXZlKSA9PiB7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgY29uc3QgYWN0aXZlRHJhZ2dhYmxlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChhY3RpdmUpO1xuXG4gICAgICBpZiAoIC8vIEFub3RoZXIgc2Vuc29yIGlzIGFscmVhZHkgaW5zdGFudGlhdGluZ1xuICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgIT09IG51bGwgfHwgLy8gTm8gYWN0aXZlIGRyYWdnYWJsZVxuICAgICAgIWFjdGl2ZURyYWdnYWJsZU5vZGUgfHwgLy8gRXZlbnQgaGFzIGFscmVhZHkgYmVlbiBjYXB0dXJlZFxuICAgICAgbmF0aXZlRXZlbnQuZG5kS2l0IHx8IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3RpdmF0aW9uQ29udGV4dCA9IHtcbiAgICAgICAgYWN0aXZlOiBhY3RpdmVEcmFnZ2FibGVOb2RlXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2hvdWxkQWN0aXZhdGUgPSBoYW5kbGVyKGV2ZW50LCBzZW5zb3Iub3B0aW9ucywgYWN0aXZhdGlvbkNvbnRleHQpO1xuXG4gICAgICBpZiAoc2hvdWxkQWN0aXZhdGUgPT09IHRydWUpIHtcbiAgICAgICAgbmF0aXZlRXZlbnQuZG5kS2l0ID0ge1xuICAgICAgICAgIGNhcHR1cmVkQnk6IHNlbnNvci5zZW5zb3JcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQgPSBhY3RpdmU7XG4gICAgICAgIGluc3RhbnRpYXRlU2Vuc29yKGV2ZW50LCBzZW5zb3IpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkcmFnZ2FibGVOb2RlcywgaW5zdGFudGlhdGVTZW5zb3JdKTtcbiAgY29uc3QgYWN0aXZhdG9ycyA9IHVzZUNvbWJpbmVBY3RpdmF0b3JzKHNlbnNvcnMsIGJpbmRBY3RpdmF0b3JUb1NlbnNvckluc3RhbnRpYXRvcik7XG4gIHVzZVNlbnNvclNldHVwKHNlbnNvcnMpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlTm9kZVJlY3QgJiYgc3RhdHVzID09PSBTdGF0dXMuSW5pdGlhbGl6aW5nKSB7XG4gICAgICBzZXRTdGF0dXMoU3RhdHVzLkluaXRpYWxpemVkKTtcbiAgICB9XG4gIH0sIFthY3RpdmVOb2RlUmVjdCwgc3RhdHVzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25EcmFnTW92ZVxuICAgIH0gPSBsYXRlc3RQcm9wcy5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIG92ZXJcbiAgICB9ID0gc2Vuc29yQ29udGV4dC5jdXJyZW50O1xuXG4gICAgaWYgKCFhY3RpdmUgfHwgIWFjdGl2YXRvckV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkZWx0YToge1xuICAgICAgICB4OiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS54LFxuICAgICAgICB5OiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS55XG4gICAgICB9LFxuICAgICAgb3ZlclxuICAgIH07XG4gICAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgb25EcmFnTW92ZSA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnTW92ZShldmVudCk7XG4gICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgIHR5cGU6ICdvbkRyYWdNb3ZlJyxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS54LCBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZS55XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlXG4gICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcblxuICAgIGlmICghYWN0aXZlIHx8IGFjdGl2ZVJlZi5jdXJyZW50ID09IG51bGwgfHwgIWFjdGl2YXRvckV2ZW50IHx8ICFzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIG9uRHJhZ092ZXJcbiAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICBjb25zdCBvdmVyQ29udGFpbmVyID0gZHJvcHBhYmxlQ29udGFpbmVycy5nZXQob3ZlcklkKTtcbiAgICBjb25zdCBvdmVyID0gb3ZlckNvbnRhaW5lciAmJiBvdmVyQ29udGFpbmVyLnJlY3QuY3VycmVudCA/IHtcbiAgICAgIGlkOiBvdmVyQ29udGFpbmVyLmlkLFxuICAgICAgcmVjdDogb3ZlckNvbnRhaW5lci5yZWN0LmN1cnJlbnQsXG4gICAgICBkYXRhOiBvdmVyQ29udGFpbmVyLmRhdGEsXG4gICAgICBkaXNhYmxlZDogb3ZlckNvbnRhaW5lci5kaXNhYmxlZFxuICAgIH0gOiBudWxsO1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZGVsdGE6IHtcbiAgICAgICAgeDogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCxcbiAgICAgICAgeTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueVxuICAgICAgfSxcbiAgICAgIG92ZXJcbiAgICB9O1xuICAgIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIHNldE92ZXIob3Zlcik7XG4gICAgICBvbkRyYWdPdmVyID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdPdmVyKGV2ZW50KTtcbiAgICAgIGRpc3BhdGNoTW9uaXRvckV2ZW50KHtcbiAgICAgICAgdHlwZTogJ29uRHJhZ092ZXInLFxuICAgICAgICBldmVudFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW292ZXJJZF0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBzZW5zb3JDb250ZXh0LmN1cnJlbnQgPSB7XG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2ZU5vZGUsXG4gICAgICBjb2xsaXNpb25SZWN0LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgICBkcmFnZ2luZ05vZGUsXG4gICAgICBkcmFnZ2luZ05vZGVSZWN0LFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIG92ZXIsXG4gICAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgICAgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVcbiAgICB9O1xuICAgIGFjdGl2ZVJlY3RzLmN1cnJlbnQgPSB7XG4gICAgICBpbml0aWFsOiBkcmFnZ2luZ05vZGVSZWN0LFxuICAgICAgdHJhbnNsYXRlZDogY29sbGlzaW9uUmVjdFxuICAgIH07XG4gIH0sIFthY3RpdmUsIGFjdGl2ZU5vZGUsIGNvbGxpc2lvbnMsIGNvbGxpc2lvblJlY3QsIGRyYWdnYWJsZU5vZGVzLCBkcmFnZ2luZ05vZGUsIGRyYWdnaW5nTm9kZVJlY3QsIGRyb3BwYWJsZVJlY3RzLCBkcm9wcGFibGVDb250YWluZXJzLCBvdmVyLCBzY3JvbGxhYmxlQW5jZXN0b3JzLCBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZV0pO1xuICB1c2VBdXRvU2Nyb2xsZXIoeyAuLi5hdXRvU2Nyb2xsT3B0aW9ucyxcbiAgICBkZWx0YTogdHJhbnNsYXRlLFxuICAgIGRyYWdnaW5nUmVjdDogY29sbGlzaW9uUmVjdCxcbiAgICBwb2ludGVyQ29vcmRpbmF0ZXMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0c1xuICB9KTtcbiAgY29uc3QgcHVibGljQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmVOb2RlLFxuICAgICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBjb250YWluZXJOb2RlUmVjdCxcbiAgICAgIGRyYWdPdmVybGF5LFxuICAgICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgICBvdmVyLFxuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBzY3JvbGxhYmxlQW5jZXN0b3JzLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgICAgbWVhc3VyaW5nU2NoZWR1bGVkLFxuICAgICAgd2luZG93UmVjdFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH0sIFthY3RpdmUsIGFjdGl2ZU5vZGUsIGFjdGl2ZU5vZGVSZWN0LCBhY3RpdmF0b3JFdmVudCwgY29sbGlzaW9ucywgY29udGFpbmVyTm9kZVJlY3QsIGRyYWdPdmVybGF5LCBkcmFnZ2FibGVOb2RlcywgZHJvcHBhYmxlQ29udGFpbmVycywgZHJvcHBhYmxlUmVjdHMsIG92ZXIsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLCBzY3JvbGxhYmxlQW5jZXN0b3JzLCBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cywgbWVhc3VyaW5nQ29uZmlndXJhdGlvbiwgbWVhc3VyaW5nU2NoZWR1bGVkLCB3aW5kb3dSZWN0XSk7XG4gIGNvbnN0IGludGVybmFsQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGFjdGl2YXRvcnMsXG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICAgIGFyaWFEZXNjcmliZWRCeUlkOiB7XG4gICAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZFxuICAgICAgfSxcbiAgICAgIGRpc3BhdGNoLFxuICAgICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgICBvdmVyLFxuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnNcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LCBbYWN0aXZhdG9yRXZlbnQsIGFjdGl2YXRvcnMsIGFjdGl2ZSwgYWN0aXZlTm9kZVJlY3QsIGRpc3BhdGNoLCBkcmFnZ2FibGVEZXNjcmliZWRCeUlkLCBkcmFnZ2FibGVOb2Rlcywgb3ZlciwgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnNdKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRG5kTW9uaXRvckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVnaXN0ZXJNb25pdG9yTGlzdGVuZXJcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChJbnRlcm5hbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogaW50ZXJuYWxDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHVibGljQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBwdWJsaWNDb250ZXh0XG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cmFuc2Zvcm1cbiAgfSwgY2hpbGRyZW4pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChSZXN0b3JlRm9jdXMsIHtcbiAgICBkaXNhYmxlZDogKGFjY2Vzc2liaWxpdHkgPT0gbnVsbCA/IHZvaWQgMCA6IGFjY2Vzc2liaWxpdHkucmVzdG9yZUZvY3VzKSA9PT0gZmFsc2VcbiAgfSkpLCBSZWFjdC5jcmVhdGVFbGVtZW50KEFjY2Vzc2liaWxpdHksIHsgLi4uYWNjZXNzaWJpbGl0eSxcbiAgICBoaWRkZW5UZXh0RGVzY3JpYmVkQnlJZDogZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZFxuICB9KSk7XG5cbiAgZnVuY3Rpb24gZ2V0QXV0b1Njcm9sbGVyT3B0aW9ucygpIHtcbiAgICBjb25zdCBhY3RpdmVTZW5zb3JEaXNhYmxlc0F1dG9zY3JvbGwgPSAoYWN0aXZlU2Vuc29yID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmVTZW5zb3IuYXV0b1Njcm9sbEVuYWJsZWQpID09PSBmYWxzZTtcbiAgICBjb25zdCBhdXRvU2Nyb2xsR2xvYmFsbHlEaXNhYmxlZCA9IHR5cGVvZiBhdXRvU2Nyb2xsID09PSAnb2JqZWN0JyA/IGF1dG9TY3JvbGwuZW5hYmxlZCA9PT0gZmFsc2UgOiBhdXRvU2Nyb2xsID09PSBmYWxzZTtcbiAgICBjb25zdCBlbmFibGVkID0gaXNJbml0aWFsaXplZCAmJiAhYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsICYmICFhdXRvU2Nyb2xsR2xvYmFsbHlEaXNhYmxlZDtcblxuICAgIGlmICh0eXBlb2YgYXV0b1Njcm9sbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB7IC4uLmF1dG9TY3JvbGwsXG4gICAgICAgIGVuYWJsZWRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVuYWJsZWRcbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgTnVsbENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGRlZmF1bHRSb2xlID0gJ2J1dHRvbic7XG5jb25zdCBJRF9QUkVGSVggPSAnRHJvcHBhYmxlJztcbmZ1bmN0aW9uIHVzZURyYWdnYWJsZShfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgZGF0YSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGF0dHJpYnV0ZXNcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGtleSA9IHVzZVVuaXF1ZUlkKElEX1BSRUZJWCk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmF0b3JzLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhcmlhRGVzY3JpYmVkQnlJZCxcbiAgICBkcmFnZ2FibGVOb2RlcyxcbiAgICBvdmVyXG4gIH0gPSB1c2VDb250ZXh0KEludGVybmFsQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICByb2xlID0gZGVmYXVsdFJvbGUsXG4gICAgcm9sZURlc2NyaXB0aW9uID0gJ2RyYWdnYWJsZScsXG4gICAgdGFiSW5kZXggPSAwXG4gIH0gPSBhdHRyaWJ1dGVzICE9IG51bGwgPyBhdHRyaWJ1dGVzIDoge307XG4gIGNvbnN0IGlzRHJhZ2dpbmcgPSAoYWN0aXZlID09IG51bGwgPyB2b2lkIDAgOiBhY3RpdmUuaWQpID09PSBpZDtcbiAgY29uc3QgdHJhbnNmb3JtID0gdXNlQ29udGV4dChpc0RyYWdnaW5nID8gQWN0aXZlRHJhZ2dhYmxlQ29udGV4dCA6IE51bGxDb250ZXh0KTtcbiAgY29uc3QgW25vZGUsIHNldE5vZGVSZWZdID0gdXNlTm9kZVJlZigpO1xuICBjb25zdCBbYWN0aXZhdG9yTm9kZSwgc2V0QWN0aXZhdG9yTm9kZVJlZl0gPSB1c2VOb2RlUmVmKCk7XG4gIGNvbnN0IGxpc3RlbmVycyA9IHVzZVN5bnRoZXRpY0xpc3RlbmVycyhhY3RpdmF0b3JzLCBpZCk7XG4gIGNvbnN0IGRhdGFSZWYgPSB1c2VMYXRlc3RWYWx1ZShkYXRhKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZHJhZ2dhYmxlTm9kZXMuc2V0KGlkLCB7XG4gICAgICBpZCxcbiAgICAgIGtleSxcbiAgICAgIG5vZGUsXG4gICAgICBhY3RpdmF0b3JOb2RlLFxuICAgICAgZGF0YTogZGF0YVJlZlxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5rZXkgPT09IGtleSkge1xuICAgICAgICBkcmFnZ2FibGVOb2Rlcy5kZWxldGUoaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2RyYWdnYWJsZU5vZGVzLCBpZF0pO1xuICBjb25zdCBtZW1vaXplZEF0dHJpYnV0ZXMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcm9sZSxcbiAgICB0YWJJbmRleCxcbiAgICAnYXJpYS1kaXNhYmxlZCc6IGRpc2FibGVkLFxuICAgICdhcmlhLXByZXNzZWQnOiBpc0RyYWdnaW5nICYmIHJvbGUgPT09IGRlZmF1bHRSb2xlID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiByb2xlRGVzY3JpcHRpb24sXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBhcmlhRGVzY3JpYmVkQnlJZC5kcmFnZ2FibGVcbiAgfSksIFtkaXNhYmxlZCwgcm9sZSwgdGFiSW5kZXgsIGlzRHJhZ2dpbmcsIHJvbGVEZXNjcmlwdGlvbiwgYXJpYURlc2NyaWJlZEJ5SWQuZHJhZ2dhYmxlXSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGF0dHJpYnV0ZXM6IG1lbW9pemVkQXR0cmlidXRlcyxcbiAgICBpc0RyYWdnaW5nLFxuICAgIGxpc3RlbmVyczogZGlzYWJsZWQgPyB1bmRlZmluZWQgOiBsaXN0ZW5lcnMsXG4gICAgbm9kZSxcbiAgICBvdmVyLFxuICAgIHNldE5vZGVSZWYsXG4gICAgc2V0QWN0aXZhdG9yTm9kZVJlZixcbiAgICB0cmFuc2Zvcm1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlRG5kQ29udGV4dCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUHVibGljQ29udGV4dCk7XG59XG5cbmNvbnN0IElEX1BSRUZJWCQxID0gJ0Ryb3BwYWJsZSc7XG5jb25zdCBkZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWcgPSB7XG4gIHRpbWVvdXQ6IDI1XG59O1xuZnVuY3Rpb24gdXNlRHJvcHBhYmxlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkYXRhLFxuICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgaWQsXG4gICAgcmVzaXplT2JzZXJ2ZXJDb25maWdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGtleSA9IHVzZVVuaXF1ZUlkKElEX1BSRUZJWCQxKTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZSxcbiAgICBkaXNwYXRjaCxcbiAgICBvdmVyLFxuICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gIH0gPSB1c2VDb250ZXh0KEludGVybmFsQ29udGV4dCk7XG4gIGNvbnN0IHByZXZpb3VzID0gdXNlUmVmKHtcbiAgICBkaXNhYmxlZFxuICB9KTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCByZWN0ID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBjYWxsYmFja0lkID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgZGlzYWJsZWQ6IHJlc2l6ZU9ic2VydmVyRGlzYWJsZWQsXG4gICAgdXBkYXRlTWVhc3VyZW1lbnRzRm9yLFxuICAgIHRpbWVvdXQ6IHJlc2l6ZU9ic2VydmVyVGltZW91dFxuICB9ID0geyAuLi5kZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWcsXG4gICAgLi4ucmVzaXplT2JzZXJ2ZXJDb25maWdcbiAgfTtcbiAgY29uc3QgaWRzID0gdXNlTGF0ZXN0VmFsdWUodXBkYXRlTWVhc3VyZW1lbnRzRm9yICE9IG51bGwgPyB1cGRhdGVNZWFzdXJlbWVudHNGb3IgOiBpZCk7XG4gIGNvbnN0IGhhbmRsZVJlc2l6ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQpIHtcbiAgICAgIC8vIFJlc2l6ZU9ic2VydmVyIGludm9rZXMgdGhlIGBoYW5kbGVSZXNpemVgIGNhbGxiYWNrIGFzIHNvb24gYXMgYG9ic2VydmVgIGlzIGNhbGxlZCxcbiAgICAgIC8vIGFzc3VtaW5nIHRoZSBlbGVtZW50IGlzIHJlbmRlcmVkIGFuZCBkaXNwbGF5ZWQuXG4gICAgICByZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tJZC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChjYWxsYmFja0lkLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIGNhbGxiYWNrSWQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoQXJyYXkuaXNBcnJheShpZHMuY3VycmVudCkgPyBpZHMuY3VycmVudCA6IFtpZHMuY3VycmVudF0pO1xuICAgICAgY2FsbGJhY2tJZC5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCByZXNpemVPYnNlcnZlclRpbWVvdXQpO1xuICB9LCAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW3Jlc2l6ZU9ic2VydmVyVGltZW91dF0pO1xuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogaGFuZGxlUmVzaXplLFxuICAgIGRpc2FibGVkOiByZXNpemVPYnNlcnZlckRpc2FibGVkIHx8ICFhY3RpdmVcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZU5vZGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygobmV3RWxlbWVudCwgcHJldmlvdXNFbGVtZW50KSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c0VsZW1lbnQpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShwcmV2aW91c0VsZW1lbnQpO1xuICAgICAgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfSwgW3Jlc2l6ZU9ic2VydmVyXSk7XG4gIGNvbnN0IFtub2RlUmVmLCBzZXROb2RlUmVmXSA9IHVzZU5vZGVSZWYoaGFuZGxlTm9kZUNoYW5nZSk7XG4gIGNvbnN0IGRhdGFSZWYgPSB1c2VMYXRlc3RWYWx1ZShkYXRhKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJlc2l6ZU9ic2VydmVyIHx8ICFub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUobm9kZVJlZi5jdXJyZW50KTtcbiAgfSwgW25vZGVSZWYsIHJlc2l6ZU9ic2VydmVyXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IEFjdGlvbi5SZWdpc3RlckRyb3BwYWJsZSxcbiAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGtleSxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5vZGU6IG5vZGVSZWYsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIGRhdGE6IGRhdGFSZWZcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uLlVucmVnaXN0ZXJEcm9wcGFibGUsXG4gICAgICBrZXksXG4gICAgICBpZFxuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtpZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCAhPT0gcHJldmlvdXMuY3VycmVudC5kaXNhYmxlZCkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBBY3Rpb24uU2V0RHJvcHBhYmxlRGlzYWJsZWQsXG4gICAgICAgIGlkLFxuICAgICAgICBrZXksXG4gICAgICAgIGRpc2FibGVkXG4gICAgICB9KTtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH0sIFtpZCwga2V5LCBkaXNhYmxlZCwgZGlzcGF0Y2hdKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgcmVjdCxcbiAgICBpc092ZXI6IChvdmVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVyLmlkKSA9PT0gaWQsXG4gICAgbm9kZTogbm9kZVJlZixcbiAgICBvdmVyLFxuICAgIHNldE5vZGVSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uTWFuYWdlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbY2xvbmVkQ2hpbGRyZW4sIHNldENsb25lZENoaWxkcmVuXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbZWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcHJldmlvdXNDaGlsZHJlbiA9IHVzZVByZXZpb3VzKGNoaWxkcmVuKTtcblxuICBpZiAoIWNoaWxkcmVuICYmICFjbG9uZWRDaGlsZHJlbiAmJiBwcmV2aW91c0NoaWxkcmVuKSB7XG4gICAgc2V0Q2xvbmVkQ2hpbGRyZW4ocHJldmlvdXNDaGlsZHJlbik7XG4gIH1cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBjbG9uZWRDaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2xvbmVkQ2hpbGRyZW4ua2V5O1xuICAgIGNvbnN0IGlkID0gY2xvbmVkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNsb25lZENoaWxkcmVuLnByb3BzLmlkO1xuXG4gICAgaWYgKGtleSA9PSBudWxsIHx8IGlkID09IG51bGwpIHtcbiAgICAgIHNldENsb25lZENoaWxkcmVuKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZShhbmltYXRpb24oaWQsIGVsZW1lbnQpKS50aGVuKCgpID0+IHtcbiAgICAgIHNldENsb25lZENoaWxkcmVuKG51bGwpO1xuICAgIH0pO1xuICB9LCBbYW5pbWF0aW9uLCBjbG9uZWRDaGlsZHJlbiwgZWxlbWVudF0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIGNsb25lZENoaWxkcmVuID8gY2xvbmVFbGVtZW50KGNsb25lZENoaWxkcmVuLCB7XG4gICAgcmVmOiBzZXRFbGVtZW50XG4gIH0pIDogbnVsbCk7XG59XG5cbmNvbnN0IGRlZmF1bHRUcmFuc2Zvcm0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuZnVuY3Rpb24gTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRJbnRlcm5hbENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY3RpdmVEcmFnZ2FibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRUcmFuc2Zvcm1cbiAgfSwgY2hpbGRyZW4pKTtcbn1cblxuY29uc3QgYmFzZVN0eWxlcyA9IHtcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZSdcbn07XG5cbmNvbnN0IGRlZmF1bHRUcmFuc2l0aW9uID0gYWN0aXZhdG9yRXZlbnQgPT4ge1xuICBjb25zdCBpc0tleWJvYXJkQWN0aXZhdG9yID0gaXNLZXlib2FyZEV2ZW50KGFjdGl2YXRvckV2ZW50KTtcbiAgcmV0dXJuIGlzS2V5Ym9hcmRBY3RpdmF0b3IgPyAndHJhbnNmb3JtIDI1MG1zIGVhc2UnIDogdW5kZWZpbmVkO1xufTtcblxuY29uc3QgUG9zaXRpb25lZE92ZXJsYXkgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZigoX3JlZiwgcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgYXMsXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWRqdXN0U2NhbGUsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lLFxuICAgIHJlY3QsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNmb3JtLFxuICAgIHRyYW5zaXRpb24gPSBkZWZhdWx0VHJhbnNpdGlvblxuICB9ID0gX3JlZjtcblxuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHNjYWxlQWRqdXN0ZWRUcmFuc2Zvcm0gPSBhZGp1c3RTY2FsZSA/IHRyYW5zZm9ybSA6IHsgLi4udHJhbnNmb3JtLFxuICAgIHNjYWxlWDogMSxcbiAgICBzY2FsZVk6IDFcbiAgfTtcbiAgY29uc3Qgc3R5bGVzID0geyAuLi5iYXNlU3R5bGVzLFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdHJhbnNmb3JtOiBDU1MuVHJhbnNmb3JtLnRvU3RyaW5nKHNjYWxlQWRqdXN0ZWRUcmFuc2Zvcm0pLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogYWRqdXN0U2NhbGUgJiYgYWN0aXZhdG9yRXZlbnQgPyBnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbihhY3RpdmF0b3JFdmVudCwgcmVjdCkgOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbjogdHlwZW9mIHRyYW5zaXRpb24gPT09ICdmdW5jdGlvbicgPyB0cmFuc2l0aW9uKGFjdGl2YXRvckV2ZW50KSA6IHRyYW5zaXRpb24sXG4gICAgLi4uc3R5bGVcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYXMsIHtcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlcyxcbiAgICByZWZcbiAgfSwgY2hpbGRyZW4pO1xufSk7XG5cbmNvbnN0IGRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMgPSBvcHRpb25zID0+IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFjdGl2ZSxcbiAgICBkcmFnT3ZlcmxheVxuICB9ID0gX3JlZjtcbiAgY29uc3Qgb3JpZ2luYWxTdHlsZXMgPSB7fTtcbiAgY29uc3Qge1xuICAgIHN0eWxlcyxcbiAgICBjbGFzc05hbWVcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKHN0eWxlcyAhPSBudWxsICYmIHN0eWxlcy5hY3RpdmUpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMuYWN0aXZlKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsU3R5bGVzW2tleV0gPSBhY3RpdmUubm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSk7XG4gICAgICBhY3RpdmUubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzICE9IG51bGwgJiYgc3R5bGVzLmRyYWdPdmVybGF5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzLmRyYWdPdmVybGF5KSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRyYWdPdmVybGF5Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5hY3RpdmUpIHtcbiAgICBhY3RpdmUubm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5hY3RpdmUpO1xuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5kcmFnT3ZlcmxheSkge1xuICAgIGRyYWdPdmVybGF5Lm5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuZHJhZ092ZXJsYXkpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3JpZ2luYWxTdHlsZXMpKSB7XG4gICAgICBhY3RpdmUubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoY2xhc3NOYW1lICE9IG51bGwgJiYgY2xhc3NOYW1lLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlLm5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuYWN0aXZlKTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlciA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICB0cmFuc2Zvcm06IHtcbiAgICAgIGluaXRpYWwsXG4gICAgICBmaW5hbFxuICAgIH1cbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gW3tcbiAgICB0cmFuc2Zvcm06IENTUy5UcmFuc2Zvcm0udG9TdHJpbmcoaW5pdGlhbClcbiAgfSwge1xuICAgIHRyYW5zZm9ybTogQ1NTLlRyYW5zZm9ybS50b1N0cmluZyhmaW5hbClcbiAgfV07XG59O1xuXG5jb25zdCBkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2luZzogJ2Vhc2UnLFxuICBrZXlmcmFtZXM6IGRlZmF1bHRLZXlmcmFtZVJlc29sdmVyLFxuICBzaWRlRWZmZWN0czogLyojX19QVVJFX18qL2RlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMoe1xuICAgIHN0eWxlczoge1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcbn07XG5mdW5jdGlvbiB1c2VEcm9wQW5pbWF0aW9uKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY29uZmlnLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvblxuICB9ID0gX3JlZjM7XG4gIHJldHVybiB1c2VFdmVudCgoaWQsIG5vZGUpID0+IHtcbiAgICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlRHJhZ2dhYmxlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgIGlmICghYWN0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlTm9kZSA9IGFjdGl2ZURyYWdnYWJsZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWFzdXJhYmxlTm9kZSA9IGdldE1lYXN1cmFibGVOb2RlKG5vZGUpO1xuXG4gICAgaWYgKCFtZWFzdXJhYmxlTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybVxuICAgIH0gPSBnZXRXaW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBwYXJzZWRUcmFuc2Zvcm0gPSBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgaWYgKCFwYXJzZWRUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb24gPSB0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nID8gY29uZmlnIDogY3JlYXRlRGVmYXVsdERyb3BBbmltYXRpb24oY29uZmlnKTtcbiAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGFjdGl2ZU5vZGUsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUpO1xuICAgIHJldHVybiBhbmltYXRpb24oe1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBkYXRhOiBhY3RpdmVEcmFnZ2FibGUuZGF0YSxcbiAgICAgICAgbm9kZTogYWN0aXZlTm9kZSxcbiAgICAgICAgcmVjdDogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUubWVhc3VyZShhY3RpdmVOb2RlKVxuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJhZ092ZXJsYXk6IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVjdDogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheS5tZWFzdXJlKG1lYXN1cmFibGVOb2RlKVxuICAgICAgfSxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgICAgdHJhbnNmb3JtOiBwYXJzZWRUcmFuc2Zvcm1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHREcm9wQW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uLFxuICAgIGVhc2luZyxcbiAgICBzaWRlRWZmZWN0cyxcbiAgICBrZXlmcmFtZXNcbiAgfSA9IHsgLi4uZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIF9yZWY0ID0+IHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IF9yZWY0O1xuXG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgLy8gRG8gbm90IGFuaW1hdGUgaWYgYW5pbWF0aW9uIGR1cmF0aW9uIGlzIHplcm8uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICB4OiBkcmFnT3ZlcmxheS5yZWN0LmxlZnQgLSBhY3RpdmUucmVjdC5sZWZ0LFxuICAgICAgeTogZHJhZ092ZXJsYXkucmVjdC50b3AgLSBhY3RpdmUucmVjdC50b3BcbiAgICB9O1xuICAgIGNvbnN0IHNjYWxlID0ge1xuICAgICAgc2NhbGVYOiB0cmFuc2Zvcm0uc2NhbGVYICE9PSAxID8gYWN0aXZlLnJlY3Qud2lkdGggKiB0cmFuc2Zvcm0uc2NhbGVYIC8gZHJhZ092ZXJsYXkucmVjdC53aWR0aCA6IDEsXG4gICAgICBzY2FsZVk6IHRyYW5zZm9ybS5zY2FsZVkgIT09IDEgPyBhY3RpdmUucmVjdC5oZWlnaHQgKiB0cmFuc2Zvcm0uc2NhbGVZIC8gZHJhZ092ZXJsYXkucmVjdC5oZWlnaHQgOiAxXG4gICAgfTtcbiAgICBjb25zdCBmaW5hbFRyYW5zZm9ybSA9IHtcbiAgICAgIHg6IHRyYW5zZm9ybS54IC0gZGVsdGEueCxcbiAgICAgIHk6IHRyYW5zZm9ybS55IC0gZGVsdGEueSxcbiAgICAgIC4uLnNjYWxlXG4gICAgfTtcbiAgICBjb25zdCBhbmltYXRpb25LZXlmcmFtZXMgPSBrZXlmcmFtZXMoeyAuLi5yZXN0LFxuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgaW5pdGlhbDogdHJhbnNmb3JtLFxuICAgICAgICBmaW5hbDogZmluYWxUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBbZmlyc3RLZXlmcmFtZV0gPSBhbmltYXRpb25LZXlmcmFtZXM7XG4gICAgY29uc3QgbGFzdEtleWZyYW1lID0gYW5pbWF0aW9uS2V5ZnJhbWVzW2FuaW1hdGlvbktleWZyYW1lcy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChKU09OLnN0cmluZ2lmeShmaXJzdEtleWZyYW1lKSA9PT0gSlNPTi5zdHJpbmdpZnkobGFzdEtleWZyYW1lKSkge1xuICAgICAgLy8gVGhlIHN0YXJ0IGFuZCBlbmQga2V5ZnJhbWVzIGFyZSB0aGUgc2FtZSwgaW5mZXIgdGhhdCB0aGVyZSBpcyBubyBhbmltYXRpb24gbmVlZGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNsZWFudXAgPSBzaWRlRWZmZWN0cyA9PSBudWxsID8gdm9pZCAwIDogc2lkZUVmZmVjdHMoe1xuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gZHJhZ092ZXJsYXkubm9kZS5hbmltYXRlKGFuaW1hdGlvbktleWZyYW1lcywge1xuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICBmaWxsOiAnZm9yd2FyZHMnXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgYW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5cbmxldCBrZXkgPSAwO1xuZnVuY3Rpb24gdXNlS2V5KGlkKSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGtleSsrO1xuICAgIHJldHVybiBrZXk7XG4gIH0sIFtpZF0pO1xufVxuXG5jb25zdCBEcmFnT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFkanVzdFNjYWxlID0gZmFsc2UsXG4gICAgY2hpbGRyZW4sXG4gICAgZHJvcEFuaW1hdGlvbjogZHJvcEFuaW1hdGlvbkNvbmZpZyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIG1vZGlmaWVycyxcbiAgICB3cmFwcGVyRWxlbWVudCA9ICdkaXYnLFxuICAgIGNsYXNzTmFtZSxcbiAgICB6SW5kZXggPSA5OTlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBkcmFnT3ZlcmxheSxcbiAgICBvdmVyLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB3aW5kb3dSZWN0XG4gIH0gPSB1c2VEbmRDb250ZXh0KCk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IHVzZUNvbnRleHQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGtleSA9IHVzZUtleShhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZCk7XG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNmb3JtID0gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCB7XG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnaW5nTm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgb3ZlcixcbiAgICBvdmVybGF5Tm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB0cmFuc2Zvcm0sXG4gICAgd2luZG93UmVjdFxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlY3QgPSB1c2VJbml0aWFsVmFsdWUoYWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBkcm9wQW5pbWF0aW9uID0gdXNlRHJvcEFuaW1hdGlvbih7XG4gICAgY29uZmlnOiBkcm9wQW5pbWF0aW9uQ29uZmlnLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvblxuICB9KTsgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgYWN0aXZlIG5vZGUgdG8gYmUgbWVhc3VyZWQgYmVmb3JlIGNvbm5lY3RpbmcgdGhlIGRyYWcgb3ZlcmxheSByZWZcbiAgLy8gb3RoZXJ3aXNlIGNvbGxpc2lvbnMgY2FuIGJlIGNvbXB1dGVkIGFnYWluc3QgYSBtaXNwb3NpdGlvbmVkIGRyYWcgb3ZlcmxheVxuXG4gIGNvbnN0IHJlZiA9IGluaXRpYWxSZWN0ID8gZHJhZ092ZXJsYXkuc2V0UmVmIDogdW5kZWZpbmVkO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdWxsaWZpZWRDb250ZXh0UHJvdmlkZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0aW9uTWFuYWdlciwge1xuICAgIGFuaW1hdGlvbjogZHJvcEFuaW1hdGlvblxuICB9LCBhY3RpdmUgJiYga2V5ID8gUmVhY3QuY3JlYXRlRWxlbWVudChQb3NpdGlvbmVkT3ZlcmxheSwge1xuICAgIGtleToga2V5LFxuICAgIGlkOiBhY3RpdmUuaWQsXG4gICAgcmVmOiByZWYsXG4gICAgYXM6IHdyYXBwZXJFbGVtZW50LFxuICAgIGFjdGl2YXRvckV2ZW50OiBhY3RpdmF0b3JFdmVudCxcbiAgICBhZGp1c3RTY2FsZTogYWRqdXN0U2NhbGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICByZWN0OiBpbml0aWFsUmVjdCxcbiAgICBzdHlsZToge1xuICAgICAgekluZGV4LFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogbW9kaWZpZWRUcmFuc2Zvcm1cbiAgfSwgY2hpbGRyZW4pIDogbnVsbCkpO1xufSk7XG5cbmV4cG9ydCB7IEF1dG9TY3JvbGxBY3RpdmF0b3IsIERuZENvbnRleHQsIERyYWdPdmVybGF5LCBLZXlib2FyZENvZGUsIEtleWJvYXJkU2Vuc29yLCBNZWFzdXJpbmdGcmVxdWVuY3ksIE1lYXN1cmluZ1N0cmF0ZWd5LCBNb3VzZVNlbnNvciwgUG9pbnRlclNlbnNvciwgVG91Y2hTZW5zb3IsIFRyYXZlcnNhbE9yZGVyLCBhcHBseU1vZGlmaWVycywgY2xvc2VzdENlbnRlciwgY2xvc2VzdENvcm5lcnMsIGRlZmF1bHRBbm5vdW5jZW1lbnRzLCBkZWZhdWx0Q29vcmRpbmF0ZXMsIGRlZmF1bHREcm9wQW5pbWF0aW9uQ29uZmlndXJhdGlvbiBhcyBkZWZhdWx0RHJvcEFuaW1hdGlvbiwgZGVmYXVsdERyb3BBbmltYXRpb25TaWRlRWZmZWN0cywgZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucywgZ2V0Q2xpZW50UmVjdCwgZ2V0Rmlyc3RDb2xsaXNpb24sIGdldFNjcm9sbGFibGVBbmNlc3RvcnMsIHBvaW50ZXJXaXRoaW4sIHJlY3RJbnRlcnNlY3Rpb24sIHVzZURuZENvbnRleHQsIHVzZURuZE1vbml0b3IsIHVzZURyYWdnYWJsZSwgdXNlRHJvcHBhYmxlLCB1c2VTZW5zb3IsIHVzZVNlbnNvcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVJlZHVjZXIiLCJtZW1vIiwiY2xvbmVFbGVtZW50IiwiZm9yd2FyZFJlZiIsImNyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidXNlVW5pcXVlSWQiLCJnZXRFdmVudENvb3JkaW5hdGVzIiwiZ2V0V2luZG93IiwiaXNEb2N1bWVudCIsImlzSFRNTEVsZW1lbnQiLCJpc1NWR0VsZW1lbnQiLCJjYW5Vc2VET00iLCJpc1dpbmRvdyIsImlzTm9kZSIsImdldE93bmVyRG9jdW1lbnQiLCJhZGQiLCJpc0tleWJvYXJkRXZlbnQiLCJzdWJ0cmFjdCIsInVzZUxhenlNZW1vIiwidXNlSW50ZXJ2YWwiLCJ1c2VQcmV2aW91cyIsInVzZUxhdGVzdFZhbHVlIiwidXNlRXZlbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTm9kZVJlZiIsImZpbmRGaXJzdEZvY3VzYWJsZU5vZGUiLCJDU1MiLCJ1c2VBbm5vdW5jZW1lbnQiLCJIaWRkZW5UZXh0IiwiTGl2ZVJlZ2lvbiIsIkRuZE1vbml0b3JDb250ZXh0IiwidXNlRG5kTW9uaXRvciIsImxpc3RlbmVyIiwicmVnaXN0ZXJMaXN0ZW5lciIsIkVycm9yIiwidW5zdWJzY3JpYmUiLCJ1c2VEbmRNb25pdG9yUHJvdmlkZXIiLCJsaXN0ZW5lcnMiLCJTZXQiLCJkZWxldGUiLCJkaXNwYXRjaCIsIl9yZWYiLCJ0eXBlIiwiZXZlbnQiLCJmb3JFYWNoIiwiX2xpc3RlbmVyJHR5cGUiLCJjYWxsIiwiZGVmYXVsdFNjcmVlblJlYWRlckluc3RydWN0aW9ucyIsImRyYWdnYWJsZSIsImRlZmF1bHRBbm5vdW5jZW1lbnRzIiwib25EcmFnU3RhcnQiLCJhY3RpdmUiLCJpZCIsIm9uRHJhZ092ZXIiLCJfcmVmMiIsIm92ZXIiLCJvbkRyYWdFbmQiLCJfcmVmMyIsIm9uRHJhZ0NhbmNlbCIsIl9yZWY0IiwiQWNjZXNzaWJpbGl0eSIsImFubm91bmNlbWVudHMiLCJjb250YWluZXIiLCJoaWRkZW5UZXh0RGVzY3JpYmVkQnlJZCIsInNjcmVlblJlYWRlckluc3RydWN0aW9ucyIsImFubm91bmNlIiwiYW5ub3VuY2VtZW50IiwibGl2ZVJlZ2lvbklkIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJvbkRyYWdNb3ZlIiwiX3JlZjUiLCJfcmVmNiIsIm1hcmt1cCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInZhbHVlIiwiQWN0aW9uIiwibm9vcCIsInVzZVNlbnNvciIsInNlbnNvciIsIm9wdGlvbnMiLCJ1c2VTZW5zb3JzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNlbnNvcnMiLCJBcnJheSIsIl9rZXkiLCJmaWx0ZXIiLCJkZWZhdWx0Q29vcmRpbmF0ZXMiLCJPYmplY3QiLCJmcmVlemUiLCJ4IiwieSIsImRpc3RhbmNlQmV0d2VlbiIsInAxIiwicDIiLCJNYXRoIiwic3FydCIsInBvdyIsImdldFJlbGF0aXZlVHJhbnNmb3JtT3JpZ2luIiwicmVjdCIsImV2ZW50Q29vcmRpbmF0ZXMiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJsZWZ0Iiwid2lkdGgiLCJ0b3AiLCJoZWlnaHQiLCJzb3J0Q29sbGlzaW9uc0FzYyIsImRhdGEiLCJhIiwiYiIsInNvcnRDb2xsaXNpb25zRGVzYyIsImNvcm5lcnNPZlJlY3RhbmdsZSIsImdldEZpcnN0Q29sbGlzaW9uIiwiY29sbGlzaW9ucyIsInByb3BlcnR5IiwiZmlyc3RDb2xsaXNpb24iLCJjZW50ZXJPZlJlY3RhbmdsZSIsImNsb3Nlc3RDZW50ZXIiLCJjb2xsaXNpb25SZWN0IiwiZHJvcHBhYmxlUmVjdHMiLCJkcm9wcGFibGVDb250YWluZXJzIiwiY2VudGVyUmVjdCIsImRyb3BwYWJsZUNvbnRhaW5lciIsImdldCIsImRpc3RCZXR3ZWVuIiwicHVzaCIsInNvcnQiLCJjbG9zZXN0Q29ybmVycyIsImNvcm5lcnMiLCJyZWN0Q29ybmVycyIsImRpc3RhbmNlcyIsInJlZHVjZSIsImFjY3VtdWxhdG9yIiwiY29ybmVyIiwiaW5kZXgiLCJlZmZlY3RpdmVEaXN0YW5jZSIsIk51bWJlciIsInRvRml4ZWQiLCJnZXRJbnRlcnNlY3Rpb25SYXRpbyIsImVudHJ5IiwidGFyZ2V0IiwibWF4IiwicmlnaHQiLCJtaW4iLCJib3R0b20iLCJ0YXJnZXRBcmVhIiwiZW50cnlBcmVhIiwiaW50ZXJzZWN0aW9uQXJlYSIsImludGVyc2VjdGlvblJhdGlvIiwicmVjdEludGVyc2VjdGlvbiIsImlzUG9pbnRXaXRoaW5SZWN0IiwicG9pbnQiLCJwb2ludGVyV2l0aGluIiwicG9pbnRlckNvb3JkaW5hdGVzIiwiYWRqdXN0U2NhbGUiLCJ0cmFuc2Zvcm0iLCJyZWN0MSIsInJlY3QyIiwic2NhbGVYIiwic2NhbGVZIiwiZ2V0UmVjdERlbHRhIiwiY3JlYXRlUmVjdEFkanVzdG1lbnRGbiIsIm1vZGlmaWVyIiwiYWRqdXN0Q2xpZW50UmVjdCIsImFkanVzdG1lbnRzIiwiYWNjIiwiYWRqdXN0bWVudCIsImdldEFkanVzdGVkUmVjdCIsInBhcnNlVHJhbnNmb3JtIiwic3RhcnRzV2l0aCIsInRyYW5zZm9ybUFycmF5Iiwic2xpY2UiLCJzcGxpdCIsImludmVyc2VUcmFuc2Zvcm0iLCJwYXJzZWRUcmFuc2Zvcm0iLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInBhcnNlRmxvYXQiLCJpbmRleE9mIiwidyIsImgiLCJkZWZhdWx0T3B0aW9ucyIsImlnbm9yZVRyYW5zZm9ybSIsImdldENsaWVudFJlY3QiLCJlbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFRyYW5zZm9ybUFnbm9zdGljQ2xpZW50UmVjdCIsImdldFdpbmRvd0NsaWVudFJlY3QiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJpc0ZpeGVkIiwibm9kZSIsImNvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsImlzU2Nyb2xsYWJsZSIsIm92ZXJmbG93UmVnZXgiLCJwcm9wZXJ0aWVzIiwic29tZSIsInRlc3QiLCJnZXRTY3JvbGxhYmxlQW5jZXN0b3JzIiwibGltaXQiLCJzY3JvbGxQYXJlbnRzIiwiZmluZFNjcm9sbGFibGVBbmNlc3RvcnMiLCJzY3JvbGxpbmdFbGVtZW50IiwiaW5jbHVkZXMiLCJwYXJlbnROb2RlIiwiZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IiLCJmaXJzdFNjcm9sbGFibGVBbmNlc3RvciIsImdldFNjcm9sbGFibGVFbGVtZW50Iiwid2luZG93IiwiZ2V0U2Nyb2xsWENvb3JkaW5hdGUiLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsImdldFNjcm9sbFlDb29yZGluYXRlIiwic2Nyb2xsWSIsInNjcm9sbFRvcCIsImdldFNjcm9sbENvb3JkaW5hdGVzIiwiRGlyZWN0aW9uIiwiaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQiLCJkb2N1bWVudCIsImdldFNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsaW5nQ29udGFpbmVyIiwibWluU2Nyb2xsIiwiZGltZW5zaW9ucyIsImNsaWVudEhlaWdodCIsImNsaWVudFdpZHRoIiwibWF4U2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJpc1RvcCIsImlzTGVmdCIsImlzQm90dG9tIiwiaXNSaWdodCIsImRlZmF1bHRUaHJlc2hvbGQiLCJnZXRTY3JvbGxEaXJlY3Rpb25BbmRTcGVlZCIsInNjcm9sbENvbnRhaW5lciIsInNjcm9sbENvbnRhaW5lclJlY3QiLCJhY2NlbGVyYXRpb24iLCJ0aHJlc2hvbGRQZXJjZW50YWdlIiwiZGlyZWN0aW9uIiwic3BlZWQiLCJ0aHJlc2hvbGQiLCJCYWNrd2FyZCIsImFicyIsIkZvcndhcmQiLCJnZXRTY3JvbGxFbGVtZW50UmVjdCIsImdldFNjcm9sbE9mZnNldHMiLCJzY3JvbGxhYmxlQW5jZXN0b3JzIiwiZ2V0U2Nyb2xsWE9mZnNldCIsImdldFNjcm9sbFlPZmZzZXQiLCJzY3JvbGxJbnRvVmlld0lmTmVlZGVkIiwibWVhc3VyZSIsInNjcm9sbEludG9WaWV3IiwiYmxvY2siLCJpbmxpbmUiLCJSZWN0IiwiY29uc3RydWN0b3IiLCJzY3JvbGxPZmZzZXRzIiwiYXhpcyIsImtleXMiLCJnZXRTY3JvbGxPZmZzZXQiLCJrZXkiLCJkZWZpbmVQcm9wZXJ0eSIsImN1cnJlbnRPZmZzZXRzIiwic2Nyb2xsT2Zmc2V0c0RlbHRsYSIsImVudW1lcmFibGUiLCJMaXN0ZW5lcnMiLCJyZW1vdmVBbGwiLCJfdGhpcyR0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnROYW1lIiwiaGFuZGxlciIsIl90aGlzJHRhcmdldDIiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0RXZlbnRMaXN0ZW5lclRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiaGFzRXhjZWVkZWREaXN0YW5jZSIsImRlbHRhIiwibWVhc3VyZW1lbnQiLCJkeCIsImR5IiwiRXZlbnROYW1lIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJLZXlib2FyZENvZGUiLCJkZWZhdWx0S2V5Ym9hcmRDb2RlcyIsInN0YXJ0IiwiU3BhY2UiLCJFbnRlciIsImNhbmNlbCIsIkVzYyIsImVuZCIsImRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIiLCJjdXJyZW50Q29vcmRpbmF0ZXMiLCJjb2RlIiwiUmlnaHQiLCJMZWZ0IiwiRG93biIsIlVwIiwidW5kZWZpbmVkIiwiS2V5Ym9hcmRTZW5zb3IiLCJwcm9wcyIsImF1dG9TY3JvbGxFbmFibGVkIiwicmVmZXJlbmNlQ29vcmRpbmF0ZXMiLCJ3aW5kb3dMaXN0ZW5lcnMiLCJoYW5kbGVLZXlEb3duIiwiYmluZCIsImhhbmRsZUNhbmNlbCIsImF0dGFjaCIsImhhbmRsZVN0YXJ0IiwiUmVzaXplIiwiVmlzaWJpbGl0eUNoYW5nZSIsInNldFRpbWVvdXQiLCJLZXlkb3duIiwiYWN0aXZlTm9kZSIsIm9uU3RhcnQiLCJjdXJyZW50IiwiY29udGV4dCIsImtleWJvYXJkQ29kZXMiLCJjb29yZGluYXRlR2V0dGVyIiwic2Nyb2xsQmVoYXZpb3IiLCJoYW5kbGVFbmQiLCJuZXdDb29yZGluYXRlcyIsImNvb3JkaW5hdGVzRGVsdGEiLCJzY3JvbGxEZWx0YSIsInNjcm9sbEVsZW1lbnRSZWN0IiwiY2xhbXBlZENvb3JkaW5hdGVzIiwiY2FuU2Nyb2xsWCIsImNhblNjcm9sbFkiLCJuZXdTY3JvbGxDb29yZGluYXRlcyIsImNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwic2Nyb2xsQnkiLCJoYW5kbGVNb3ZlIiwiY29vcmRpbmF0ZXMiLCJvbk1vdmUiLCJvbkVuZCIsImRldGFjaCIsIm9uQ2FuY2VsIiwiYWN0aXZhdG9ycyIsIm9uQWN0aXZhdGlvbiIsIm5hdGl2ZUV2ZW50IiwiYWN0aXZhdG9yIiwiYWN0aXZhdG9yTm9kZSIsImlzRGlzdGFuY2VDb25zdHJhaW50IiwiY29uc3RyYWludCIsIkJvb2xlYW4iLCJpc0RlbGF5Q29uc3RyYWludCIsIkFic3RyYWN0UG9pbnRlclNlbnNvciIsImV2ZW50cyIsImxpc3RlbmVyVGFyZ2V0IiwiX2dldEV2ZW50Q29vcmRpbmF0ZXMiLCJhY3RpdmF0ZWQiLCJpbml0aWFsQ29vcmRpbmF0ZXMiLCJ0aW1lb3V0SWQiLCJkb2N1bWVudExpc3RlbmVycyIsImhhbmRsZUtleWRvd24iLCJyZW1vdmVUZXh0U2VsZWN0aW9uIiwiYWN0aXZhdGlvbkNvbnN0cmFpbnQiLCJtb3ZlIiwibmFtZSIsInBhc3NpdmUiLCJEcmFnU3RhcnQiLCJDb250ZXh0TWVudSIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiQ2xpY2siLCJjYXB0dXJlIiwiU2VsZWN0aW9uQ2hhbmdlIiwiX2dldEV2ZW50Q29vcmRpbmF0ZXMyIiwidG9sZXJhbmNlIiwiZGlzdGFuY2UiLCJjYW5jZWxhYmxlIiwiX3RoaXMkZG9jdW1lbnQkZ2V0U2VsIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiUG9pbnRlclNlbnNvciIsImlzUHJpbWFyeSIsImJ1dHRvbiIsImV2ZW50cyQxIiwiTW91c2VCdXR0b24iLCJNb3VzZVNlbnNvciIsIlJpZ2h0Q2xpY2siLCJldmVudHMkMiIsIlRvdWNoU2Vuc29yIiwic2V0dXAiLCJ0ZWFyZG93biIsInRvdWNoZXMiLCJBdXRvU2Nyb2xsQWN0aXZhdG9yIiwiVHJhdmVyc2FsT3JkZXIiLCJ1c2VBdXRvU2Nyb2xsZXIiLCJQb2ludGVyIiwiY2FuU2Nyb2xsIiwiZHJhZ2dpbmdSZWN0IiwiZW5hYmxlZCIsImludGVydmFsIiwib3JkZXIiLCJUcmVlT3JkZXIiLCJzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyIsInNjcm9sbEludGVudCIsInVzZVNjcm9sbEludGVudCIsImRpc2FibGVkIiwic2V0QXV0b1Njcm9sbEludGVydmFsIiwiY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwiLCJzY3JvbGxTcGVlZCIsInNjcm9sbERpcmVjdGlvbiIsIkRyYWdnYWJsZVJlY3QiLCJzY3JvbGxDb250YWluZXJSZWYiLCJhdXRvU2Nyb2xsIiwic29ydGVkU2Nyb2xsYWJsZUFuY2VzdG9ycyIsInJldmVyc2UiLCJKU09OIiwic3RyaW5naWZ5IiwiZGVmYXVsdFNjcm9sbEludGVudCIsInByZXZpb3VzRGVsdGEiLCJwcmV2aW91c0ludGVudCIsInNpZ24iLCJ1c2VDYWNoZWROb2RlIiwiZHJhZ2dhYmxlTm9kZXMiLCJkcmFnZ2FibGVOb2RlIiwiY2FjaGVkTm9kZSIsInVzZUNvbWJpbmVBY3RpdmF0b3JzIiwiZ2V0U3ludGhldGljSGFuZGxlciIsIlNlbnNvciIsInNlbnNvckFjdGl2YXRvcnMiLCJtYXAiLCJNZWFzdXJpbmdTdHJhdGVneSIsIk1lYXN1cmluZ0ZyZXF1ZW5jeSIsImRlZmF1bHRWYWx1ZSIsIk1hcCIsInVzZURyb3BwYWJsZU1lYXN1cmluZyIsImNvbnRhaW5lcnMiLCJkcmFnZ2luZyIsImRlcGVuZGVuY2llcyIsImNvbmZpZyIsInF1ZXVlIiwic2V0UXVldWUiLCJmcmVxdWVuY3kiLCJzdHJhdGVneSIsImNvbnRhaW5lcnNSZWYiLCJpc0Rpc2FibGVkIiwiZGlzYWJsZWRSZWYiLCJtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyIsImlkcyIsImNvbmNhdCIsInByZXZpb3VzVmFsdWUiLCJzZXQiLCJtZWFzdXJpbmdTY2hlZHVsZWQiLCJBbHdheXMiLCJCZWZvcmVEcmFnZ2luZyIsInVzZUluaXRpYWxWYWx1ZSIsImNvbXB1dGVGbiIsInVzZUluaXRpYWxSZWN0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsImNhbGxiYWNrIiwiaGFuZGxlTXV0YXRpb25zIiwibXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwidXNlUmVzaXplT2JzZXJ2ZXIiLCJoYW5kbGVSZXNpemUiLCJyZXNpemVPYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyIiwiZGVmYXVsdE1lYXN1cmUiLCJ1c2VSZWN0IiwiZmFsbGJhY2tSZWN0IiwibWVhc3VyZVJlY3QiLCJyZWR1Y2VyIiwicmVjb3JkcyIsInJlY29yZCIsIkhUTUxFbGVtZW50IiwiY29udGFpbnMiLCJvYnNlcnZlIiwiYm9keSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjdXJyZW50UmVjdCIsImlzQ29ubmVjdGVkIiwibmV3UmVjdCIsInVzZVJlY3REZWx0YSIsImluaXRpYWxSZWN0IiwiZGVmYXVsdFZhbHVlJDEiLCJ1c2VTY3JvbGxhYmxlQW5jZXN0b3JzIiwicHJldmlvdXNOb2RlIiwiYW5jZXN0b3JzIiwidXNlU2Nyb2xsT2Zmc2V0cyIsImVsZW1lbnRzIiwic2Nyb2xsQ29vcmRpbmF0ZXMiLCJzZXRTY3JvbGxDb29yZGluYXRlcyIsInByZXZFbGVtZW50cyIsImhhbmRsZVNjcm9sbCIsInByZXZpb3VzRWxlbWVudHMiLCJjbGVhbnVwIiwiZW50cmllcyIsInNjcm9sbGFibGVFbGVtZW50IiwiZnJvbSIsInZhbHVlcyIsInVzZVNjcm9sbE9mZnNldHNEZWx0YSIsImluaXRpYWxTY3JvbGxPZmZzZXRzIiwiaGFzU2Nyb2xsT2Zmc2V0cyIsInVzZVNlbnNvclNldHVwIiwidGVhcmRvd25GbnMiLCJ1c2VTeW50aGV0aWNMaXN0ZW5lcnMiLCJ1c2VXaW5kb3dSZWN0IiwiZGVmYXVsdFZhbHVlJDIiLCJ1c2VSZWN0cyIsImZpcnN0RWxlbWVudCIsIndpbmRvd1JlY3QiLCJyZWN0cyIsIm1lYXN1cmVSZWN0cyIsImdldE1lYXN1cmFibGVOb2RlIiwiY2hpbGRyZW4iLCJmaXJzdENoaWxkIiwidXNlRHJhZ092ZXJsYXlNZWFzdXJpbmciLCJzZXRSZWN0IiwiaGFuZGxlTm9kZUNoYW5nZSIsIm5vZGVSZWYiLCJzZXRSZWYiLCJkZWZhdWx0U2Vuc29ycyIsImRlZmF1bHREYXRhIiwiZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJkcm9wcGFibGUiLCJXaGlsZURyYWdnaW5nIiwiT3B0aW1pemVkIiwiZHJhZ092ZXJsYXkiLCJEcm9wcGFibGVDb250YWluZXJzTWFwIiwiX3N1cGVyJGdldCIsInRvQXJyYXkiLCJnZXRFbmFibGVkIiwiZ2V0Tm9kZUZvciIsIl90aGlzJGdldCRub2RlJGN1cnJlbiIsIl90aGlzJGdldCIsImRlZmF1bHRQdWJsaWNDb250ZXh0IiwiYWN0aXZhdG9yRXZlbnQiLCJhY3RpdmVOb2RlUmVjdCIsImNvbnRhaW5lck5vZGVSZWN0IiwibWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsImRlZmF1bHRJbnRlcm5hbENvbnRleHQiLCJhcmlhRGVzY3JpYmVkQnlJZCIsIkludGVybmFsQ29udGV4dCIsIlB1YmxpY0NvbnRleHQiLCJnZXRJbml0aWFsU3RhdGUiLCJub2RlcyIsInRyYW5zbGF0ZSIsInN0YXRlIiwiYWN0aW9uIiwiRHJhZ01vdmUiLCJEcmFnRW5kIiwiRHJhZ0NhbmNlbCIsIlJlZ2lzdGVyRHJvcHBhYmxlIiwiU2V0RHJvcHBhYmxlRGlzYWJsZWQiLCJVbnJlZ2lzdGVyRHJvcHBhYmxlIiwiUmVzdG9yZUZvY3VzIiwicHJldmlvdXNBY3RpdmF0b3JFdmVudCIsInByZXZpb3VzQWN0aXZlSWQiLCJhY3RpdmVFbGVtZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZm9jdXNhYmxlTm9kZSIsImZvY3VzIiwiYXBwbHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJhcmdzIiwidXNlTWVhc3VyaW5nQ29uZmlndXJhdGlvbiIsInVzZUxheW91dFNoaWZ0U2Nyb2xsQ29tcGVuc2F0aW9uIiwiaW5pdGlhbGl6ZWQiLCJyZWN0RGVsdGEiLCJBY3RpdmVEcmFnZ2FibGVDb250ZXh0IiwiU3RhdHVzIiwiRG5kQ29udGV4dCIsIl9zZW5zb3JDb250ZXh0JGN1cnJlbiIsIl9kcmFnT3ZlcmxheSRub2RlUmVmJCIsIl9kcmFnT3ZlcmxheSRyZWN0IiwiX292ZXIkcmVjdCIsImFjY2Vzc2liaWxpdHkiLCJjb2xsaXNpb25EZXRlY3Rpb24iLCJtZWFzdXJpbmciLCJzdG9yZSIsImRpc3BhdGNoTW9uaXRvckV2ZW50IiwicmVnaXN0ZXJNb25pdG9yTGlzdGVuZXIiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJVbmluaXRpYWxpemVkIiwiaXNJbml0aWFsaXplZCIsIkluaXRpYWxpemVkIiwiYWN0aXZlSWQiLCJhY3RpdmVSZWN0cyIsImluaXRpYWwiLCJ0cmFuc2xhdGVkIiwiX25vZGUkZGF0YSIsImFjdGl2ZVJlZiIsImFjdGl2ZVNlbnNvciIsInNldEFjdGl2ZVNlbnNvciIsInNldEFjdGl2YXRvckV2ZW50IiwibGF0ZXN0UHJvcHMiLCJkcmFnZ2FibGVEZXNjcmliZWRCeUlkIiwiZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMiLCJhY3RpdmF0aW9uQ29vcmRpbmF0ZXMiLCJhdXRvU2Nyb2xsT3B0aW9ucyIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJpbml0aWFsQWN0aXZlTm9kZVJlY3QiLCJsYXlvdXRTaGlmdENvbXBlbnNhdGlvbiIsInBhcmVudEVsZW1lbnQiLCJzZW5zb3JDb250ZXh0IiwiZHJhZ2dpbmdOb2RlIiwiZHJhZ2dpbmdOb2RlUmVjdCIsInNjcm9sbEFkanVzdGVkVHJhbnNsYXRlIiwib3Zlck5vZGUiLCJ1c2VzRHJhZ092ZXJsYXkiLCJub2RlUmVjdERlbHRhIiwibW9kaWZpZWRUcmFuc2xhdGUiLCJvdmVybGF5Tm9kZVJlY3QiLCJzY3JvbGxBZGp1c3RtZW50IiwiYWN0aXZlTm9kZVNjcm9sbERlbHRhIiwib3ZlcklkIiwic2V0T3ZlciIsImFwcGxpZWRUcmFuc2xhdGUiLCJpbnN0YW50aWF0ZVNlbnNvciIsInNlbnNvckluc3RhbmNlIiwiSW5pdGlhbGl6aW5nIiwiY3JlYXRlSGFuZGxlciIsImNhbmNlbERyb3AiLCJzaG91bGRDYW5jZWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImJpbmRBY3RpdmF0b3JUb1NlbnNvckluc3RhbnRpYXRvciIsImFjdGl2ZURyYWdnYWJsZU5vZGUiLCJkbmRLaXQiLCJkZWZhdWx0UHJldmVudGVkIiwiYWN0aXZhdGlvbkNvbnRleHQiLCJzaG91bGRBY3RpdmF0ZSIsImNhcHR1cmVkQnkiLCJvdmVyQ29udGFpbmVyIiwicHVibGljQ29udGV4dCIsImludGVybmFsQ29udGV4dCIsIlByb3ZpZGVyIiwicmVzdG9yZUZvY3VzIiwiYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsIiwiYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQiLCJOdWxsQ29udGV4dCIsImRlZmF1bHRSb2xlIiwiSURfUFJFRklYIiwidXNlRHJhZ2dhYmxlIiwiYXR0cmlidXRlcyIsInJvbGUiLCJyb2xlRGVzY3JpcHRpb24iLCJ0YWJJbmRleCIsImlzRHJhZ2dpbmciLCJzZXROb2RlUmVmIiwic2V0QWN0aXZhdG9yTm9kZVJlZiIsImRhdGFSZWYiLCJtZW1vaXplZEF0dHJpYnV0ZXMiLCJ1c2VEbmRDb250ZXh0IiwiSURfUFJFRklYJDEiLCJkZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWciLCJ0aW1lb3V0IiwidXNlRHJvcHBhYmxlIiwicmVzaXplT2JzZXJ2ZXJDb25maWciLCJwcmV2aW91cyIsInJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkIiwiY2FsbGJhY2tJZCIsInJlc2l6ZU9ic2VydmVyRGlzYWJsZWQiLCJ1cGRhdGVNZWFzdXJlbWVudHNGb3IiLCJyZXNpemVPYnNlcnZlclRpbWVvdXQiLCJpc0FycmF5IiwibmV3RWxlbWVudCIsInByZXZpb3VzRWxlbWVudCIsInVub2JzZXJ2ZSIsImlzT3ZlciIsIkFuaW1hdGlvbk1hbmFnZXIiLCJhbmltYXRpb24iLCJjbG9uZWRDaGlsZHJlbiIsInNldENsb25lZENoaWxkcmVuIiwic2V0RWxlbWVudCIsInByZXZpb3VzQ2hpbGRyZW4iLCJ0aGVuIiwicmVmIiwiZGVmYXVsdFRyYW5zZm9ybSIsIk51bGxpZmllZENvbnRleHRQcm92aWRlciIsImJhc2VTdHlsZXMiLCJ0b3VjaEFjdGlvbiIsImRlZmF1bHRUcmFuc2l0aW9uIiwiaXNLZXlib2FyZEFjdGl2YXRvciIsIlBvc2l0aW9uZWRPdmVybGF5IiwiYXMiLCJjbGFzc05hbWUiLCJzdHlsZSIsInRyYW5zaXRpb24iLCJzY2FsZUFkanVzdGVkVHJhbnNmb3JtIiwic3R5bGVzIiwiVHJhbnNmb3JtIiwidG9TdHJpbmciLCJkZWZhdWx0RHJvcEFuaW1hdGlvblNpZGVFZmZlY3RzIiwib3JpZ2luYWxTdHlsZXMiLCJnZXRQcm9wZXJ0eVZhbHVlIiwic2V0UHJvcGVydHkiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlciIsImZpbmFsIiwiZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uIiwiZHVyYXRpb24iLCJlYXNpbmciLCJrZXlmcmFtZXMiLCJzaWRlRWZmZWN0cyIsIm9wYWNpdHkiLCJ1c2VEcm9wQW5pbWF0aW9uIiwiYWN0aXZlRHJhZ2dhYmxlIiwibWVhc3VyYWJsZU5vZGUiLCJjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbiIsInJlc3QiLCJzY2FsZSIsImZpbmFsVHJhbnNmb3JtIiwiYW5pbWF0aW9uS2V5ZnJhbWVzIiwiZmlyc3RLZXlmcmFtZSIsImxhc3RLZXlmcmFtZSIsImFuaW1hdGUiLCJmaWxsIiwib25maW5pc2giLCJ1c2VLZXkiLCJEcmFnT3ZlcmxheSIsImRyb3BBbmltYXRpb24iLCJkcm9wQW5pbWF0aW9uQ29uZmlnIiwid3JhcHBlckVsZW1lbnQiLCJ6SW5kZXgiLCJtb2RpZmllZFRyYW5zZm9ybSIsImRlZmF1bHREcm9wQW5pbWF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/sortable/dist/sortable.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dnd-kit/sortable/dist/sortable.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortableContext: () => (/* binding */ SortableContext),\n/* harmony export */   arrayMove: () => (/* binding */ arrayMove),\n/* harmony export */   arraySwap: () => (/* binding */ arraySwap),\n/* harmony export */   defaultAnimateLayoutChanges: () => (/* binding */ defaultAnimateLayoutChanges),\n/* harmony export */   defaultNewIndexGetter: () => (/* binding */ defaultNewIndexGetter),\n/* harmony export */   hasSortableData: () => (/* binding */ hasSortableData),\n/* harmony export */   horizontalListSortingStrategy: () => (/* binding */ horizontalListSortingStrategy),\n/* harmony export */   rectSortingStrategy: () => (/* binding */ rectSortingStrategy),\n/* harmony export */   rectSwappingStrategy: () => (/* binding */ rectSwappingStrategy),\n/* harmony export */   sortableKeyboardCoordinates: () => (/* binding */ sortableKeyboardCoordinates),\n/* harmony export */   useSortable: () => (/* binding */ useSortable),\n/* harmony export */   verticalListSortingStrategy: () => (/* binding */ verticalListSortingStrategy)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/core */ \"(ssr)/./node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n\n\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */ function arrayMove(array, from, to) {\n    const newArray = array.slice();\n    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n    return newArray;\n}\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */ function arraySwap(array, from, to) {\n    const newArray = array.slice();\n    newArray[from] = array[to];\n    newArray[to] = array[from];\n    return newArray;\n}\nfunction getSortedRects(items, rects) {\n    return items.reduce((accumulator, id, index)=>{\n        const rect = rects.get(id);\n        if (rect) {\n            accumulator[index] = rect;\n        }\n        return accumulator;\n    }, Array(items.length));\n}\nfunction isValidIndex(index) {\n    return index !== null && index >= 0;\n}\nfunction itemsEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction normalizeDisabled(disabled) {\n    if (typeof disabled === \"boolean\") {\n        return {\n            draggable: disabled,\n            droppable: disabled\n        };\n    }\n    return disabled;\n}\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst horizontalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { rects, activeNodeRect: fallbackActiveRect, activeIndex, overIndex, index } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    const itemGap = getItemGap(rects, index, activeIndex);\n    if (index === activeIndex) {\n        const newIndexRect = rects[overIndex];\n        if (!newIndexRect) {\n            return null;\n        }\n        return {\n            x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: -activeNodeRect.width - itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: activeNodeRect.width + itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale\n    };\n};\nfunction getItemGap(rects, index, activeIndex) {\n    const currentRect = rects[index];\n    const previousRect = rects[index - 1];\n    const nextRect = rects[index + 1];\n    if (!currentRect || !previousRect && !nextRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n    }\n    return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\nconst rectSortingStrategy = (_ref)=>{\n    let { rects, activeIndex, overIndex, index } = _ref;\n    const newRects = arrayMove(rects, overIndex, activeIndex);\n    const oldRect = rects[index];\n    const newRect = newRects[index];\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\nconst rectSwappingStrategy = (_ref)=>{\n    let { activeIndex, index, rects, overIndex } = _ref;\n    let oldRect;\n    let newRect;\n    if (index === activeIndex) {\n        oldRect = rects[index];\n        newRect = rects[overIndex];\n    }\n    if (index === overIndex) {\n        oldRect = rects[index];\n        newRect = rects[activeIndex];\n    }\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst verticalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { activeIndex, activeNodeRect: fallbackActiveRect, index, rects, overIndex } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    if (index === activeIndex) {\n        const overIndexRect = rects[overIndex];\n        if (!overIndexRect) {\n            return null;\n        }\n        return {\n            x: 0,\n            y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n            ...defaultScale$1\n        };\n    }\n    const itemGap = getItemGap$1(rects, index, activeIndex);\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: 0,\n            y: -activeNodeRect.height - itemGap,\n            ...defaultScale$1\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: 0,\n            y: activeNodeRect.height + itemGap,\n            ...defaultScale$1\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale$1\n    };\n};\nfunction getItemGap$1(clientRects, index, activeIndex) {\n    const currentRect = clientRects[index];\n    const previousRect = clientRects[index - 1];\n    const nextRect = clientRects[index + 1];\n    if (!currentRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n    }\n    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\nconst ID_PREFIX = \"Sortable\";\nconst Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    activeIndex: -1,\n    containerId: ID_PREFIX,\n    disableTransforms: false,\n    items: [],\n    overIndex: -1,\n    useDragOverlay: false,\n    sortedRects: [],\n    strategy: rectSortingStrategy,\n    disabled: {\n        draggable: false,\n        droppable: false\n    }\n});\nfunction SortableContext(_ref) {\n    let { children, id, items: userDefinedItems, strategy = rectSortingStrategy, disabled: disabledProp = false } = _ref;\n    const { active, dragOverlay, droppableRects, over, measureDroppableContainers } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDndContext)();\n    const containerId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX, id);\n    const useDragOverlay = Boolean(dragOverlay.rect !== null);\n    const items = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>userDefinedItems.map((item)=>typeof item === \"object\" && \"id\" in item ? item.id : item), [\n        userDefinedItems\n    ]);\n    const isDragging = active != null;\n    const activeIndex = active ? items.indexOf(active.id) : -1;\n    const overIndex = over ? items.indexOf(over.id) : -1;\n    const previousItemsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items);\n    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n    const disabled = normalizeDisabled(disabledProp);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (itemsHaveChanged && isDragging) {\n            measureDroppableContainers(items);\n        }\n    }, [\n        itemsHaveChanged,\n        items,\n        isDragging,\n        measureDroppableContainers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousItemsRef.current = items;\n    }, [\n        items\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            activeIndex,\n            containerId,\n            disabled,\n            disableTransforms,\n            items,\n            overIndex,\n            useDragOverlay,\n            sortedRects: getSortedRects(items, droppableRects),\n            strategy\n        }), [\n        activeIndex,\n        containerId,\n        disabled.draggable,\n        disabled.droppable,\n        disableTransforms,\n        items,\n        overIndex,\n        droppableRects,\n        useDragOverlay,\n        strategy\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nconst defaultNewIndexGetter = (_ref)=>{\n    let { id, items, activeIndex, overIndex } = _ref;\n    return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = (_ref2)=>{\n    let { containerId, isSorting, wasDragging, index, items, newIndex, previousItems, previousContainerId, transition } = _ref2;\n    if (!transition || !wasDragging) {\n        return false;\n    }\n    if (previousItems !== items && index === newIndex) {\n        return false;\n    }\n    if (isSorting) {\n        return true;\n    }\n    return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n    duration: 200,\n    easing: \"ease\"\n};\nconst transitionProperty = \"transform\";\nconst disabledTransition = /*#__PURE__*/ _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n    property: transitionProperty,\n    duration: 0,\n    easing: \"linear\"\n});\nconst defaultAttributes = {\n    roleDescription: \"sortable\"\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */ function useDerivedTransform(_ref) {\n    let { disabled, index, node, rect } = _ref;\n    const [derivedTransform, setDerivedtransform] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(index);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!disabled && index !== previousIndex.current && node.current) {\n            const initial = rect.current;\n            if (initial) {\n                const current = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getClientRect)(node.current, {\n                    ignoreTransform: true\n                });\n                const delta = {\n                    x: initial.left - current.left,\n                    y: initial.top - current.top,\n                    scaleX: initial.width / current.width,\n                    scaleY: initial.height / current.height\n                };\n                if (delta.x || delta.y) {\n                    setDerivedtransform(delta);\n                }\n            }\n        }\n        if (index !== previousIndex.current) {\n            previousIndex.current = index;\n        }\n    }, [\n        disabled,\n        index,\n        node,\n        rect\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (derivedTransform) {\n            setDerivedtransform(null);\n        }\n    }, [\n        derivedTransform\n    ]);\n    return derivedTransform;\n}\nfunction useSortable(_ref) {\n    let { animateLayoutChanges = defaultAnimateLayoutChanges, attributes: userDefinedAttributes, disabled: localDisabled, data: customData, getNewIndex = defaultNewIndexGetter, id, strategy: localStrategy, resizeObserverConfig, transition = defaultTransition } = _ref;\n    const { items, containerId, activeIndex, disabled: globalDisabled, disableTransforms, sortedRects, overIndex, useDragOverlay, strategy: globalStrategy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n    const index = items.indexOf(id);\n    const data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sortable: {\n                containerId,\n                index,\n                items\n            },\n            ...customData\n        }), [\n        containerId,\n        customData,\n        index,\n        items\n    ]);\n    const itemsAfterCurrentSortable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>items.slice(items.indexOf(id)), [\n        items,\n        id\n    ]);\n    const { rect, node, isOver, setNodeRef: setDroppableNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDroppable)({\n        id,\n        data,\n        disabled: disabled.droppable,\n        resizeObserverConfig: {\n            updateMeasurementsFor: itemsAfterCurrentSortable,\n            ...resizeObserverConfig\n        }\n    });\n    const { active, activatorEvent, activeNodeRect, attributes, setNodeRef: setDraggableNodeRef, listeners, isDragging, over, setActivatorNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\n        id,\n        data,\n        attributes: {\n            ...defaultAttributes,\n            ...userDefinedAttributes\n        },\n        disabled: disabled.draggable\n    });\n    const setNodeRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useCombinedRefs)(setDroppableNodeRef, setDraggableNodeRef);\n    const isSorting = Boolean(active);\n    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n    const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n    const strategy = localStrategy != null ? localStrategy : globalStrategy;\n    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index\n    }) : null;\n    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n        id,\n        items,\n        activeIndex,\n        overIndex\n    }) : index;\n    const activeId = active == null ? void 0 : active.id;\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activeId,\n        items,\n        newIndex,\n        containerId\n    });\n    const itemsHaveChanged = items !== previous.current.items;\n    const shouldAnimateLayoutChanges = animateLayoutChanges({\n        active,\n        containerId,\n        isDragging,\n        isSorting,\n        id,\n        index,\n        items,\n        newIndex: previous.current.newIndex,\n        previousItems: previous.current.items,\n        previousContainerId: previous.current.containerId,\n        transition,\n        wasDragging: previous.current.activeId != null\n    });\n    const derivedTransform = useDerivedTransform({\n        disabled: !shouldAnimateLayoutChanges,\n        index,\n        node,\n        rect\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isSorting && previous.current.newIndex !== newIndex) {\n            previous.current.newIndex = newIndex;\n        }\n        if (containerId !== previous.current.containerId) {\n            previous.current.containerId = containerId;\n        }\n        if (items !== previous.current.items) {\n            previous.current.items = items;\n        }\n    }, [\n        isSorting,\n        newIndex,\n        containerId,\n        items\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeId === previous.current.activeId) {\n            return;\n        }\n        if (activeId && !previous.current.activeId) {\n            previous.current.activeId = activeId;\n            return;\n        }\n        const timeoutId = setTimeout(()=>{\n            previous.current.activeId = activeId;\n        }, 50);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        activeId\n    ]);\n    return {\n        active,\n        activeIndex,\n        attributes,\n        data,\n        rect,\n        index,\n        newIndex,\n        items,\n        isOver,\n        isSorting,\n        isDragging,\n        listeners,\n        node,\n        overIndex,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        setDroppableNodeRef,\n        setDraggableNodeRef,\n        transform: derivedTransform != null ? derivedTransform : finalTransform,\n        transition: getTransition()\n    };\n    function getTransition() {\n        if (derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n        itemsHaveChanged && previous.current.newIndex === index) {\n            return disabledTransition;\n        }\n        if (shouldDisplaceDragSource && !(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent) || !transition) {\n            return undefined;\n        }\n        if (isSorting || shouldAnimateLayoutChanges) {\n            return _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n                ...transition,\n                property: transitionProperty\n            });\n        }\n        return undefined;\n    }\n}\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n    var _localDisabled$dragga, _localDisabled$droppa;\n    if (typeof localDisabled === \"boolean\") {\n        return {\n            draggable: localDisabled,\n            // Backwards compatibility\n            droppable: false\n        };\n    }\n    return {\n        draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n        droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n    };\n}\nfunction hasSortableData(entry) {\n    if (!entry) {\n        return false;\n    }\n    const data = entry.data.current;\n    if (data && \"sortable\" in data && typeof data.sortable === \"object\" && \"containerId\" in data.sortable && \"items\" in data.sortable && \"index\" in data.sortable) {\n        return true;\n    }\n    return false;\n}\nconst directions = [\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left\n];\nconst sortableKeyboardCoordinates = (event, _ref)=>{\n    let { context: { active, collisionRect, droppableRects, droppableContainers, over, scrollableAncestors } } = _ref;\n    if (directions.includes(event.code)) {\n        event.preventDefault();\n        if (!active || !collisionRect) {\n            return;\n        }\n        const filteredContainers = [];\n        droppableContainers.getEnabled().forEach((entry)=>{\n            if (!entry || entry != null && entry.disabled) {\n                return;\n            }\n            const rect = droppableRects.get(entry.id);\n            if (!rect) {\n                return;\n            }\n            switch(event.code){\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down:\n                    if (collisionRect.top < rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up:\n                    if (collisionRect.top > rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left:\n                    if (collisionRect.left > rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right:\n                    if (collisionRect.left < rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n            }\n        });\n        const collisions = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.closestCorners)({\n            active,\n            collisionRect: collisionRect,\n            droppableRects,\n            droppableContainers: filteredContainers,\n            pointerCoordinates: null\n        });\n        let closestId = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getFirstCollision)(collisions, \"id\");\n        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n            closestId = collisions[1].id;\n        }\n        if (closestId != null) {\n            const activeDroppable = droppableContainers.get(active.id);\n            const newDroppable = droppableContainers.get(closestId);\n            const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n            const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n            if (newNode && newRect && activeDroppable && newDroppable) {\n                const newScrollAncestors = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(newNode);\n                const hasDifferentScrollAncestors = newScrollAncestors.some((element, index)=>scrollableAncestors[index] !== element);\n                const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n                const isAfterActive = isAfter(activeDroppable, newDroppable);\n                const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n                    x: 0,\n                    y: 0\n                } : {\n                    x: isAfterActive ? collisionRect.width - newRect.width : 0,\n                    y: isAfterActive ? collisionRect.height - newRect.height : 0\n                };\n                const rectCoordinates = {\n                    x: newRect.left,\n                    y: newRect.top\n                };\n                const newCoordinates = offset.x && offset.y ? rectCoordinates : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(rectCoordinates, offset);\n                return newCoordinates;\n            }\n        }\n    }\n    return undefined;\n};\nfunction isSameContainer(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\nfunction isAfter(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    if (!isSameContainer(a, b)) {\n        return false;\n    }\n    return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n //# sourceMappingURL=sortable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvc29ydGFibGUvZGlzdC9zb3J0YWJsZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNrRjtBQUNyQztBQUU3SDs7Q0FFQyxHQUNELFNBQVNvQixVQUFVQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtJQUNoQyxNQUFNQyxXQUFXSCxNQUFNSSxLQUFLO0lBQzVCRCxTQUFTRSxNQUFNLENBQUNILEtBQUssSUFBSUMsU0FBU0csTUFBTSxHQUFHSixLQUFLQSxJQUFJLEdBQUdDLFNBQVNFLE1BQU0sQ0FBQ0osTUFBTSxFQUFFLENBQUMsRUFBRTtJQUNsRixPQUFPRTtBQUNUO0FBRUE7O0NBRUMsR0FDRCxTQUFTSSxVQUFVUCxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRTtJQUNoQyxNQUFNQyxXQUFXSCxNQUFNSSxLQUFLO0lBQzVCRCxRQUFRLENBQUNGLEtBQUssR0FBR0QsS0FBSyxDQUFDRSxHQUFHO0lBQzFCQyxRQUFRLENBQUNELEdBQUcsR0FBR0YsS0FBSyxDQUFDQyxLQUFLO0lBQzFCLE9BQU9FO0FBQ1Q7QUFFQSxTQUFTSyxlQUFlQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsT0FBT0QsTUFBTUUsTUFBTSxDQUFDLENBQUNDLGFBQWFDLElBQUlDO1FBQ3BDLE1BQU1DLE9BQU9MLE1BQU1NLEdBQUcsQ0FBQ0g7UUFFdkIsSUFBSUUsTUFBTTtZQUNSSCxXQUFXLENBQUNFLE1BQU0sR0FBR0M7UUFDdkI7UUFFQSxPQUFPSDtJQUNULEdBQUdLLE1BQU1SLE1BQU1ILE1BQU07QUFDdkI7QUFFQSxTQUFTWSxhQUFhSixLQUFLO0lBQ3pCLE9BQU9BLFVBQVUsUUFBUUEsU0FBUztBQUNwQztBQUVBLFNBQVNLLFdBQVdDLENBQUMsRUFBRUMsQ0FBQztJQUN0QixJQUFJRCxNQUFNQyxHQUFHO1FBQ1gsT0FBTztJQUNUO0lBRUEsSUFBSUQsRUFBRWQsTUFBTSxLQUFLZSxFQUFF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QUM2QyxRQUFRLENBQUNsRSxXQUFXO0FBQ3BGO0FBRUEsU0FBUzRILFFBQVF0SyxDQUFDLEVBQUVDLENBQUM7SUFDbkIsSUFBSSxDQUFDb0ksZ0JBQWdCckksTUFBTSxDQUFDcUksZ0JBQWdCcEksSUFBSTtRQUM5QyxPQUFPO0lBQ1Q7SUFFQSxJQUFJLENBQUNtSyxnQkFBZ0JwSyxHQUFHQyxJQUFJO1FBQzFCLE9BQU87SUFDVDtJQUVBLE9BQU9ELEVBQUVvRyxJQUFJLENBQUNyQyxPQUFPLENBQUM2QyxRQUFRLENBQUNsSCxLQUFLLEdBQUdPLEVBQUVtRyxJQUFJLENBQUNyQyxPQUFPLENBQUM2QyxRQUFRLENBQUNsSCxLQUFLO0FBQ3RFO0FBRXVRLENBQ3ZRLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3BheWxvYWQtcGxheWdyb3VuZC8uL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9zb3J0YWJsZS9kaXN0L3NvcnRhYmxlLmVzbS5qcz82NmU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VEbmRDb250ZXh0LCBnZXRDbGllbnRSZWN0LCB1c2VEcm9wcGFibGUsIHVzZURyYWdnYWJsZSwgY2xvc2VzdENvcm5lcnMsIGdldEZpcnN0Q29sbGlzaW9uLCBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzLCBLZXlib2FyZENvZGUgfSBmcm9tICdAZG5kLWtpdC9jb3JlJztcbmltcG9ydCB7IHVzZVVuaXF1ZUlkLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBDU1MsIHVzZUNvbWJpbmVkUmVmcywgaXNLZXlib2FyZEV2ZW50LCBzdWJ0cmFjdCB9IGZyb20gJ0BkbmQta2l0L3V0aWxpdGllcyc7XG5cbi8qKlxyXG4gKiBNb3ZlIGFuIGFycmF5IGl0ZW0gdG8gYSBkaWZmZXJlbnQgcG9zaXRpb24uIFJldHVybnMgYSBuZXcgYXJyYXkgd2l0aCB0aGUgaXRlbSBtb3ZlZCB0byB0aGUgbmV3IHBvc2l0aW9uLlxyXG4gKi9cbmZ1bmN0aW9uIGFycmF5TW92ZShhcnJheSwgZnJvbSwgdG8pIHtcbiAgY29uc3QgbmV3QXJyYXkgPSBhcnJheS5zbGljZSgpO1xuICBuZXdBcnJheS5zcGxpY2UodG8gPCAwID8gbmV3QXJyYXkubGVuZ3RoICsgdG8gOiB0bywgMCwgbmV3QXJyYXkuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcclxuICogU3dhcCBhbiBhcnJheSBpdGVtIHRvIGEgZGlmZmVyZW50IHBvc2l0aW9uLiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGl0ZW0gc3dhcHBlZCB0byB0aGUgbmV3IHBvc2l0aW9uLlxyXG4gKi9cbmZ1bmN0aW9uIGFycmF5U3dhcChhcnJheSwgZnJvbSwgdG8pIHtcbiAgY29uc3QgbmV3QXJyYXkgPSBhcnJheS5zbGljZSgpO1xuICBuZXdBcnJheVtmcm9tXSA9IGFycmF5W3RvXTtcbiAgbmV3QXJyYXlbdG9dID0gYXJyYXlbZnJvbV07XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ydGVkUmVjdHMoaXRlbXMsIHJlY3RzKSB7XG4gIHJldHVybiBpdGVtcy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBpZCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCByZWN0ID0gcmVjdHMuZ2V0KGlkKTtcblxuICAgIGlmIChyZWN0KSB7XG4gICAgICBhY2N1bXVsYXRvcltpbmRleF0gPSByZWN0O1xuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfSwgQXJyYXkoaXRlbXMubGVuZ3RoKSk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRJbmRleChpbmRleCkge1xuICByZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPj0gMDtcbn1cblxuZnVuY3Rpb24gaXRlbXNFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgaWYgKHR5cGVvZiBkaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYWdnYWJsZTogZGlzYWJsZWQsXG4gICAgICBkcm9wcGFibGU6IGRpc2FibGVkXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBkaXNhYmxlZDtcbn1cblxuLy8gVG8tZG86IFdlIHNob3VsZCBiZSBjYWxjdWxhdGluZyBzY2FsZSB0cmFuc2Zvcm1hdGlvblxuY29uc3QgZGVmYXVsdFNjYWxlID0ge1xuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmNvbnN0IGhvcml6b250YWxMaXN0U29ydGluZ1N0cmF0ZWd5ID0gX3JlZiA9PiB7XG4gIHZhciBfcmVjdHMkYWN0aXZlSW5kZXg7XG5cbiAgbGV0IHtcbiAgICByZWN0cyxcbiAgICBhY3RpdmVOb2RlUmVjdDogZmFsbGJhY2tBY3RpdmVSZWN0LFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleCxcbiAgICBpbmRleFxuICB9ID0gX3JlZjtcbiAgY29uc3QgYWN0aXZlTm9kZVJlY3QgPSAoX3JlY3RzJGFjdGl2ZUluZGV4ID0gcmVjdHNbYWN0aXZlSW5kZXhdKSAhPSBudWxsID8gX3JlY3RzJGFjdGl2ZUluZGV4IDogZmFsbGJhY2tBY3RpdmVSZWN0O1xuXG4gIGlmICghYWN0aXZlTm9kZVJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGl0ZW1HYXAgPSBnZXRJdGVtR2FwKHJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpO1xuXG4gIGlmIChpbmRleCA9PT0gYWN0aXZlSW5kZXgpIHtcbiAgICBjb25zdCBuZXdJbmRleFJlY3QgPSByZWN0c1tvdmVySW5kZXhdO1xuXG4gICAgaWYgKCFuZXdJbmRleFJlY3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiBhY3RpdmVJbmRleCA8IG92ZXJJbmRleCA/IG5ld0luZGV4UmVjdC5sZWZ0ICsgbmV3SW5kZXhSZWN0LndpZHRoIC0gKGFjdGl2ZU5vZGVSZWN0LmxlZnQgKyBhY3RpdmVOb2RlUmVjdC53aWR0aCkgOiBuZXdJbmRleFJlY3QubGVmdCAtIGFjdGl2ZU5vZGVSZWN0LmxlZnQsXG4gICAgICB5OiAwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpbmRleCA+IGFjdGl2ZUluZGV4ICYmIGluZGV4IDw9IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAtYWN0aXZlTm9kZVJlY3Qud2lkdGggLSBpdGVtR2FwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZVxuICAgIH07XG4gIH1cblxuICBpZiAoaW5kZXggPCBhY3RpdmVJbmRleCAmJiBpbmRleCA+PSBvdmVySW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYWN0aXZlTm9kZVJlY3Qud2lkdGggKyBpdGVtR2FwLFxuICAgICAgeTogMCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICAuLi5kZWZhdWx0U2NhbGVcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEl0ZW1HYXAocmVjdHMsIGluZGV4LCBhY3RpdmVJbmRleCkge1xuICBjb25zdCBjdXJyZW50UmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgY29uc3QgcHJldmlvdXNSZWN0ID0gcmVjdHNbaW5kZXggLSAxXTtcbiAgY29uc3QgbmV4dFJlY3QgPSByZWN0c1tpbmRleCArIDFdO1xuXG4gIGlmICghY3VycmVudFJlY3QgfHwgIXByZXZpb3VzUmVjdCAmJiAhbmV4dFJlY3QpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhY3RpdmVJbmRleCA8IGluZGV4KSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVjdCA/IGN1cnJlbnRSZWN0LmxlZnQgLSAocHJldmlvdXNSZWN0LmxlZnQgKyBwcmV2aW91c1JlY3Qud2lkdGgpIDogbmV4dFJlY3QubGVmdCAtIChjdXJyZW50UmVjdC5sZWZ0ICsgY3VycmVudFJlY3Qud2lkdGgpO1xuICB9XG5cbiAgcmV0dXJuIG5leHRSZWN0ID8gbmV4dFJlY3QubGVmdCAtIChjdXJyZW50UmVjdC5sZWZ0ICsgY3VycmVudFJlY3Qud2lkdGgpIDogY3VycmVudFJlY3QubGVmdCAtIChwcmV2aW91c1JlY3QubGVmdCArIHByZXZpb3VzUmVjdC53aWR0aCk7XG59XG5cbmNvbnN0IHJlY3RTb3J0aW5nU3RyYXRlZ3kgPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICByZWN0cyxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXgsXG4gICAgaW5kZXhcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IG5ld1JlY3RzID0gYXJyYXlNb3ZlKHJlY3RzLCBvdmVySW5kZXgsIGFjdGl2ZUluZGV4KTtcbiAgY29uc3Qgb2xkUmVjdCA9IHJlY3RzW2luZGV4XTtcbiAgY29uc3QgbmV3UmVjdCA9IG5ld1JlY3RzW2luZGV4XTtcblxuICBpZiAoIW5ld1JlY3QgfHwgIW9sZFJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogbmV3UmVjdC5sZWZ0IC0gb2xkUmVjdC5sZWZ0LFxuICAgIHk6IG5ld1JlY3QudG9wIC0gb2xkUmVjdC50b3AsXG4gICAgc2NhbGVYOiBuZXdSZWN0LndpZHRoIC8gb2xkUmVjdC53aWR0aCxcbiAgICBzY2FsZVk6IG5ld1JlY3QuaGVpZ2h0IC8gb2xkUmVjdC5oZWlnaHRcbiAgfTtcbn07XG5cbmNvbnN0IHJlY3RTd2FwcGluZ1N0cmF0ZWd5ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgaW5kZXgsXG4gICAgcmVjdHMsXG4gICAgb3ZlckluZGV4XG4gIH0gPSBfcmVmO1xuICBsZXQgb2xkUmVjdDtcbiAgbGV0IG5ld1JlY3Q7XG5cbiAgaWYgKGluZGV4ID09PSBhY3RpdmVJbmRleCkge1xuICAgIG9sZFJlY3QgPSByZWN0c1tpbmRleF07XG4gICAgbmV3UmVjdCA9IHJlY3RzW292ZXJJbmRleF07XG4gIH1cblxuICBpZiAoaW5kZXggPT09IG92ZXJJbmRleCkge1xuICAgIG9sZFJlY3QgPSByZWN0c1tpbmRleF07XG4gICAgbmV3UmVjdCA9IHJlY3RzW2FjdGl2ZUluZGV4XTtcbiAgfVxuXG4gIGlmICghbmV3UmVjdCB8fCAhb2xkUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBuZXdSZWN0LmxlZnQgLSBvbGRSZWN0LmxlZnQsXG4gICAgeTogbmV3UmVjdC50b3AgLSBvbGRSZWN0LnRvcCxcbiAgICBzY2FsZVg6IG5ld1JlY3Qud2lkdGggLyBvbGRSZWN0LndpZHRoLFxuICAgIHNjYWxlWTogbmV3UmVjdC5oZWlnaHQgLyBvbGRSZWN0LmhlaWdodFxuICB9O1xufTtcblxuLy8gVG8tZG86IFdlIHNob3VsZCBiZSBjYWxjdWxhdGluZyBzY2FsZSB0cmFuc2Zvcm1hdGlvblxuY29uc3QgZGVmYXVsdFNjYWxlJDEgPSB7XG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuY29uc3QgdmVydGljYWxMaXN0U29ydGluZ1N0cmF0ZWd5ID0gX3JlZiA9PiB7XG4gIHZhciBfcmVjdHMkYWN0aXZlSW5kZXg7XG5cbiAgbGV0IHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBhY3RpdmVOb2RlUmVjdDogZmFsbGJhY2tBY3RpdmVSZWN0LFxuICAgIGluZGV4LFxuICAgIHJlY3RzLFxuICAgIG92ZXJJbmRleFxuICB9ID0gX3JlZjtcbiAgY29uc3QgYWN0aXZlTm9kZVJlY3QgPSAoX3JlY3RzJGFjdGl2ZUluZGV4ID0gcmVjdHNbYWN0aXZlSW5kZXhdKSAhPSBudWxsID8gX3JlY3RzJGFjdGl2ZUluZGV4IDogZmFsbGJhY2tBY3RpdmVSZWN0O1xuXG4gIGlmICghYWN0aXZlTm9kZVJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gYWN0aXZlSW5kZXgpIHtcbiAgICBjb25zdCBvdmVySW5kZXhSZWN0ID0gcmVjdHNbb3ZlckluZGV4XTtcblxuICAgIGlmICghb3ZlckluZGV4UmVjdCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiBhY3RpdmVJbmRleCA8IG92ZXJJbmRleCA/IG92ZXJJbmRleFJlY3QudG9wICsgb3ZlckluZGV4UmVjdC5oZWlnaHQgLSAoYWN0aXZlTm9kZVJlY3QudG9wICsgYWN0aXZlTm9kZVJlY3QuaGVpZ2h0KSA6IG92ZXJJbmRleFJlY3QudG9wIC0gYWN0aXZlTm9kZVJlY3QudG9wLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlJDFcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaXRlbUdhcCA9IGdldEl0ZW1HYXAkMShyZWN0cywgaW5kZXgsIGFjdGl2ZUluZGV4KTtcblxuICBpZiAoaW5kZXggPiBhY3RpdmVJbmRleCAmJiBpbmRleCA8PSBvdmVySW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IC1hY3RpdmVOb2RlUmVjdC5oZWlnaHQgLSBpdGVtR2FwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlJDFcbiAgICB9O1xuICB9XG5cbiAgaWYgKGluZGV4IDwgYWN0aXZlSW5kZXggJiYgaW5kZXggPj0gb3ZlckluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiBhY3RpdmVOb2RlUmVjdC5oZWlnaHQgKyBpdGVtR2FwLFxuICAgICAgLi4uZGVmYXVsdFNjYWxlJDFcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgLi4uZGVmYXVsdFNjYWxlJDFcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEl0ZW1HYXAkMShjbGllbnRSZWN0cywgaW5kZXgsIGFjdGl2ZUluZGV4KSB7XG4gIGNvbnN0IGN1cnJlbnRSZWN0ID0gY2xpZW50UmVjdHNbaW5kZXhdO1xuICBjb25zdCBwcmV2aW91c1JlY3QgPSBjbGllbnRSZWN0c1tpbmRleCAtIDFdO1xuICBjb25zdCBuZXh0UmVjdCA9IGNsaWVudFJlY3RzW2luZGV4ICsgMV07XG5cbiAgaWYgKCFjdXJyZW50UmVjdCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFjdGl2ZUluZGV4IDwgaW5kZXgpIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWN0ID8gY3VycmVudFJlY3QudG9wIC0gKHByZXZpb3VzUmVjdC50b3AgKyBwcmV2aW91c1JlY3QuaGVpZ2h0KSA6IG5leHRSZWN0ID8gbmV4dFJlY3QudG9wIC0gKGN1cnJlbnRSZWN0LnRvcCArIGN1cnJlbnRSZWN0LmhlaWdodCkgOiAwO1xuICB9XG5cbiAgcmV0dXJuIG5leHRSZWN0ID8gbmV4dFJlY3QudG9wIC0gKGN1cnJlbnRSZWN0LnRvcCArIGN1cnJlbnRSZWN0LmhlaWdodCkgOiBwcmV2aW91c1JlY3QgPyBjdXJyZW50UmVjdC50b3AgLSAocHJldmlvdXNSZWN0LnRvcCArIHByZXZpb3VzUmVjdC5oZWlnaHQpIDogMDtcbn1cblxuY29uc3QgSURfUFJFRklYID0gJ1NvcnRhYmxlJztcbmNvbnN0IENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGFjdGl2ZUluZGV4OiAtMSxcbiAgY29udGFpbmVySWQ6IElEX1BSRUZJWCxcbiAgZGlzYWJsZVRyYW5zZm9ybXM6IGZhbHNlLFxuICBpdGVtczogW10sXG4gIG92ZXJJbmRleDogLTEsXG4gIHVzZURyYWdPdmVybGF5OiBmYWxzZSxcbiAgc29ydGVkUmVjdHM6IFtdLFxuICBzdHJhdGVneTogcmVjdFNvcnRpbmdTdHJhdGVneSxcbiAgZGlzYWJsZWQ6IHtcbiAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgIGRyb3BwYWJsZTogZmFsc2VcbiAgfVxufSk7XG5mdW5jdGlvbiBTb3J0YWJsZUNvbnRleHQoX3JlZikge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkLFxuICAgIGl0ZW1zOiB1c2VyRGVmaW5lZEl0ZW1zLFxuICAgIHN0cmF0ZWd5ID0gcmVjdFNvcnRpbmdTdHJhdGVneSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWRQcm9wID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUsXG4gICAgZHJhZ092ZXJsYXksXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgb3ZlcixcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gdXNlRG5kQ29udGV4dCgpO1xuICBjb25zdCBjb250YWluZXJJZCA9IHVzZVVuaXF1ZUlkKElEX1BSRUZJWCwgaWQpO1xuICBjb25zdCB1c2VEcmFnT3ZlcmxheSA9IEJvb2xlYW4oZHJhZ092ZXJsYXkucmVjdCAhPT0gbnVsbCk7XG4gIGNvbnN0IGl0ZW1zID0gdXNlTWVtbygoKSA9PiB1c2VyRGVmaW5lZEl0ZW1zLm1hcChpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAnaWQnIGluIGl0ZW0gPyBpdGVtLmlkIDogaXRlbSksIFt1c2VyRGVmaW5lZEl0ZW1zXSk7XG4gIGNvbnN0IGlzRHJhZ2dpbmcgPSBhY3RpdmUgIT0gbnVsbDtcbiAgY29uc3QgYWN0aXZlSW5kZXggPSBhY3RpdmUgPyBpdGVtcy5pbmRleE9mKGFjdGl2ZS5pZCkgOiAtMTtcbiAgY29uc3Qgb3ZlckluZGV4ID0gb3ZlciA/IGl0ZW1zLmluZGV4T2Yob3Zlci5pZCkgOiAtMTtcbiAgY29uc3QgcHJldmlvdXNJdGVtc1JlZiA9IHVzZVJlZihpdGVtcyk7XG4gIGNvbnN0IGl0ZW1zSGF2ZUNoYW5nZWQgPSAhaXRlbXNFcXVhbChpdGVtcywgcHJldmlvdXNJdGVtc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgZGlzYWJsZVRyYW5zZm9ybXMgPSBvdmVySW5kZXggIT09IC0xICYmIGFjdGl2ZUluZGV4ID09PSAtMSB8fCBpdGVtc0hhdmVDaGFuZ2VkO1xuICBjb25zdCBkaXNhYmxlZCA9IG5vcm1hbGl6ZURpc2FibGVkKGRpc2FibGVkUHJvcCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpdGVtc0hhdmVDaGFuZ2VkICYmIGlzRHJhZ2dpbmcpIHtcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKGl0ZW1zKTtcbiAgICB9XG4gIH0sIFtpdGVtc0hhdmVDaGFuZ2VkLCBpdGVtcywgaXNEcmFnZ2luZywgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBwcmV2aW91c0l0ZW1zUmVmLmN1cnJlbnQgPSBpdGVtcztcbiAgfSwgW2l0ZW1zXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBhY3RpdmVJbmRleCxcbiAgICBjb250YWluZXJJZCxcbiAgICBkaXNhYmxlZCxcbiAgICBkaXNhYmxlVHJhbnNmb3JtcyxcbiAgICBpdGVtcyxcbiAgICBvdmVySW5kZXgsXG4gICAgdXNlRHJhZ092ZXJsYXksXG4gICAgc29ydGVkUmVjdHM6IGdldFNvcnRlZFJlY3RzKGl0ZW1zLCBkcm9wcGFibGVSZWN0cyksXG4gICAgc3RyYXRlZ3lcbiAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2FjdGl2ZUluZGV4LCBjb250YWluZXJJZCwgZGlzYWJsZWQuZHJhZ2dhYmxlLCBkaXNhYmxlZC5kcm9wcGFibGUsIGRpc2FibGVUcmFuc2Zvcm1zLCBpdGVtcywgb3ZlckluZGV4LCBkcm9wcGFibGVSZWN0cywgdXNlRHJhZ092ZXJsYXksIHN0cmF0ZWd5XSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuY29uc3QgZGVmYXVsdE5ld0luZGV4R2V0dGVyID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgaXRlbXMsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4XG4gIH0gPSBfcmVmO1xuICByZXR1cm4gYXJyYXlNb3ZlKGl0ZW1zLCBhY3RpdmVJbmRleCwgb3ZlckluZGV4KS5pbmRleE9mKGlkKTtcbn07XG5jb25zdCBkZWZhdWx0QW5pbWF0ZUxheW91dENoYW5nZXMgPSBfcmVmMiA9PiB7XG4gIGxldCB7XG4gICAgY29udGFpbmVySWQsXG4gICAgaXNTb3J0aW5nLFxuICAgIHdhc0RyYWdnaW5nLFxuICAgIGluZGV4LFxuICAgIGl0ZW1zLFxuICAgIG5ld0luZGV4LFxuICAgIHByZXZpb3VzSXRlbXMsXG4gICAgcHJldmlvdXNDb250YWluZXJJZCxcbiAgICB0cmFuc2l0aW9uXG4gIH0gPSBfcmVmMjtcblxuICBpZiAoIXRyYW5zaXRpb24gfHwgIXdhc0RyYWdnaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByZXZpb3VzSXRlbXMgIT09IGl0ZW1zICYmIGluZGV4ID09PSBuZXdJbmRleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1NvcnRpbmcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXdJbmRleCAhPT0gaW5kZXggJiYgY29udGFpbmVySWQgPT09IHByZXZpb3VzQ29udGFpbmVySWQ7XG59O1xuY29uc3QgZGVmYXVsdFRyYW5zaXRpb24gPSB7XG4gIGR1cmF0aW9uOiAyMDAsXG4gIGVhc2luZzogJ2Vhc2UnXG59O1xuY29uc3QgdHJhbnNpdGlvblByb3BlcnR5ID0gJ3RyYW5zZm9ybSc7XG5jb25zdCBkaXNhYmxlZFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovQ1NTLlRyYW5zaXRpb24udG9TdHJpbmcoe1xuICBwcm9wZXJ0eTogdHJhbnNpdGlvblByb3BlcnR5LFxuICBkdXJhdGlvbjogMCxcbiAgZWFzaW5nOiAnbGluZWFyJ1xufSk7XG5jb25zdCBkZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgcm9sZURlc2NyaXB0aW9uOiAnc29ydGFibGUnXG59O1xuXG4vKlxyXG4gKiBXaGVuIHRoZSBpbmRleCBvZiBhbiBpdGVtIGNoYW5nZXMgd2hpbGUgc29ydGluZyxcclxuICogd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBkaXNhYmxlIHRoZSB0cmFuc2Zvcm1zXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VEZXJpdmVkVHJhbnNmb3JtKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkaXNhYmxlZCxcbiAgICBpbmRleCxcbiAgICBub2RlLFxuICAgIHJlY3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtkZXJpdmVkVHJhbnNmb3JtLCBzZXREZXJpdmVkdHJhbnNmb3JtXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBwcmV2aW91c0luZGV4ID0gdXNlUmVmKGluZGV4KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkaXNhYmxlZCAmJiBpbmRleCAhPT0gcHJldmlvdXNJbmRleC5jdXJyZW50ICYmIG5vZGUuY3VycmVudCkge1xuICAgICAgY29uc3QgaW5pdGlhbCA9IHJlY3QuY3VycmVudDtcblxuICAgICAgaWYgKGluaXRpYWwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGdldENsaWVudFJlY3Qobm9kZS5jdXJyZW50LCB7XG4gICAgICAgICAgaWdub3JlVHJhbnNmb3JtOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHtcbiAgICAgICAgICB4OiBpbml0aWFsLmxlZnQgLSBjdXJyZW50LmxlZnQsXG4gICAgICAgICAgeTogaW5pdGlhbC50b3AgLSBjdXJyZW50LnRvcCxcbiAgICAgICAgICBzY2FsZVg6IGluaXRpYWwud2lkdGggLyBjdXJyZW50LndpZHRoLFxuICAgICAgICAgIHNjYWxlWTogaW5pdGlhbC5oZWlnaHQgLyBjdXJyZW50LmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkZWx0YS54IHx8IGRlbHRhLnkpIHtcbiAgICAgICAgICBzZXREZXJpdmVkdHJhbnNmb3JtKGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbmRleCAhPT0gcHJldmlvdXNJbmRleC5jdXJyZW50KSB7XG4gICAgICBwcmV2aW91c0luZGV4LmN1cnJlbnQgPSBpbmRleDtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgaW5kZXgsIG5vZGUsIHJlY3RdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGVyaXZlZFRyYW5zZm9ybSkge1xuICAgICAgc2V0RGVyaXZlZHRyYW5zZm9ybShudWxsKTtcbiAgICB9XG4gIH0sIFtkZXJpdmVkVHJhbnNmb3JtXSk7XG4gIHJldHVybiBkZXJpdmVkVHJhbnNmb3JtO1xufVxuXG5mdW5jdGlvbiB1c2VTb3J0YWJsZShfcmVmKSB7XG4gIGxldCB7XG4gICAgYW5pbWF0ZUxheW91dENoYW5nZXMgPSBkZWZhdWx0QW5pbWF0ZUxheW91dENoYW5nZXMsXG4gICAgYXR0cmlidXRlczogdXNlckRlZmluZWRBdHRyaWJ1dGVzLFxuICAgIGRpc2FibGVkOiBsb2NhbERpc2FibGVkLFxuICAgIGRhdGE6IGN1c3RvbURhdGEsXG4gICAgZ2V0TmV3SW5kZXggPSBkZWZhdWx0TmV3SW5kZXhHZXR0ZXIsXG4gICAgaWQsXG4gICAgc3RyYXRlZ3k6IGxvY2FsU3RyYXRlZ3ksXG4gICAgcmVzaXplT2JzZXJ2ZXJDb25maWcsXG4gICAgdHJhbnNpdGlvbiA9IGRlZmF1bHRUcmFuc2l0aW9uXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgaXRlbXMsXG4gICAgY29udGFpbmVySWQsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgZGlzYWJsZWQ6IGdsb2JhbERpc2FibGVkLFxuICAgIGRpc2FibGVUcmFuc2Zvcm1zLFxuICAgIHNvcnRlZFJlY3RzLFxuICAgIG92ZXJJbmRleCxcbiAgICB1c2VEcmFnT3ZlcmxheSxcbiAgICBzdHJhdGVneTogZ2xvYmFsU3RyYXRlZ3lcbiAgfSA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gIGNvbnN0IGRpc2FibGVkID0gbm9ybWFsaXplTG9jYWxEaXNhYmxlZChsb2NhbERpc2FibGVkLCBnbG9iYWxEaXNhYmxlZCk7XG4gIGNvbnN0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihpZCk7XG4gIGNvbnN0IGRhdGEgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgc29ydGFibGU6IHtcbiAgICAgIGNvbnRhaW5lcklkLFxuICAgICAgaW5kZXgsXG4gICAgICBpdGVtc1xuICAgIH0sXG4gICAgLi4uY3VzdG9tRGF0YVxuICB9KSwgW2NvbnRhaW5lcklkLCBjdXN0b21EYXRhLCBpbmRleCwgaXRlbXNdKTtcbiAgY29uc3QgaXRlbXNBZnRlckN1cnJlbnRTb3J0YWJsZSA9IHVzZU1lbW8oKCkgPT4gaXRlbXMuc2xpY2UoaXRlbXMuaW5kZXhPZihpZCkpLCBbaXRlbXMsIGlkXSk7XG4gIGNvbnN0IHtcbiAgICByZWN0LFxuICAgIG5vZGUsXG4gICAgaXNPdmVyLFxuICAgIHNldE5vZGVSZWY6IHNldERyb3BwYWJsZU5vZGVSZWZcbiAgfSA9IHVzZURyb3BwYWJsZSh7XG4gICAgaWQsXG4gICAgZGF0YSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQuZHJvcHBhYmxlLFxuICAgIHJlc2l6ZU9ic2VydmVyQ29uZmlnOiB7XG4gICAgICB1cGRhdGVNZWFzdXJlbWVudHNGb3I6IGl0ZW1zQWZ0ZXJDdXJyZW50U29ydGFibGUsXG4gICAgICAuLi5yZXNpemVPYnNlcnZlckNvbmZpZ1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYXR0cmlidXRlcyxcbiAgICBzZXROb2RlUmVmOiBzZXREcmFnZ2FibGVOb2RlUmVmLFxuICAgIGxpc3RlbmVycyxcbiAgICBpc0RyYWdnaW5nLFxuICAgIG92ZXIsXG4gICAgc2V0QWN0aXZhdG9yTm9kZVJlZixcbiAgICB0cmFuc2Zvcm1cbiAgfSA9IHVzZURyYWdnYWJsZSh7XG4gICAgaWQsXG4gICAgZGF0YSxcbiAgICBhdHRyaWJ1dGVzOiB7IC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgLi4udXNlckRlZmluZWRBdHRyaWJ1dGVzXG4gICAgfSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWQuZHJhZ2dhYmxlXG4gIH0pO1xuICBjb25zdCBzZXROb2RlUmVmID0gdXNlQ29tYmluZWRSZWZzKHNldERyb3BwYWJsZU5vZGVSZWYsIHNldERyYWdnYWJsZU5vZGVSZWYpO1xuICBjb25zdCBpc1NvcnRpbmcgPSBCb29sZWFuKGFjdGl2ZSk7XG4gIGNvbnN0IGRpc3BsYWNlSXRlbSA9IGlzU29ydGluZyAmJiAhZGlzYWJsZVRyYW5zZm9ybXMgJiYgaXNWYWxpZEluZGV4KGFjdGl2ZUluZGV4KSAmJiBpc1ZhbGlkSW5kZXgob3ZlckluZGV4KTtcbiAgY29uc3Qgc2hvdWxkRGlzcGxhY2VEcmFnU291cmNlID0gIXVzZURyYWdPdmVybGF5ICYmIGlzRHJhZ2dpbmc7XG4gIGNvbnN0IGRyYWdTb3VyY2VEaXNwbGFjZW1lbnQgPSBzaG91bGREaXNwbGFjZURyYWdTb3VyY2UgJiYgZGlzcGxhY2VJdGVtID8gdHJhbnNmb3JtIDogbnVsbDtcbiAgY29uc3Qgc3RyYXRlZ3kgPSBsb2NhbFN0cmF0ZWd5ICE9IG51bGwgPyBsb2NhbFN0cmF0ZWd5IDogZ2xvYmFsU3RyYXRlZ3k7XG4gIGNvbnN0IGZpbmFsVHJhbnNmb3JtID0gZGlzcGxhY2VJdGVtID8gZHJhZ1NvdXJjZURpc3BsYWNlbWVudCAhPSBudWxsID8gZHJhZ1NvdXJjZURpc3BsYWNlbWVudCA6IHN0cmF0ZWd5KHtcbiAgICByZWN0czogc29ydGVkUmVjdHMsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4LFxuICAgIGluZGV4XG4gIH0pIDogbnVsbDtcbiAgY29uc3QgbmV3SW5kZXggPSBpc1ZhbGlkSW5kZXgoYWN0aXZlSW5kZXgpICYmIGlzVmFsaWRJbmRleChvdmVySW5kZXgpID8gZ2V0TmV3SW5kZXgoe1xuICAgIGlkLFxuICAgIGl0ZW1zLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleFxuICB9KSA6IGluZGV4O1xuICBjb25zdCBhY3RpdmVJZCA9IGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmlkO1xuICBjb25zdCBwcmV2aW91cyA9IHVzZVJlZih7XG4gICAgYWN0aXZlSWQsXG4gICAgaXRlbXMsXG4gICAgbmV3SW5kZXgsXG4gICAgY29udGFpbmVySWRcbiAgfSk7XG4gIGNvbnN0IGl0ZW1zSGF2ZUNoYW5nZWQgPSBpdGVtcyAhPT0gcHJldmlvdXMuY3VycmVudC5pdGVtcztcbiAgY29uc3Qgc2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMgPSBhbmltYXRlTGF5b3V0Q2hhbmdlcyh7XG4gICAgYWN0aXZlLFxuICAgIGNvbnRhaW5lcklkLFxuICAgIGlzRHJhZ2dpbmcsXG4gICAgaXNTb3J0aW5nLFxuICAgIGlkLFxuICAgIGluZGV4LFxuICAgIGl0ZW1zLFxuICAgIG5ld0luZGV4OiBwcmV2aW91cy5jdXJyZW50Lm5ld0luZGV4LFxuICAgIHByZXZpb3VzSXRlbXM6IHByZXZpb3VzLmN1cnJlbnQuaXRlbXMsXG4gICAgcHJldmlvdXNDb250YWluZXJJZDogcHJldmlvdXMuY3VycmVudC5jb250YWluZXJJZCxcbiAgICB0cmFuc2l0aW9uLFxuICAgIHdhc0RyYWdnaW5nOiBwcmV2aW91cy5jdXJyZW50LmFjdGl2ZUlkICE9IG51bGxcbiAgfSk7XG4gIGNvbnN0IGRlcml2ZWRUcmFuc2Zvcm0gPSB1c2VEZXJpdmVkVHJhbnNmb3JtKHtcbiAgICBkaXNhYmxlZDogIXNob3VsZEFuaW1hdGVMYXlvdXRDaGFuZ2VzLFxuICAgIGluZGV4LFxuICAgIG5vZGUsXG4gICAgcmVjdFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNTb3J0aW5nICYmIHByZXZpb3VzLmN1cnJlbnQubmV3SW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICBwcmV2aW91cy5jdXJyZW50Lm5ld0luZGV4ID0gbmV3SW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lcklkICE9PSBwcmV2aW91cy5jdXJyZW50LmNvbnRhaW5lcklkKSB7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmNvbnRhaW5lcklkID0gY29udGFpbmVySWQ7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1zICE9PSBwcmV2aW91cy5jdXJyZW50Lml0ZW1zKSB7XG4gICAgICBwcmV2aW91cy5jdXJyZW50Lml0ZW1zID0gaXRlbXM7XG4gICAgfVxuICB9LCBbaXNTb3J0aW5nLCBuZXdJbmRleCwgY29udGFpbmVySWQsIGl0ZW1zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZUlkID09PSBwcmV2aW91cy5jdXJyZW50LmFjdGl2ZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUlkICYmICFwcmV2aW91cy5jdXJyZW50LmFjdGl2ZUlkKSB7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmFjdGl2ZUlkID0gYWN0aXZlSWQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBwcmV2aW91cy5jdXJyZW50LmFjdGl2ZUlkID0gYWN0aXZlSWQ7XG4gICAgfSwgNTApO1xuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgfSwgW2FjdGl2ZUlkXSk7XG4gIHJldHVybiB7XG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgZGF0YSxcbiAgICByZWN0LFxuICAgIGluZGV4LFxuICAgIG5ld0luZGV4LFxuICAgIGl0ZW1zLFxuICAgIGlzT3ZlcixcbiAgICBpc1NvcnRpbmcsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBsaXN0ZW5lcnMsXG4gICAgbm9kZSxcbiAgICBvdmVySW5kZXgsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmLFxuICAgIHNldEFjdGl2YXRvck5vZGVSZWYsXG4gICAgc2V0RHJvcHBhYmxlTm9kZVJlZixcbiAgICBzZXREcmFnZ2FibGVOb2RlUmVmLFxuICAgIHRyYW5zZm9ybTogZGVyaXZlZFRyYW5zZm9ybSAhPSBudWxsID8gZGVyaXZlZFRyYW5zZm9ybSA6IGZpbmFsVHJhbnNmb3JtLFxuICAgIHRyYW5zaXRpb246IGdldFRyYW5zaXRpb24oKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRyYW5zaXRpb24oKSB7XG4gICAgaWYgKCAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zIGZvciBhIHNpbmdsZSBmcmFtZSB0byBzZXQgdXAgZGVyaXZlZCB0cmFuc2Zvcm1zXG4gICAgZGVyaXZlZFRyYW5zZm9ybSB8fCAvLyBPciB0byBwcmV2ZW50IGl0ZW1zIGp1bXBpbmcgdG8gYmFjayB0byB0aGVpciBcIm5ld1wiIHBvc2l0aW9uIHdoZW4gaXRlbXMgY2hhbmdlXG4gICAgaXRlbXNIYXZlQ2hhbmdlZCAmJiBwcmV2aW91cy5jdXJyZW50Lm5ld0luZGV4ID09PSBpbmRleCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkVHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkRGlzcGxhY2VEcmFnU291cmNlICYmICFpc0tleWJvYXJkRXZlbnQoYWN0aXZhdG9yRXZlbnQpIHx8ICF0cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChpc1NvcnRpbmcgfHwgc2hvdWxkQW5pbWF0ZUxheW91dENoYW5nZXMpIHtcbiAgICAgIHJldHVybiBDU1MuVHJhbnNpdGlvbi50b1N0cmluZyh7IC4uLnRyYW5zaXRpb24sXG4gICAgICAgIHByb3BlcnR5OiB0cmFuc2l0aW9uUHJvcGVydHlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxEaXNhYmxlZChsb2NhbERpc2FibGVkLCBnbG9iYWxEaXNhYmxlZCkge1xuICB2YXIgX2xvY2FsRGlzYWJsZWQkZHJhZ2dhLCBfbG9jYWxEaXNhYmxlZCRkcm9wcGE7XG5cbiAgaWYgKHR5cGVvZiBsb2NhbERpc2FibGVkID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhZ2dhYmxlOiBsb2NhbERpc2FibGVkLFxuICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIGRyb3BwYWJsZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IChfbG9jYWxEaXNhYmxlZCRkcmFnZ2EgPSBsb2NhbERpc2FibGVkID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbERpc2FibGVkLmRyYWdnYWJsZSkgIT0gbnVsbCA/IF9sb2NhbERpc2FibGVkJGRyYWdnYSA6IGdsb2JhbERpc2FibGVkLmRyYWdnYWJsZSxcbiAgICBkcm9wcGFibGU6IChfbG9jYWxEaXNhYmxlZCRkcm9wcGEgPSBsb2NhbERpc2FibGVkID09IG51bGwgPyB2b2lkIDAgOiBsb2NhbERpc2FibGVkLmRyb3BwYWJsZSkgIT0gbnVsbCA/IF9sb2NhbERpc2FibGVkJGRyb3BwYSA6IGdsb2JhbERpc2FibGVkLmRyb3BwYWJsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBoYXNTb3J0YWJsZURhdGEoZW50cnkpIHtcbiAgaWYgKCFlbnRyeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBlbnRyeS5kYXRhLmN1cnJlbnQ7XG5cbiAgaWYgKGRhdGEgJiYgJ3NvcnRhYmxlJyBpbiBkYXRhICYmIHR5cGVvZiBkYXRhLnNvcnRhYmxlID09PSAnb2JqZWN0JyAmJiAnY29udGFpbmVySWQnIGluIGRhdGEuc29ydGFibGUgJiYgJ2l0ZW1zJyBpbiBkYXRhLnNvcnRhYmxlICYmICdpbmRleCcgaW4gZGF0YS5zb3J0YWJsZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBkaXJlY3Rpb25zID0gW0tleWJvYXJkQ29kZS5Eb3duLCBLZXlib2FyZENvZGUuUmlnaHQsIEtleWJvYXJkQ29kZS5VcCwgS2V5Ym9hcmRDb2RlLkxlZnRdO1xuY29uc3Qgc29ydGFibGVLZXlib2FyZENvb3JkaW5hdGVzID0gKGV2ZW50LCBfcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgY29udGV4dDoge1xuICAgICAgYWN0aXZlLFxuICAgICAgY29sbGlzaW9uUmVjdCxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIG92ZXIsXG4gICAgICBzY3JvbGxhYmxlQW5jZXN0b3JzXG4gICAgfVxuICB9ID0gX3JlZjtcblxuICBpZiAoZGlyZWN0aW9ucy5pbmNsdWRlcyhldmVudC5jb2RlKSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAoIWFjdGl2ZSB8fCAhY29sbGlzaW9uUmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbHRlcmVkQ29udGFpbmVycyA9IFtdO1xuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0RW5hYmxlZCgpLmZvckVhY2goZW50cnkgPT4ge1xuICAgICAgaWYgKCFlbnRyeSB8fCBlbnRyeSAhPSBudWxsICYmIGVudHJ5LmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChlbnRyeS5pZCk7XG5cbiAgICAgIGlmICghcmVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZXZlbnQuY29kZSkge1xuICAgICAgICBjYXNlIEtleWJvYXJkQ29kZS5Eb3duOlxuICAgICAgICAgIGlmIChjb2xsaXNpb25SZWN0LnRvcCA8IHJlY3QudG9wKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvbnRhaW5lcnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBLZXlib2FyZENvZGUuVXA6XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QudG9wID4gcmVjdC50b3ApIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEtleWJvYXJkQ29kZS5MZWZ0OlxuICAgICAgICAgIGlmIChjb2xsaXNpb25SZWN0LmxlZnQgPiByZWN0LmxlZnQpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkQ29udGFpbmVycy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEtleWJvYXJkQ29kZS5SaWdodDpcbiAgICAgICAgICBpZiAoY29sbGlzaW9uUmVjdC5sZWZ0IDwgcmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvbnRhaW5lcnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY29sbGlzaW9ucyA9IGNsb3Nlc3RDb3JuZXJzKHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGNvbGxpc2lvblJlY3Q6IGNvbGxpc2lvblJlY3QsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnM6IGZpbHRlcmVkQ29udGFpbmVycyxcbiAgICAgIHBvaW50ZXJDb29yZGluYXRlczogbnVsbFxuICAgIH0pO1xuICAgIGxldCBjbG9zZXN0SWQgPSBnZXRGaXJzdENvbGxpc2lvbihjb2xsaXNpb25zLCAnaWQnKTtcblxuICAgIGlmIChjbG9zZXN0SWQgPT09IChvdmVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVyLmlkKSAmJiBjb2xsaXNpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNsb3Nlc3RJZCA9IGNvbGxpc2lvbnNbMV0uaWQ7XG4gICAgfVxuXG4gICAgaWYgKGNsb3Nlc3RJZCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhY3RpdmVEcm9wcGFibGUgPSBkcm9wcGFibGVDb250YWluZXJzLmdldChhY3RpdmUuaWQpO1xuICAgICAgY29uc3QgbmV3RHJvcHBhYmxlID0gZHJvcHBhYmxlQ29udGFpbmVycy5nZXQoY2xvc2VzdElkKTtcbiAgICAgIGNvbnN0IG5ld1JlY3QgPSBuZXdEcm9wcGFibGUgPyBkcm9wcGFibGVSZWN0cy5nZXQobmV3RHJvcHBhYmxlLmlkKSA6IG51bGw7XG4gICAgICBjb25zdCBuZXdOb2RlID0gbmV3RHJvcHBhYmxlID09IG51bGwgPyB2b2lkIDAgOiBuZXdEcm9wcGFibGUubm9kZS5jdXJyZW50O1xuXG4gICAgICBpZiAobmV3Tm9kZSAmJiBuZXdSZWN0ICYmIGFjdGl2ZURyb3BwYWJsZSAmJiBuZXdEcm9wcGFibGUpIHtcbiAgICAgICAgY29uc3QgbmV3U2Nyb2xsQW5jZXN0b3JzID0gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhuZXdOb2RlKTtcbiAgICAgICAgY29uc3QgaGFzRGlmZmVyZW50U2Nyb2xsQW5jZXN0b3JzID0gbmV3U2Nyb2xsQW5jZXN0b3JzLnNvbWUoKGVsZW1lbnQsIGluZGV4KSA9PiBzY3JvbGxhYmxlQW5jZXN0b3JzW2luZGV4XSAhPT0gZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGhhc1NhbWVDb250YWluZXIgPSBpc1NhbWVDb250YWluZXIoYWN0aXZlRHJvcHBhYmxlLCBuZXdEcm9wcGFibGUpO1xuICAgICAgICBjb25zdCBpc0FmdGVyQWN0aXZlID0gaXNBZnRlcihhY3RpdmVEcm9wcGFibGUsIG5ld0Ryb3BwYWJsZSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGhhc0RpZmZlcmVudFNjcm9sbEFuY2VzdG9ycyB8fCAhaGFzU2FtZUNvbnRhaW5lciA/IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB4OiBpc0FmdGVyQWN0aXZlID8gY29sbGlzaW9uUmVjdC53aWR0aCAtIG5ld1JlY3Qud2lkdGggOiAwLFxuICAgICAgICAgIHk6IGlzQWZ0ZXJBY3RpdmUgPyBjb2xsaXNpb25SZWN0LmhlaWdodCAtIG5ld1JlY3QuaGVpZ2h0IDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWN0Q29vcmRpbmF0ZXMgPSB7XG4gICAgICAgICAgeDogbmV3UmVjdC5sZWZ0LFxuICAgICAgICAgIHk6IG5ld1JlY3QudG9wXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5ld0Nvb3JkaW5hdGVzID0gb2Zmc2V0LnggJiYgb2Zmc2V0LnkgPyByZWN0Q29vcmRpbmF0ZXMgOiBzdWJ0cmFjdChyZWN0Q29vcmRpbmF0ZXMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXdDb29yZGluYXRlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gaXNTYW1lQ29udGFpbmVyKGEsIGIpIHtcbiAgaWYgKCFoYXNTb3J0YWJsZURhdGEoYSkgfHwgIWhhc1NvcnRhYmxlRGF0YShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhLmRhdGEuY3VycmVudC5zb3J0YWJsZS5jb250YWluZXJJZCA9PT0gYi5kYXRhLmN1cnJlbnQuc29ydGFibGUuY29udGFpbmVySWQ7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIoYSwgYikge1xuICBpZiAoIWhhc1NvcnRhYmxlRGF0YShhKSB8fCAhaGFzU29ydGFibGVEYXRhKGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc1NhbWVDb250YWluZXIoYSwgYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYS5kYXRhLmN1cnJlbnQuc29ydGFibGUuaW5kZXggPCBiLmRhdGEuY3VycmVudC5zb3J0YWJsZS5pbmRleDtcbn1cblxuZXhwb3J0IHsgU29ydGFibGVDb250ZXh0LCBhcnJheU1vdmUsIGFycmF5U3dhcCwgZGVmYXVsdEFuaW1hdGVMYXlvdXRDaGFuZ2VzLCBkZWZhdWx0TmV3SW5kZXhHZXR0ZXIsIGhhc1NvcnRhYmxlRGF0YSwgaG9yaXpvbnRhbExpc3RTb3J0aW5nU3RyYXRlZ3ksIHJlY3RTb3J0aW5nU3RyYXRlZ3ksIHJlY3RTd2FwcGluZ1N0cmF0ZWd5LCBzb3J0YWJsZUtleWJvYXJkQ29vcmRpbmF0ZXMsIHVzZVNvcnRhYmxlLCB2ZXJ0aWNhbExpc3RTb3J0aW5nU3RyYXRlZ3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnRhYmxlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZUNvbnRleHQiLCJ1c2VEbmRDb250ZXh0IiwiZ2V0Q2xpZW50UmVjdCIsInVzZURyb3BwYWJsZSIsInVzZURyYWdnYWJsZSIsImNsb3Nlc3RDb3JuZXJzIiwiZ2V0Rmlyc3RDb2xsaXNpb24iLCJnZXRTY3JvbGxhYmxlQW5jZXN0b3JzIiwiS2V5Ym9hcmRDb2RlIiwidXNlVW5pcXVlSWQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiQ1NTIiwidXNlQ29tYmluZWRSZWZzIiwiaXNLZXlib2FyZEV2ZW50Iiwic3VidHJhY3QiLCJhcnJheU1vdmUiLCJhcnJheSIsImZyb20iLCJ0byIsIm5ld0FycmF5Iiwic2xpY2UiLCJzcGxpY2UiLCJsZW5ndGgiLCJhcnJheVN3YXAiLCJnZXRTb3J0ZWRSZWN0cyIsIml0ZW1zIiwicmVjdHMiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsImlkIiwiaW5kZXgiLCJyZWN0IiwiZ2V0IiwiQXJyYXkiLCJpc1ZhbGlkSW5kZXgiLCJpdGVtc0VxdWFsIiwiYSIsImIiLCJpIiwibm9ybWFsaXplRGlzYWJsZWQiLCJkaXNhYmxlZCIsImRyYWdnYWJsZSIsImRyb3BwYWJsZSIsImRlZmF1bHRTY2FsZSIsInNjYWxlWCIsInNjYWxlWSIsImhvcml6b250YWxMaXN0U29ydGluZ1N0cmF0ZWd5IiwiX3JlZiIsIl9yZWN0cyRhY3RpdmVJbmRleCIsImFjdGl2ZU5vZGVSZWN0IiwiZmFsbGJhY2tBY3RpdmVSZWN0IiwiYWN0aXZlSW5kZXgiLCJvdmVySW5kZXgiLCJpdGVtR2FwIiwiZ2V0SXRlbUdhcCIsIm5ld0luZGV4UmVjdCIsIngiLCJsZWZ0Iiwid2lkdGgiLCJ5IiwiY3VycmVudFJlY3QiLCJwcmV2aW91c1JlY3QiLCJuZXh0UmVjdCIsInJlY3RTb3J0aW5nU3RyYXRlZ3kiLCJuZXdSZWN0cyIsIm9sZFJlY3QiLCJuZXdSZWN0IiwidG9wIiwiaGVpZ2h0IiwicmVjdFN3YXBwaW5nU3RyYXRlZ3kiLCJkZWZhdWx0U2NhbGUkMSIsInZlcnRpY2FsTGlzdFNvcnRpbmdTdHJhdGVneSIsIm92ZXJJbmRleFJlY3QiLCJnZXRJdGVtR2FwJDEiLCJjbGllbnRSZWN0cyIsIklEX1BSRUZJWCIsIkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiY29udGFpbmVySWQiLCJkaXNhYmxlVHJhbnNmb3JtcyIsInVzZURyYWdPdmVybGF5Iiwic29ydGVkUmVjdHMiLCJzdHJhdGVneSIsIlNvcnRhYmxlQ29udGV4dCIsImNoaWxkcmVuIiwidXNlckRlZmluZWRJdGVtcyIsImRpc2FibGVkUHJvcCIsImFjdGl2ZSIsImRyYWdPdmVybGF5IiwiZHJvcHBhYmxlUmVjdHMiLCJvdmVyIiwibWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMiLCJCb29sZWFuIiwibWFwIiwiaXRlbSIsImlzRHJhZ2dpbmciLCJpbmRleE9mIiwicHJldmlvdXNJdGVtc1JlZiIsIml0ZW1zSGF2ZUNoYW5nZWQiLCJjdXJyZW50IiwiY29udGV4dFZhbHVlIiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJkZWZhdWx0TmV3SW5kZXhHZXR0ZXIiLCJkZWZhdWx0QW5pbWF0ZUxheW91dENoYW5nZXMiLCJfcmVmMiIsImlzU29ydGluZyIsIndhc0RyYWdnaW5nIiwibmV3SW5kZXgiLCJwcmV2aW91c0l0ZW1zIiwicHJldmlvdXNDb250YWluZXJJZCIsInRyYW5zaXRpb24iLCJkZWZhdWx0VHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiZWFzaW5nIiwidHJhbnNpdGlvblByb3BlcnR5IiwiZGlzYWJsZWRUcmFuc2l0aW9uIiwiVHJhbnNpdGlvbiIsInRvU3RyaW5nIiwicHJvcGVydHkiLCJkZWZhdWx0QXR0cmlidXRlcyIsInJvbGVEZXNjcmlwdGlvbiIsInVzZURlcml2ZWRUcmFuc2Zvcm0iLCJub2RlIiwiZGVyaXZlZFRyYW5zZm9ybSIsInNldERlcml2ZWR0cmFuc2Zvcm0iLCJwcmV2aW91c0luZGV4IiwiaW5pdGlhbCIsImlnbm9yZVRyYW5zZm9ybSIsImRlbHRhIiwidXNlU29ydGFibGUiLCJhbmltYXRlTGF5b3V0Q2hhbmdlcyIsImF0dHJpYnV0ZXMiLCJ1c2VyRGVmaW5lZEF0dHJpYnV0ZXMiLCJsb2NhbERpc2FibGVkIiwiZGF0YSIsImN1c3RvbURhdGEiLCJnZXROZXdJbmRleCIsImxvY2FsU3RyYXRlZ3kiLCJyZXNpemVPYnNlcnZlckNvbmZpZyIsImdsb2JhbERpc2FibGVkIiwiZ2xvYmFsU3RyYXRlZ3kiLCJub3JtYWxpemVMb2NhbERpc2FibGVkIiwic29ydGFibGUiLCJpdGVtc0FmdGVyQ3VycmVudFNvcnRhYmxlIiwiaXNPdmVyIiwic2V0Tm9kZVJlZiIsInNldERyb3BwYWJsZU5vZGVSZWYiLCJ1cGRhdGVNZWFzdXJlbWVudHNGb3IiLCJhY3RpdmF0b3JFdmVudCIsInNldERyYWdnYWJsZU5vZGVSZWYiLCJsaXN0ZW5lcnMiLCJzZXRBY3RpdmF0b3JOb2RlUmVmIiwidHJhbnNmb3JtIiwiZGlzcGxhY2VJdGVtIiwic2hvdWxkRGlzcGxhY2VEcmFnU291cmNlIiwiZHJhZ1NvdXJjZURpc3BsYWNlbWVudCIsImZpbmFsVHJhbnNmb3JtIiwiYWN0aXZlSWQiLCJwcmV2aW91cyIsInNob3VsZEFuaW1hdGVMYXlvdXRDaGFuZ2VzIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsImdldFRyYW5zaXRpb24iLCJ1bmRlZmluZWQiLCJfbG9jYWxEaXNhYmxlZCRkcmFnZ2EiLCJfbG9jYWxEaXNhYmxlZCRkcm9wcGEiLCJoYXNTb3J0YWJsZURhdGEiLCJlbnRyeSIsImRpcmVjdGlvbnMiLCJEb3duIiwiUmlnaHQiLCJVcCIsIkxlZnQiLCJzb3J0YWJsZUtleWJvYXJkQ29vcmRpbmF0ZXMiLCJldmVudCIsImNvbnRleHQiLCJjb2xsaXNpb25SZWN0IiwiZHJvcHBhYmxlQ29udGFpbmVycyIsInNjcm9sbGFibGVBbmNlc3RvcnMiLCJpbmNsdWRlcyIsImNvZGUiLCJwcmV2ZW50RGVmYXVsdCIsImZpbHRlcmVkQ29udGFpbmVycyIsImdldEVuYWJsZWQiLCJmb3JFYWNoIiwicHVzaCIsImNvbGxpc2lvbnMiLCJwb2ludGVyQ29vcmRpbmF0ZXMiLCJjbG9zZXN0SWQiLCJhY3RpdmVEcm9wcGFibGUiLCJuZXdEcm9wcGFibGUiLCJuZXdOb2RlIiwibmV3U2Nyb2xsQW5jZXN0b3JzIiwiaGFzRGlmZmVyZW50U2Nyb2xsQW5jZXN0b3JzIiwic29tZSIsImVsZW1lbnQiLCJoYXNTYW1lQ29udGFpbmVyIiwiaXNTYW1lQ29udGFpbmVyIiwiaXNBZnRlckFjdGl2ZSIsImlzQWZ0ZXIiLCJvZmZzZXQiLCJyZWN0Q29vcmRpbmF0ZXMiLCJuZXdDb29yZGluYXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/sortable/dist/sortable.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dnd-kit/utilities/dist/utilities.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CSS: () => (/* binding */ CSS),\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   canUseDOM: () => (/* binding */ canUseDOM),\n/* harmony export */   findFirstFocusableNode: () => (/* binding */ findFirstFocusableNode),\n/* harmony export */   getEventCoordinates: () => (/* binding */ getEventCoordinates),\n/* harmony export */   getOwnerDocument: () => (/* binding */ getOwnerDocument),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   hasViewportRelativeCoordinates: () => (/* binding */ hasViewportRelativeCoordinates),\n/* harmony export */   isDocument: () => (/* binding */ isDocument),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isKeyboardEvent: () => (/* binding */ isKeyboardEvent),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isSVGElement: () => (/* binding */ isSVGElement),\n/* harmony export */   isTouchEvent: () => (/* binding */ isTouchEvent),\n/* harmony export */   isWindow: () => (/* binding */ isWindow),\n/* harmony export */   subtract: () => (/* binding */ subtract),\n/* harmony export */   useCombinedRefs: () => (/* binding */ useCombinedRefs),\n/* harmony export */   useEvent: () => (/* binding */ useEvent),\n/* harmony export */   useInterval: () => (/* binding */ useInterval),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   useLatestValue: () => (/* binding */ useLatestValue),\n/* harmony export */   useLazyMemo: () => (/* binding */ useLazyMemo),\n/* harmony export */   useNodeRef: () => (/* binding */ useNodeRef),\n/* harmony export */   usePrevious: () => (/* binding */ usePrevious),\n/* harmony export */   useUniqueId: () => (/* binding */ useUniqueId)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction useCombinedRefs() {\n    for(var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++){\n        refs[_key] = arguments[_key];\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>(node)=>{\n            refs.forEach((ref)=>ref(node));\n        }, refs);\n}\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nconst canUseDOM =  false && 0;\nfunction isWindow(element) {\n    const elementString = Object.prototype.toString.call(element);\n    return elementString === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n    elementString === \"[object global]\";\n}\nfunction isNode(node) {\n    return \"nodeType\" in node;\n}\nfunction getWindow(target) {\n    var _target$ownerDocument, _target$ownerDocument2;\n    if (!target) {\n        return window;\n    }\n    if (isWindow(target)) {\n        return target;\n    }\n    if (!isNode(target)) {\n        return window;\n    }\n    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;\n}\nfunction isDocument(node) {\n    const { Document } = getWindow(node);\n    return node instanceof Document;\n}\nfunction isHTMLElement(node) {\n    if (isWindow(node)) {\n        return false;\n    }\n    return node instanceof getWindow(node).HTMLElement;\n}\nfunction isSVGElement(node) {\n    return node instanceof getWindow(node).SVGElement;\n}\nfunction getOwnerDocument(target) {\n    if (!target) {\n        return document;\n    }\n    if (isWindow(target)) {\n        return target.document;\n    }\n    if (!isNode(target)) {\n        return document;\n    }\n    if (isDocument(target)) {\n        return target;\n    }\n    if (isHTMLElement(target)) {\n        return target.ownerDocument;\n    }\n    return document;\n}\n/**\r\n * A hook that resolves to useEffect on the server and useLayoutEffect on the client\r\n * @param callback {function} Callback function that is invoked when the dependencies of the hook change\r\n */ const useIsomorphicLayoutEffect = canUseDOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useEvent(handler) {\n    const handlerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(handler);\n    useIsomorphicLayoutEffect(()=>{\n        handlerRef.current = handler;\n    });\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return handlerRef.current == null ? void 0 : handlerRef.current(...args);\n    }, []);\n}\nfunction useInterval() {\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const set = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((listener, duration)=>{\n        intervalRef.current = setInterval(listener, duration);\n    }, []);\n    const clear = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (intervalRef.current !== null) {\n            clearInterval(intervalRef.current);\n            intervalRef.current = null;\n        }\n    }, []);\n    return [\n        set,\n        clear\n    ];\n}\nfunction useLatestValue(value, dependencies) {\n    if (dependencies === void 0) {\n        dependencies = [\n            value\n        ];\n    }\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n    useIsomorphicLayoutEffect(()=>{\n        if (valueRef.current !== value) {\n            valueRef.current = value;\n        }\n    }, dependencies);\n    return valueRef;\n}\nfunction useLazyMemo(callback, dependencies) {\n    const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const newValue = callback(valueRef.current);\n        valueRef.current = newValue;\n        return newValue;\n    }, [\n        ...dependencies\n    ]);\n}\nfunction useNodeRef(onChange) {\n    const onChangeHandler = useEvent(onChange);\n    const node = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const setNodeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((element)=>{\n        if (element !== node.current) {\n            onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);\n        }\n        node.current = element;\n    }, []);\n    return [\n        node,\n        setNodeRef\n    ];\n}\nfunction usePrevious(value) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        ref.current = value;\n    }, [\n        value\n    ]);\n    return ref.current;\n}\nlet ids = {};\nfunction useUniqueId(prefix, value) {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (value) {\n            return value;\n        }\n        const id = ids[prefix] == null ? 0 : ids[prefix] + 1;\n        ids[prefix] = id;\n        return prefix + \"-\" + id;\n    }, [\n        prefix,\n        value\n    ]);\n}\nfunction createAdjustmentFn(modifier) {\n    return function(object) {\n        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            adjustments[_key - 1] = arguments[_key];\n        }\n        return adjustments.reduce((accumulator, adjustment)=>{\n            const entries = Object.entries(adjustment);\n            for (const [key, valueAdjustment] of entries){\n                const value = accumulator[key];\n                if (value != null) {\n                    accumulator[key] = value + modifier * valueAdjustment;\n                }\n            }\n            return accumulator;\n        }, {\n            ...object\n        });\n    };\n}\nconst add = /*#__PURE__*/ createAdjustmentFn(1);\nconst subtract = /*#__PURE__*/ createAdjustmentFn(-1);\nfunction hasViewportRelativeCoordinates(event) {\n    return \"clientX\" in event && \"clientY\" in event;\n}\nfunction isKeyboardEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { KeyboardEvent } = getWindow(event.target);\n    return KeyboardEvent && event instanceof KeyboardEvent;\n}\nfunction isTouchEvent(event) {\n    if (!event) {\n        return false;\n    }\n    const { TouchEvent } = getWindow(event.target);\n    return TouchEvent && event instanceof TouchEvent;\n}\n/**\r\n * Returns the normalized x and y coordinates for mouse and touch events.\r\n */ function getEventCoordinates(event) {\n    if (isTouchEvent(event)) {\n        if (event.touches && event.touches.length) {\n            const { clientX: x, clientY: y } = event.touches[0];\n            return {\n                x,\n                y\n            };\n        } else if (event.changedTouches && event.changedTouches.length) {\n            const { clientX: x, clientY: y } = event.changedTouches[0];\n            return {\n                x,\n                y\n            };\n        }\n    }\n    if (hasViewportRelativeCoordinates(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    }\n    return null;\n}\nconst CSS = /*#__PURE__*/ Object.freeze({\n    Translate: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { x, y } = transform;\n            return \"translate3d(\" + (x ? Math.round(x) : 0) + \"px, \" + (y ? Math.round(y) : 0) + \"px, 0)\";\n        }\n    },\n    Scale: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            const { scaleX, scaleY } = transform;\n            return \"scaleX(\" + scaleX + \") scaleY(\" + scaleY + \")\";\n        }\n    },\n    Transform: {\n        toString (transform) {\n            if (!transform) {\n                return;\n            }\n            return [\n                CSS.Translate.toString(transform),\n                CSS.Scale.toString(transform)\n            ].join(\" \");\n        }\n    },\n    Transition: {\n        toString (_ref) {\n            let { property, duration, easing } = _ref;\n            return property + \" \" + duration + \"ms \" + easing;\n        }\n    }\n});\nconst SELECTOR = \"a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]\";\nfunction findFirstFocusableNode(element) {\n    if (element.matches(SELECTOR)) {\n        return element;\n    }\n    return element.querySelector(SELECTOR);\n}\n //# sourceMappingURL=utilities.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGRuZC1raXQvdXRpbGl0aWVzL2Rpc3QvdXRpbGl0aWVzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUY7QUFFakYsU0FBU0s7SUFDUCxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7UUFDdkZGLElBQUksQ0FBQ0UsS0FBSyxHQUFHSixTQUFTLENBQUNJLEtBQUs7SUFDOUI7SUFFQSxPQUFPWCw4Q0FBT0EsQ0FBQyxJQUFNWSxDQUFBQTtZQUNuQkgsS0FBS0ksT0FBTyxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJRjtRQUMxQixHQUNBSDtBQUNGO0FBRUEsd0ZBQXdGO0FBQ3hGLE1BQU1NLFlBQVksTUFBNEQsSUFBZSxDQUF5QztBQUV0SSxTQUFTSSxTQUFTQyxPQUFPO0lBQ3ZCLE1BQU1DLGdCQUFnQkMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7SUFDckQsT0FBT0Msa0JBQWtCLHFCQUFxQixzRUFBc0U7SUFDcEhBLGtCQUFrQjtBQUNwQjtBQUVBLFNBQVNLLE9BQU9kLElBQUk7SUFDbEIsT0FBTyxjQUFjQTtBQUN2QjtBQUVBLFNBQVNlLFVBQVVDLE1BQU07SUFDdkIsSUFBSUMsdUJBQXVCQztJQUUzQixJQUFJLENBQUNGLFFBQVE7UUFDWCxPQUFPWjtJQUNUO0lBRUEsSUFBSUcsU0FBU1MsU0FBUztRQUNwQixPQUFPQTtJQUNUO0lBRUEsSUFBSSxDQUFDRixPQUFPRSxTQUFTO1FBQ25CLE9BQU9aO0lBQ1Q7SUFFQSxPQUFPLENBQUNhLHdCQUF3QixDQUFDQyx5QkFBeUJGLE9BQU9HLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSUQsdUJBQXVCRSxXQUFXLEtBQUssT0FBT0gsd0JBQXdCYjtBQUMzSztBQUVBLFNBQVNpQixXQUFXckIsSUFBSTtJ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O0lBRUY7QUFDRjtBQUVBLE1BQU1DLFdBQVc7QUFDakIsU0FBU0MsdUJBQXVCM0YsT0FBTztJQUNyQyxJQUFJQSxRQUFRNEYsT0FBTyxDQUFDRixXQUFXO1FBQzdCLE9BQU8xRjtJQUNUO0lBRUEsT0FBT0EsUUFBUTZGLGFBQWEsQ0FBQ0g7QUFDL0I7QUFFbVgsQ0FDblgseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5bG9hZC1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL0BkbmQta2l0L3V0aWxpdGllcy9kaXN0L3V0aWxpdGllcy5lc20uanM/MjU4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VNZW1vLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gdXNlQ29tYmluZWRSZWZzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcmVmcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICByZWZzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gbm9kZSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKHJlZiA9PiByZWYobm9kZSkpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHJlZnMpO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG5jb25zdCBjYW5Vc2VET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpc1dpbmRvdyhlbGVtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50U3RyaW5nID09PSAnW29iamVjdCBXaW5kb3ddJyB8fCAvLyBJbiBFbGVjdHJvbiBjb250ZXh0IHRoZSBXaW5kb3cgb2JqZWN0IHNlcmlhbGl6ZXMgdG8gW29iamVjdCBnbG9iYWxdXG4gIGVsZW1lbnRTdHJpbmcgPT09ICdbb2JqZWN0IGdsb2JhbF0nO1xufVxuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gJ25vZGVUeXBlJyBpbiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3codGFyZ2V0KSB7XG4gIHZhciBfdGFyZ2V0JG93bmVyRG9jdW1lbnQsIF90YXJnZXQkb3duZXJEb2N1bWVudDI7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKGlzV2luZG93KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKCFpc05vZGUodGFyZ2V0KSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gKF90YXJnZXQkb3duZXJEb2N1bWVudCA9IChfdGFyZ2V0JG93bmVyRG9jdW1lbnQyID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JG93bmVyRG9jdW1lbnQyLmRlZmF1bHRWaWV3KSAhPSBudWxsID8gX3RhcmdldCRvd25lckRvY3VtZW50IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBpc0RvY3VtZW50KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIERvY3VtZW50XG4gIH0gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICBpZiAoaXNXaW5kb3cobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBnZXRXaW5kb3cobm9kZSkuU1ZHRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQuZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50O1xuICB9XG5cbiAgaWYgKGlzRG9jdW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5vd25lckRvY3VtZW50O1xuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50O1xufVxuXG4vKipcclxuICogQSBob29rIHRoYXQgcmVzb2x2ZXMgdG8gdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgYW5kIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgY2xpZW50XHJcbiAqIEBwYXJhbSBjYWxsYmFjayB7ZnVuY3Rpb259IENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIGhvb2sgY2hhbmdlXHJcbiAqL1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VFdmVudChoYW5kbGVyKSB7XG4gIGNvbnN0IGhhbmRsZXJSZWYgPSB1c2VSZWYoaGFuZGxlcik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IGhhbmRsZXI7XG4gIH0pO1xuICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlclJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVyUmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlSW50ZXJ2YWwoKSB7XG4gIGNvbnN0IGludGVydmFsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXQgPSB1c2VDYWxsYmFjaygobGlzdGVuZXIsIGR1cmF0aW9uKSA9PiB7XG4gICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKGxpc3RlbmVyLCBkdXJhdGlvbik7XG4gIH0sIFtdKTtcbiAgY29uc3QgY2xlYXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxSZWYuY3VycmVudCk7XG4gICAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtzZXQsIGNsZWFyXTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0VmFsdWUodmFsdWUsIGRlcGVuZGVuY2llcykge1xuICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHtcbiAgICBkZXBlbmRlbmNpZXMgPSBbdmFsdWVdO1xuICB9XG5cbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAodmFsdWVSZWYuY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIGRlcGVuZGVuY2llcyk7XG4gIHJldHVybiB2YWx1ZVJlZjtcbn1cblxuZnVuY3Rpb24gdXNlTGF6eU1lbW8oY2FsbGJhY2ssIGRlcGVuZGVuY2llcykge1xuICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZigpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjYWxsYmFjayh2YWx1ZVJlZi5jdXJyZW50KTtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFsuLi5kZXBlbmRlbmNpZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlTm9kZVJlZihvbkNoYW5nZSkge1xuICBjb25zdCBvbkNoYW5nZUhhbmRsZXIgPSB1c2VFdmVudChvbkNoYW5nZSk7XG4gIGNvbnN0IG5vZGUgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldE5vZGVSZWYgPSB1c2VDYWxsYmFjayhlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudCAhPT0gbm9kZS5jdXJyZW50KSB7XG4gICAgICBvbkNoYW5nZUhhbmRsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlSGFuZGxlcihlbGVtZW50LCBub2RlLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIG5vZGUuY3VycmVudCA9IGVsZW1lbnQ7XG4gIH0sIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIFtdKTtcbiAgcmV0dXJuIFtub2RlLCBzZXROb2RlUmVmXTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgY29uc3QgcmVmID0gdXNlUmVmKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxubGV0IGlkcyA9IHt9O1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQocHJlZml4LCB2YWx1ZSkge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBpZHNbcHJlZml4XSA9PSBudWxsID8gMCA6IGlkc1twcmVmaXhdICsgMTtcbiAgICBpZHNbcHJlZml4XSA9IGlkO1xuICAgIHJldHVybiBwcmVmaXggKyBcIi1cIiArIGlkO1xuICB9LCBbcHJlZml4LCB2YWx1ZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZGp1c3RtZW50Rm4obW9kaWZpZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYWRqdXN0bWVudHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYWRqdXN0bWVudHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhZGp1c3RtZW50cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBhZGp1c3RtZW50KSA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYWRqdXN0bWVudCk7XG5cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVBZGp1c3RtZW50XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWNjdW11bGF0b3Jba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZSArIG1vZGlmaWVyICogdmFsdWVBZGp1c3RtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9LCB7IC4uLm9iamVjdFxuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBhZGQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQWRqdXN0bWVudEZuKDEpO1xuY29uc3Qgc3VidHJhY3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlQWRqdXN0bWVudEZuKC0xKTtcblxuZnVuY3Rpb24gaGFzVmlld3BvcnRSZWxhdGl2ZUNvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIHJldHVybiAnY2xpZW50WCcgaW4gZXZlbnQgJiYgJ2NsaWVudFknIGluIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBpc0tleWJvYXJkRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFldmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBLZXlib2FyZEV2ZW50XG4gIH0gPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KTtcbiAgcmV0dXJuIEtleWJvYXJkRXZlbnQgJiYgZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFldmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBUb3VjaEV2ZW50XG4gIH0gPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KTtcbiAgcmV0dXJuIFRvdWNoRXZlbnQgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50O1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCkge1xuICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgIGNsaWVudFk6IHlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICBjbGllbnRZOiB5XG4gICAgICB9ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMoZXZlbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBDU1MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIFRyYW5zbGF0ZToge1xuICAgIHRvU3RyaW5nKHRyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0cmFuc2Zvcm07XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArICh4ID8gTWF0aC5yb3VuZCh4KSA6IDApICsgXCJweCwgXCIgKyAoeSA/IE1hdGgucm91bmQoeSkgOiAwKSArIFwicHgsIDApXCI7XG4gICAgfVxuXG4gIH0sXG4gIFNjYWxlOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVlcbiAgICAgIH0gPSB0cmFuc2Zvcm07XG4gICAgICByZXR1cm4gXCJzY2FsZVgoXCIgKyBzY2FsZVggKyBcIikgc2NhbGVZKFwiICsgc2NhbGVZICsgXCIpXCI7XG4gICAgfVxuXG4gIH0sXG4gIFRyYW5zZm9ybToge1xuICAgIHRvU3RyaW5nKHRyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW0NTUy5UcmFuc2xhdGUudG9TdHJpbmcodHJhbnNmb3JtKSwgQ1NTLlNjYWxlLnRvU3RyaW5nKHRyYW5zZm9ybSldLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgfSxcbiAgVHJhbnNpdGlvbjoge1xuICAgIHRvU3RyaW5nKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBwcm9wZXJ0eSArIFwiIFwiICsgZHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nO1xuICAgIH1cblxuICB9XG59KTtcblxuY29uc3QgU0VMRUNUT1IgPSAnYSxmcmFtZSxpZnJhbWUsaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pOm5vdCg6ZGlzYWJsZWQpLHNlbGVjdDpub3QoOmRpc2FibGVkKSx0ZXh0YXJlYTpub3QoOmRpc2FibGVkKSxidXR0b246bm90KDpkaXNhYmxlZCksKlt0YWJpbmRleF0nO1xuZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlTm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm1hdGNoZXMoU0VMRUNUT1IpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SKTtcbn1cblxuZXhwb3J0IHsgQ1NTLCBhZGQsIGNhblVzZURPTSwgZmluZEZpcnN0Rm9jdXNhYmxlTm9kZSwgZ2V0RXZlbnRDb29yZGluYXRlcywgZ2V0T3duZXJEb2N1bWVudCwgZ2V0V2luZG93LCBoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMsIGlzRG9jdW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzS2V5Ym9hcmRFdmVudCwgaXNOb2RlLCBpc1NWR0VsZW1lbnQsIGlzVG91Y2hFdmVudCwgaXNXaW5kb3csIHN1YnRyYWN0LCB1c2VDb21iaW5lZFJlZnMsIHVzZUV2ZW50LCB1c2VJbnRlcnZhbCwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgdXNlTGF0ZXN0VmFsdWUsIHVzZUxhenlNZW1vLCB1c2VOb2RlUmVmLCB1c2VQcmV2aW91cywgdXNlVW5pcXVlSWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxpdGllcy5lc20uanMubWFwXG4iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlQ29tYmluZWRSZWZzIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInJlZnMiLCJBcnJheSIsIl9rZXkiLCJub2RlIiwiZm9yRWFjaCIsInJlZiIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlzV2luZG93IiwiZWxlbWVudCIsImVsZW1lbnRTdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc05vZGUiLCJnZXRXaW5kb3ciLCJ0YXJnZXQiLCJfdGFyZ2V0JG93bmVyRG9jdW1lbnQiLCJfdGFyZ2V0JG93bmVyRG9jdW1lbnQyIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNEb2N1bWVudCIsIkRvY3VtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTVkdFbGVtZW50IiwiU1ZHRWxlbWVudCIsImdldE93bmVyRG9jdW1lbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlRXZlbnQiLCJoYW5kbGVyIiwiaGFuZGxlclJlZiIsImN1cnJlbnQiLCJhcmdzIiwidXNlSW50ZXJ2YWwiLCJpbnRlcnZhbFJlZiIsInNldCIsImxpc3RlbmVyIiwiZHVyYXRpb24iLCJzZXRJbnRlcnZhbCIsImNsZWFyIiwiY2xlYXJJbnRlcnZhbCIsInVzZUxhdGVzdFZhbHVlIiwidmFsdWUiLCJkZXBlbmRlbmNpZXMiLCJ2YWx1ZVJlZiIsInVzZUxhenlNZW1vIiwiY2FsbGJhY2siLCJuZXdWYWx1ZSIsInVzZU5vZGVSZWYiLCJvbkNoYW5nZSIsIm9uQ2hhbmdlSGFuZGxlciIsInNldE5vZGVSZWYiLCJ1c2VQcmV2aW91cyIsImlkcyIsInVzZVVuaXF1ZUlkIiwicHJlZml4IiwiaWQiLCJjcmVhdGVBZGp1c3RtZW50Rm4iLCJtb2RpZmllciIsIm9iamVjdCIsImFkanVzdG1lbnRzIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJhZGp1c3RtZW50IiwiZW50cmllcyIsImtleSIsInZhbHVlQWRqdXN0bWVudCIsImFkZCIsInN1YnRyYWN0IiwiaGFzVmlld3BvcnRSZWxhdGl2ZUNvb3JkaW5hdGVzIiwiZXZlbnQiLCJpc0tleWJvYXJkRXZlbnQiLCJLZXlib2FyZEV2ZW50IiwiaXNUb3VjaEV2ZW50IiwiVG91Y2hFdmVudCIsImdldEV2ZW50Q29vcmRpbmF0ZXMiLCJ0b3VjaGVzIiwiY2xpZW50WCIsIngiLCJjbGllbnRZIiwieSIsImNoYW5nZWRUb3VjaGVzIiwiQ1NTIiwiZnJlZXplIiwiVHJhbnNsYXRlIiwidHJhbnNmb3JtIiwiTWF0aCIsInJvdW5kIiwiU2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJUcmFuc2Zvcm0iLCJqb2luIiwiVHJhbnNpdGlvbiIsIl9yZWYiLCJwcm9wZXJ0eSIsImVhc2luZyIsIlNFTEVDVE9SIiwiZmluZEZpcnN0Rm9jdXNhYmxlTm9kZSIsIm1hdGNoZXMiLCJxdWVyeVNlbGVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@dnd-kit/utilities/dist/utilities.esm.js\n");

/***/ })

};
;