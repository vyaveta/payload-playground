"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/get-it";
exports.ids = ["vendor-chunks/get-it"];
exports.modules = {

/***/ "(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nconst isReactNative = typeof navigator === \"undefined\" ? false : navigator.product === \"ReactNative\";\nconst defaultOptions = {\n    timeout: isReactNative ? 6e4 : 12e4\n};\nconst processOptions = function processOptions2(opts) {\n    const options = {\n        ...defaultOptions,\n        ...typeof opts === \"string\" ? {\n            url: opts\n        } : opts\n    };\n    const { searchParams } = new URL(options.url, \"http://localhost\");\n    options.timeout = normalizeTimeout(options.timeout);\n    if (options.query) {\n        for (const [key, value] of Object.entries(options.query)){\n            if (value !== void 0) {\n                if (Array.isArray(value)) {\n                    for (const v of value){\n                        searchParams.append(key, v);\n                    }\n                } else {\n                    searchParams.append(key, value);\n                }\n            }\n        }\n    }\n    const [url] = options.url.split(\"?\");\n    const search = searchParams.toString();\n    if (search) {\n        options.url = \"\".concat(url, \"?\").concat(search);\n    }\n    options.method = options.body && !options.method ? \"POST\" : (options.method || \"GET\").toUpperCase();\n    return options;\n};\nfunction normalizeTimeout(time) {\n    if (time === false || time === 0) {\n        return false;\n    }\n    if (time.connect || time.socket) {\n        return time;\n    }\n    const delay = Number(time);\n    if (isNaN(delay)) {\n        return normalizeTimeout(defaultOptions.timeout);\n    }\n    return {\n        connect: delay,\n        socket: delay\n    };\n}\nconst validUrl = /^https?:\\/\\//i;\nconst validateOptions = function validateOptions2(options) {\n    if (!validUrl.test(options.url)) {\n        throw new Error('\"'.concat(options.url, '\" is not a valid URL'));\n    }\n};\nexports.processOptions = processOptions;\nexports.validateOptions = validateOptions; //# sourceMappingURL=defaultOptionsValidator-2bJolbLg.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci0yYkpvbGJMZy5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxnQkFBZ0IsT0FBT0MsY0FBYyxjQUFjLFFBQVFBLFVBQVVDLE9BQU8sS0FBSztBQUN2RixNQUFNQyxpQkFBaUI7SUFDckJDLFNBQVNKLGdCQUFnQixNQUFNO0FBQ2pDO0FBQ0EsTUFBTUssaUJBQWlCLFNBQVNDLGdCQUFnQkMsSUFBSTtJQUNsRCxNQUFNQyxVQUFVO1FBQ2QsR0FBR0wsY0FBYztRQUNqQixHQUFJLE9BQU9JLFNBQVMsV0FBVztZQUM3QkUsS0FBS0Y7UUFDUCxJQUFJQSxJQUFJO0lBQ1Y7SUFDQSxNQUFNLEVBQ0pHLFlBQVksRUFDYixHQUFHLElBQUlDLElBQUlILFFBQVFDLEdBQUcsRUFBRTtJQUN6QkQsUUFBUUosT0FBTyxHQUFHUSxpQkFBaUJKLFFBQVFKLE9BQU87SUFDbEQsSUFBSUksUUFBUUssS0FBSyxFQUFFO1FBQ2pCLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1QsUUFBUUssS0FBSyxFQUFHO1lBQ3hELElBQUlFLFVBQVUsS0FBSyxHQUFHO2dCQUNwQixJQUFJRyxNQUFNQyxPQUFPLENBQUNKLFFBQVE7b0JBQ3hCLEtBQUssTUFBTUssS0FBS0wsTUFBTzt3QkFDckJMLGFBQWFXLE1BQU0sQ0FBQ1AsS0FBS007b0JBQzNCO2dCQUNGLE9BQU87b0JBQ0xWLGFBQWFXLE1BQU0sQ0FBQ1AsS0FBS0M7Z0JBQzNCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTSxDQUFDTixJQUFJLEdBQUdELFFBQVFDLEdBQUcsQ0FBQ2EsS0FBSyxDQUFDO0lBQ2hDLE1BQU1DLFNBQVNiLGFBQWFjLFFBQVE7SUFDcEMsSUFBSUQsUUFBUTtRQUNWZixRQUFRQyxHQUFHLEdBQUcsR0FBR2dCLE1BQU0sQ0FBQ2hCLEtBQUssS0FBS2dCLE1BQU0sQ0FBQ0Y7SUFDM0M7SUFDQWYsUUFBUWtCLE1BQU0sR0FBR2xCLFFBQVFtQixJQUFJLElBQUksQ0FBQ25CLFFBQVFrQixNQUFNLEdBQUcsU0FBUyxDQUFDbEIsUUFBUWtCLE1BQU0sSUFBSSxLQUFJLEVBQUdFLFdBQVc7SUFDakcsT0FBT3BCO0FBQ1Q7QUFDQSxTQUFTSSxpQkFBaUJpQixJQUFJO0lBQzVCLElBQUlBLFNBQVMsU0FBU0EsU0FBUyxHQUFHO1FBQ2hDLE9BQU87SUFDVDtJQUNBLElBQUlBLEtBQUtDLE9BQU8sSUFBSUQsS0FBS0UsTUFBTSxFQUFFO1FBQy9CLE9BQU9GO0lBQ1Q7SUFDQSxNQUFNRyxRQUFRQyxPQUFPSjtJQUNyQixJQUFJSyxNQUFNRixRQUFRO1FBQ2hCLE9BQU9wQixpQkFBaUJULGVBQWVDLE9BQU87SUFDaEQ7SUFDQSxPQUFPO1FBQ0wwQixTQUFTRTtRQUNURCxRQUFRQztJQUNWO0FBQ0Y7QUFDQSxNQUFNRyxXQUFXO0FBQ2pCLE1BQU1DLGtCQUFrQixTQUFTQyxpQkFBaUI3QixPQUFPO0lBQ3ZELElBQUksQ0FBQzJCLFNBQVNHLElBQUksQ0FBQzlCLFFBQVFDLEdBQUcsR0FBRztRQUMvQixNQUFNLElBQUk4QixNQUFNLElBQUlkLE1BQU0sQ0FBQ2pCLFFBQVFDLEdBQUcsRUFBRTtJQUMxQztBQUNGO0FBQ0ErQixzQkFBc0IsR0FBR25DO0FBQ3pCbUMsdUJBQXVCLEdBQUdKLGlCQUMxQiw2REFBNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wYXlsb2FkLXBsYXlncm91bmQvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci0yYkpvbGJMZy5janM/MDY3MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yID09PSBcInVuZGVmaW5lZFwiID8gZmFsc2UgOiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IGlzUmVhY3ROYXRpdmUgPyA2ZTQgOiAxMmU0XG59O1xuY29uc3QgcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzT3B0aW9uczIob3B0cykge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgIC4uLih0eXBlb2Ygb3B0cyA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgIHVybDogb3B0c1xuICAgIH0gOiBvcHRzKVxuICB9O1xuICBjb25zdCB7XG4gICAgc2VhcmNoUGFyYW1zXG4gIH0gPSBuZXcgVVJMKG9wdGlvbnMudXJsLCBcImh0dHA6Ly9sb2NhbGhvc3RcIik7XG4gIG9wdGlvbnMudGltZW91dCA9IG5vcm1hbGl6ZVRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zLnF1ZXJ5KSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgW3VybF0gPSBvcHRpb25zLnVybC5zcGxpdChcIj9cIik7XG4gIGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuICBpZiAoc2VhcmNoKSB7XG4gICAgb3B0aW9ucy51cmwgPSBcIlwiLmNvbmNhdCh1cmwsIFwiP1wiKS5jb25jYXQoc2VhcmNoKTtcbiAgfVxuICBvcHRpb25zLm1ldGhvZCA9IG9wdGlvbnMuYm9keSAmJiAhb3B0aW9ucy5tZXRob2QgPyBcIlBPU1RcIiA6IChvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiKS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gb3B0aW9ucztcbn07XG5mdW5jdGlvbiBub3JtYWxpemVUaW1lb3V0KHRpbWUpIHtcbiAgaWYgKHRpbWUgPT09IGZhbHNlIHx8IHRpbWUgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRpbWUuY29ubmVjdCB8fCB0aW1lLnNvY2tldCkge1xuICAgIHJldHVybiB0aW1lO1xuICB9XG4gIGNvbnN0IGRlbGF5ID0gTnVtYmVyKHRpbWUpO1xuICBpZiAoaXNOYU4oZGVsYXkpKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVRpbWVvdXQoZGVmYXVsdE9wdGlvbnMudGltZW91dCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb25uZWN0OiBkZWxheSxcbiAgICBzb2NrZXQ6IGRlbGF5XG4gIH07XG59XG5jb25zdCB2YWxpZFVybCA9IC9eaHR0cHM/OlxcL1xcLy9pO1xuY29uc3QgdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zMihvcHRpb25zKSB7XG4gIGlmICghdmFsaWRVcmwudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJy5jb25jYXQob3B0aW9ucy51cmwsICdcIiBpcyBub3QgYSB2YWxpZCBVUkwnKSk7XG4gIH1cbn07XG5leHBvcnRzLnByb2Nlc3NPcHRpb25zID0gcHJvY2Vzc09wdGlvbnM7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLTJiSm9sYkxnLmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJpc1JlYWN0TmF0aXZlIiwibmF2aWdhdG9yIiwicHJvZHVjdCIsImRlZmF1bHRPcHRpb25zIiwidGltZW91dCIsInByb2Nlc3NPcHRpb25zIiwicHJvY2Vzc09wdGlvbnMyIiwib3B0cyIsIm9wdGlvbnMiLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJVUkwiLCJub3JtYWxpemVUaW1lb3V0IiwicXVlcnkiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwiYXBwZW5kIiwic3BsaXQiLCJzZWFyY2giLCJ0b1N0cmluZyIsImNvbmNhdCIsIm1ldGhvZCIsImJvZHkiLCJ0b1VwcGVyQ2FzZSIsInRpbWUiLCJjb25uZWN0Iiwic29ja2V0IiwiZGVsYXkiLCJOdW1iZXIiLCJpc05hTiIsInZhbGlkVXJsIiwidmFsaWRhdGVPcHRpb25zIiwidmFsaWRhdGVPcHRpb25zMiIsInRlc3QiLCJFcnJvciIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/get-it/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-2bJolbLg.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\");\nvar decompressResponse = __webpack_require__(/*! decompress-response */ \"(ssr)/./node_modules/decompress-response/index.js\");\nvar follow = __webpack_require__(/*! follow-redirects */ \"(ssr)/./node_modules/follow-redirects/index.js\");\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar toStream = __webpack_require__(/*! into-stream */ \"(ssr)/./node_modules/into-stream/index.js\");\nvar isStream = __webpack_require__(/*! is-stream */ \"(ssr)/./node_modules/is-stream/index.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar qs = __webpack_require__(/*! querystring */ \"querystring\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar tunnel = __webpack_require__(/*! tunnel-agent */ \"(ssr)/./node_modules/tunnel-agent/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nfunction _interopNamespaceCompat(e) {\n    if (e && typeof e === \"object\" && \"default\" in e) return e;\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar decompressResponse__default = /*#__PURE__*/ _interopDefaultCompat(decompressResponse);\nvar follow__default = /*#__PURE__*/ _interopDefaultCompat(follow);\nvar http__default = /*#__PURE__*/ _interopDefaultCompat(http);\nvar https__default = /*#__PURE__*/ _interopDefaultCompat(https);\nvar toStream__default = /*#__PURE__*/ _interopDefaultCompat(toStream);\nvar isStream__default = /*#__PURE__*/ _interopDefaultCompat(isStream);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar qs__default = /*#__PURE__*/ _interopDefaultCompat(qs);\nvar url__default = /*#__PURE__*/ _interopDefaultCompat(url);\nvar tunnel__namespace = /*#__PURE__*/ _interopNamespaceCompat(tunnel);\nconst middlewareReducer = (middleware)=>function applyMiddleware(hook, defaultValue) {\n        const bailEarly = hook === \"onError\";\n        let value = defaultValue;\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        for(let i = 0; i < middleware[hook].length; i++){\n            const handler = middleware[hook][i];\n            value = handler(value, ...args);\n            if (bailEarly && !value) {\n                break;\n            }\n        }\n        return value;\n    };\nfunction createPubSub() {\n    const subscribers = /* @__PURE__ */ Object.create(null);\n    let nextId = 0;\n    function subscribe(subscriber) {\n        const id = nextId++;\n        subscribers[id] = subscriber;\n        return function unsubscribe() {\n            delete subscribers[id];\n        };\n    }\n    function publish(event) {\n        for(const id in subscribers){\n            subscribers[id](event);\n        }\n    }\n    return {\n        publish,\n        subscribe\n    };\n}\nconst channelNames = [\n    \"request\",\n    \"response\",\n    \"progress\",\n    \"error\",\n    \"abort\"\n];\nconst middlehooks = [\n    \"processOptions\",\n    \"validateOptions\",\n    \"interceptRequest\",\n    \"finalizeOptions\",\n    \"onRequest\",\n    \"onResponse\",\n    \"onError\",\n    \"onReturn\",\n    \"onHeaders\"\n];\nfunction createRequester(initMiddleware, httpRequest) {\n    const loadedMiddleware = [];\n    const middleware = middlehooks.reduce((ware, name)=>{\n        ware[name] = ware[name] || [];\n        return ware;\n    }, {\n        processOptions: [\n            defaultOptionsValidator.processOptions\n        ],\n        validateOptions: [\n            defaultOptionsValidator.validateOptions\n        ]\n    });\n    function request(opts) {\n        const onResponse = (reqErr, res, ctx)=>{\n            let error = reqErr;\n            let response = res;\n            if (!error) {\n                try {\n                    response = applyMiddleware(\"onResponse\", res, ctx);\n                } catch (err) {\n                    response = null;\n                    error = err;\n                }\n            }\n            error = error && applyMiddleware(\"onError\", error, ctx);\n            if (error) {\n                channels.error.publish(error);\n            } else if (response) {\n                channels.response.publish(response);\n            }\n        };\n        const channels = channelNames.reduce((target, name)=>{\n            target[name] = createPubSub();\n            return target;\n        }, {});\n        const applyMiddleware = middlewareReducer(middleware);\n        const options = applyMiddleware(\"processOptions\", opts);\n        applyMiddleware(\"validateOptions\", options);\n        const context = {\n            options,\n            channels,\n            applyMiddleware\n        };\n        let ongoingRequest;\n        const unsubscribe = channels.request.subscribe((ctx)=>{\n            ongoingRequest = httpRequest(ctx, (err, res)=>onResponse(err, res, ctx));\n        });\n        channels.abort.subscribe(()=>{\n            unsubscribe();\n            if (ongoingRequest) {\n                ongoingRequest.abort();\n            }\n        });\n        const returnValue = applyMiddleware(\"onReturn\", channels, context);\n        if (returnValue === channels) {\n            channels.request.publish(context);\n        }\n        return returnValue;\n    }\n    request.use = function use(newMiddleware) {\n        if (!newMiddleware) {\n            throw new Error(\"Tried to add middleware that resolved to falsey value\");\n        }\n        if (typeof newMiddleware === \"function\") {\n            throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n        }\n        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n            throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n        }\n        middlehooks.forEach((key)=>{\n            if (newMiddleware[key]) {\n                middleware[key].push(newMiddleware[key]);\n            }\n        });\n        loadedMiddleware.push(newMiddleware);\n        return request;\n    };\n    request.clone = ()=>createRequester(loadedMiddleware, httpRequest);\n    initMiddleware.forEach(request.use);\n    return request;\n}\nfunction lowerCaseHeaders(headers) {\n    return Object.keys(headers || {}).reduce((acc, header)=>{\n        acc[header.toLowerCase()] = headers[header];\n        return acc;\n    }, {});\n}\nfunction formatHostname(hostname) {\n    return hostname.replace(/^\\.*/, \".\").toLowerCase();\n}\nfunction parseNoProxyZone(zoneStr) {\n    const zone = zoneStr.trim().toLowerCase();\n    const zoneParts = zone.split(\":\", 2);\n    const zoneHost = formatHostname(zoneParts[0]);\n    const zonePort = zoneParts[1];\n    const hasPort = zone.indexOf(\":\") > -1;\n    return {\n        hostname: zoneHost,\n        port: zonePort,\n        hasPort\n    };\n}\nfunction uriInNoProxy(uri, noProxy) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    const hostname = formatHostname(uri.hostname);\n    const noProxyList = noProxy.split(\",\");\n    return noProxyList.map(parseNoProxyZone).some((noProxyZone)=>{\n        const isMatchedAt = hostname.indexOf(noProxyZone.hostname);\n        const hostnameMatched = isMatchedAt > -1 && isMatchedAt === hostname.length - noProxyZone.hostname.length;\n        if (noProxyZone.hasPort) {\n            return port === noProxyZone.port && hostnameMatched;\n        }\n        return hostnameMatched;\n    });\n}\nfunction getProxyFromUri(uri) {\n    const noProxy = process.env.NO_PROXY || process.env.no_proxy || \"\";\n    if (noProxy === \"*\") {\n        return null;\n    }\n    if (noProxy !== \"\" && uriInNoProxy(uri, noProxy)) {\n        return null;\n    }\n    if (uri.protocol === \"http:\") {\n        return process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    if (uri.protocol === \"https:\") {\n        return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;\n    }\n    return null;\n}\nfunction getHostFromUri(uri) {\n    let host = uri.host;\n    if (uri.port) {\n        if (uri.port === \"80\" && uri.protocol === \"http:\" || uri.port === \"443\" && uri.protocol === \"https:\") {\n            host = uri.hostname;\n        }\n    }\n    return host;\n}\nfunction getHostHeaderWithPort(uri) {\n    const port = uri.port || (uri.protocol === \"https:\" ? \"443\" : \"80\");\n    return \"\".concat(uri.hostname, \":\").concat(port);\n}\nfunction rewriteUriForProxy(reqOpts, uri, proxy) {\n    const headers = reqOpts.headers || {};\n    const options = Object.assign({}, reqOpts, {\n        headers\n    });\n    headers.host = headers.host || getHostHeaderWithPort(uri);\n    options.protocol = proxy.protocol || options.protocol;\n    options.hostname = proxy.host.replace(/:\\d+/, \"\");\n    options.port = proxy.port;\n    options.host = getHostFromUri(Object.assign({}, uri, proxy));\n    options.href = \"\".concat(options.protocol, \"//\").concat(options.host).concat(options.path);\n    options.path = url__default.default.format(uri);\n    return options;\n}\nfunction getProxyOptions(options) {\n    let proxy;\n    if (options.hasOwnProperty(\"proxy\")) {\n        proxy = options.proxy;\n    } else {\n        const uri = url__default.default.parse(options.url);\n        proxy = getProxyFromUri(uri);\n    }\n    return typeof proxy === \"string\" ? url__default.default.parse(proxy) : proxy;\n}\n/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ function concat(stream, cb) {\n    const chunks = [];\n    stream.on(\"data\", function(chunk) {\n        chunks.push(chunk);\n    });\n    stream.once(\"end\", function() {\n        if (cb) cb(null, Buffer.concat(chunks));\n        cb = null;\n    });\n    stream.once(\"error\", function(err) {\n        if (cb) cb(err);\n        cb = null;\n    });\n}\nfunction timedOut(req, time) {\n    if (req.timeoutTimer) {\n        return req;\n    }\n    const delays = isNaN(time) ? time : {\n        socket: time,\n        connect: time\n    };\n    const hostHeader = req.getHeader(\"host\");\n    const host = hostHeader ? \" to \" + hostHeader : \"\";\n    if (delays.connect !== void 0) {\n        req.timeoutTimer = setTimeout(function timeoutHandler() {\n            req.abort();\n            const e = new Error(\"Connection timed out on request\" + host);\n            e.code = \"ETIMEDOUT\";\n            req.emit(\"error\", e);\n        }, delays.connect);\n    }\n    req.on(\"socket\", function assign(socket) {\n        if (!(socket.connecting || socket._connecting)) {\n            connect();\n            return;\n        }\n        socket.once(\"connect\", connect);\n    });\n    function clear() {\n        if (req.timeoutTimer) {\n            clearTimeout(req.timeoutTimer);\n            req.timeoutTimer = null;\n        }\n    }\n    function connect() {\n        clear();\n        if (delays.socket !== void 0) {\n            req.setTimeout(delays.socket, function socketTimeoutHandler() {\n                req.abort();\n                const e = new Error(\"Socket timed out on request\" + host);\n                e.code = \"ESOCKETTIMEDOUT\";\n                req.emit(\"error\", e);\n            });\n        }\n    }\n    return req.on(\"error\", clear);\n}\nconst uriParts = [\n    \"protocol\",\n    \"slashes\",\n    \"auth\",\n    \"host\",\n    \"port\",\n    \"hostname\",\n    \"hash\",\n    \"search\",\n    \"query\",\n    \"pathname\",\n    \"path\",\n    \"href\"\n];\nconst defaultProxyHeaderWhiteList = [\n    \"accept\",\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"accept-language\",\n    \"accept-ranges\",\n    \"cache-control\",\n    \"content-encoding\",\n    \"content-language\",\n    \"content-location\",\n    \"content-md5\",\n    \"content-range\",\n    \"content-type\",\n    \"connection\",\n    \"date\",\n    \"expect\",\n    \"max-forwards\",\n    \"pragma\",\n    \"referer\",\n    \"te\",\n    \"user-agent\",\n    \"via\"\n];\nconst defaultProxyHeaderExclusiveList = [\n    \"proxy-authorization\"\n];\nfunction shouldEnable(options) {\n    if (typeof options.tunnel !== \"undefined\") {\n        return Boolean(options.tunnel);\n    }\n    const uri = url__default.default.parse(options.url);\n    if (uri.protocol === \"https:\") {\n        return true;\n    }\n    return false;\n}\nfunction applyAgent() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let proxy = arguments.length > 1 ? arguments[1] : undefined;\n    const options = Object.assign({}, opts);\n    const proxyHeaderWhiteList = defaultProxyHeaderWhiteList.concat(options.proxyHeaderWhiteList || []).map((header)=>header.toLowerCase());\n    const proxyHeaderExclusiveList = defaultProxyHeaderExclusiveList.concat(options.proxyHeaderExclusiveList || []).map((header)=>header.toLowerCase());\n    const proxyHeaders = getAllowedProxyHeaders(options.headers, proxyHeaderWhiteList);\n    proxyHeaders.host = constructProxyHost(options);\n    options.headers = Object.keys(options.headers || {}).reduce((headers, header)=>{\n        const isAllowed = proxyHeaderExclusiveList.indexOf(header.toLowerCase()) === -1;\n        if (isAllowed) {\n            headers[header] = options.headers[header];\n        }\n        return headers;\n    }, {});\n    const tunnelFn = getTunnelFn(options, proxy);\n    const tunnelOptions = constructTunnelOptions(options, proxy, proxyHeaders);\n    options.agent = tunnelFn(tunnelOptions);\n    return options;\n}\nfunction getTunnelFn(options, proxy) {\n    const uri = getUriParts(options);\n    const tunnelFnName = constructTunnelFnName(uri, proxy);\n    return tunnel__namespace[tunnelFnName];\n}\nfunction getUriParts(options) {\n    return uriParts.reduce((uri, part)=>{\n        uri[part] = options[part];\n        return uri;\n    }, {});\n}\nfunction constructTunnelFnName(uri, proxy) {\n    const uriProtocol = uri.protocol === \"https:\" ? \"https\" : \"http\";\n    const proxyProtocol = proxy.protocol === \"https:\" ? \"Https\" : \"Http\";\n    return \"\".concat(uriProtocol, \"Over\").concat(proxyProtocol);\n}\nfunction constructProxyHost(uri) {\n    const port = uri.port;\n    const protocol = uri.protocol;\n    let proxyHost = \"\".concat(uri.hostname, \":\");\n    if (port) {\n        proxyHost += port;\n    } else if (protocol === \"https:\") {\n        proxyHost += \"443\";\n    } else {\n        proxyHost += \"80\";\n    }\n    return proxyHost;\n}\nfunction getAllowedProxyHeaders(headers, whiteList) {\n    return Object.keys(headers).filter((header)=>whiteList.indexOf(header.toLowerCase()) !== -1).reduce((set, header)=>{\n        set[header] = headers[header];\n        return set;\n    }, {});\n}\nfunction constructTunnelOptions(options, proxy, proxyHeaders) {\n    return {\n        proxy: {\n            host: proxy.hostname,\n            port: +proxy.port,\n            proxyAuth: proxy.auth,\n            headers: proxyHeaders\n        },\n        headers: options.headers,\n        ca: options.ca,\n        cert: options.cert,\n        key: options.key,\n        passphrase: options.passphrase,\n        pfx: options.pfx,\n        ciphers: options.ciphers,\n        rejectUnauthorized: options.rejectUnauthorized,\n        secureOptions: options.secureOptions,\n        secureProtocol: options.secureProtocol\n    };\n}\nconst adapter = \"node\";\nconst reduceResponse = (res, reqUrl, method, body)=>({\n        body,\n        url: reqUrl,\n        method,\n        headers: res.headers,\n        statusCode: res.statusCode,\n        statusMessage: res.statusMessage\n    });\nconst httpRequester = (context, cb)=>{\n    const { options } = context;\n    const uri = Object.assign({}, url__default.default.parse(options.url));\n    if (typeof fetch === \"function\" && options.fetch) {\n        const controller = new AbortController();\n        const reqOpts2 = context.applyMiddleware(\"finalizeOptions\", {\n            ...uri,\n            method: options.method,\n            headers: {\n                ...typeof options.fetch === \"object\" && options.fetch.headers ? lowerCaseHeaders(options.fetch.headers) : {},\n                ...lowerCaseHeaders(options.headers)\n            },\n            maxRedirects: options.maxRedirects\n        });\n        const fetchOpts = {\n            credentials: options.withCredentials ? \"include\" : \"omit\",\n            ...typeof options.fetch === \"object\" ? options.fetch : {},\n            method: reqOpts2.method,\n            headers: reqOpts2.headers,\n            body: options.body,\n            signal: controller.signal\n        };\n        const injectedResponse2 = context.applyMiddleware(\"interceptRequest\", void 0, {\n            adapter,\n            context\n        });\n        if (injectedResponse2) {\n            const cbTimer = setTimeout(cb, 0, null, injectedResponse2);\n            const cancel = ()=>clearTimeout(cbTimer);\n            return {\n                abort: cancel\n            };\n        }\n        const request2 = fetch(options.url, fetchOpts);\n        context.applyMiddleware(\"onRequest\", {\n            options,\n            adapter,\n            request: request2,\n            context\n        });\n        request2.then(async (res)=>{\n            const body = options.rawBody ? res.body : await res.text();\n            const headers = {};\n            res.headers.forEach((value, key)=>{\n                headers[key] = value;\n            });\n            cb(null, {\n                body,\n                url: res.url,\n                method: options.method,\n                headers,\n                statusCode: res.status,\n                statusMessage: res.statusText\n            });\n        }).catch((err)=>{\n            if (err.name == \"AbortError\") return;\n            cb(err);\n        });\n        return {\n            abort: ()=>controller.abort()\n        };\n    }\n    const bodyType = isStream__default.default(options.body) ? \"stream\" : typeof options.body;\n    if (bodyType !== \"undefined\" && bodyType !== \"stream\" && bodyType !== \"string\" && !Buffer.isBuffer(options.body)) {\n        throw new Error(\"Request body must be a string, buffer or stream, got \".concat(bodyType));\n    }\n    const lengthHeader = {};\n    if (options.bodySize) {\n        lengthHeader[\"content-length\"] = options.bodySize;\n    } else if (options.body && bodyType !== \"stream\") {\n        lengthHeader[\"content-length\"] = Buffer.byteLength(options.body);\n    }\n    let aborted = false;\n    const callback = (err, res)=>!aborted && cb(err, res);\n    context.channels.abort.subscribe(()=>{\n        aborted = true;\n    });\n    let reqOpts = Object.assign({}, uri, {\n        method: options.method,\n        headers: Object.assign({}, lowerCaseHeaders(options.headers), lengthHeader),\n        maxRedirects: options.maxRedirects\n    });\n    const proxy = getProxyOptions(options);\n    const tunnel = proxy && shouldEnable(options);\n    const injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n    });\n    if (injectedResponse) {\n        const cbTimer = setImmediate(callback, null, injectedResponse);\n        const abort = ()=>clearImmediate(cbTimer);\n        return {\n            abort\n        };\n    }\n    if (options.maxRedirects !== 0) {\n        reqOpts.maxRedirects = options.maxRedirects || 5;\n    }\n    if (proxy && tunnel) {\n        reqOpts = applyAgent(reqOpts, proxy);\n    } else if (proxy && !tunnel) {\n        reqOpts = rewriteUriForProxy(reqOpts, uri, proxy);\n    }\n    if (!tunnel && proxy && proxy.auth && !reqOpts.headers[\"proxy-authorization\"]) {\n        const [username, password] = proxy.auth.username ? [\n            proxy.auth.username,\n            proxy.auth.password\n        ] : proxy.auth.split(\":\").map((item)=>qs__default.default.unescape(item));\n        const auth = Buffer.from(\"\".concat(username, \":\").concat(password), \"utf8\");\n        const authBase64 = auth.toString(\"base64\");\n        reqOpts.headers[\"proxy-authorization\"] = \"Basic \".concat(authBase64);\n    }\n    const transport = getRequestTransport(reqOpts, proxy, tunnel);\n    if (typeof options.debug === \"function\" && proxy) {\n        options.debug(\"Proxying using %s\", reqOpts.agent ? \"tunnel agent\" : \"\".concat(reqOpts.host, \":\").concat(reqOpts.port));\n    }\n    const tryCompressed = reqOpts.method !== \"HEAD\";\n    if (tryCompressed && !reqOpts.headers[\"accept-encoding\"] && options.compress !== false) {\n        reqOpts.headers[\"accept-encoding\"] = \"br, gzip, deflate\";\n    }\n    const finalOptions = context.applyMiddleware(\"finalizeOptions\", reqOpts);\n    const request = transport.request(finalOptions, (response)=>{\n        const res = tryCompressed ? decompressResponse__default.default(response) : response;\n        const resStream = context.applyMiddleware(\"onHeaders\", res, {\n            headers: response.headers,\n            adapter,\n            context\n        });\n        const reqUrl = \"responseUrl\" in response ? response.responseUrl : options.url;\n        if (options.stream) {\n            callback(null, reduceResponse(res, reqUrl, reqOpts.method, resStream));\n            return;\n        }\n        concat(resStream, (err, data)=>{\n            if (err) {\n                return callback(err);\n            }\n            const body = options.rawBody ? data : data.toString();\n            const reduced = reduceResponse(res, reqUrl, reqOpts.method, body);\n            return callback(null, reduced);\n        });\n    });\n    if (options.timeout) {\n        timedOut(request, options.timeout);\n    }\n    request.once(\"error\", callback);\n    const { bodyStream, progress } = getProgressStream(options);\n    context.applyMiddleware(\"onRequest\", {\n        options,\n        adapter,\n        request,\n        context,\n        progress\n    });\n    if (bodyStream) {\n        bodyStream.pipe(request);\n    } else {\n        request.end(options.body);\n    }\n    return {\n        abort: ()=>request.abort()\n    };\n};\nfunction getProgressStream(options) {\n    if (!options.body) {\n        return {};\n    }\n    const bodyIsStream = isStream__default.default(options.body);\n    const length = options.bodySize || (bodyIsStream ? null : Buffer.byteLength(options.body));\n    if (!length) {\n        return bodyIsStream ? {\n            bodyStream: options.body\n        } : {};\n    }\n    const progress = progressStream__default.default({\n        time: 16,\n        length\n    });\n    const bodyStream = bodyIsStream ? options.body : toStream__default.default(options.body);\n    return {\n        bodyStream: bodyStream.pipe(progress),\n        progress\n    };\n}\nfunction getRequestTransport(reqOpts, proxy, tunnel) {\n    const isHttpsRequest = reqOpts.protocol === \"https:\";\n    const transports = reqOpts.maxRedirects === 0 ? {\n        http: http__default.default,\n        https: https__default.default\n    } : {\n        http: follow__default.default.http,\n        https: follow__default.default.https\n    };\n    if (!proxy || tunnel) {\n        return isHttpsRequest ? transports.https : transports.http;\n    }\n    let isHttpsProxy = proxy.port === 443;\n    if (proxy.protocol) {\n        isHttpsProxy = /^https:?/.test(proxy.protocol);\n    }\n    return isHttpsProxy ? transports.https : transports.http;\n}\nconst getIt = function() {\n    let initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : httpRequester;\n    return createRequester(initMiddleware, httpRequest);\n};\nconst environment = \"node\";\nexports.adapter = adapter;\nexports.environment = environment;\nexports.getIt = getIt; //# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUMzQ0csT0FBTztBQUNULENBQUMsRUFBQztBQUNGLElBQUlDLDBCQUEwQkMsbUJBQU9BLENBQUM7QUFDdEMsSUFBSUMscUJBQXFCRCxtQkFBT0EsQ0FBQztBQUNqQyxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUNyQixJQUFJRyxPQUFPSCxtQkFBT0EsQ0FBQztBQUNuQixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxXQUFXTCxtQkFBT0EsQ0FBQztBQUN2QixJQUFJTSxXQUFXTixtQkFBT0EsQ0FBQztBQUN2QixJQUFJTyxpQkFBaUJQLG1CQUFPQSxDQUFDO0FBQzdCLElBQUlRLEtBQUtSLG1CQUFPQSxDQUFDO0FBQ2pCLElBQUlTLE1BQU1ULG1CQUFPQSxDQUFDO0FBQ2xCLElBQUlVLFNBQVNWLG1CQUFPQSxDQUFDO0FBQ3JCLFNBQVNXLHNCQUFzQkMsQ0FBQztJQUM5QixPQUFPQSxLQUFLLE9BQU9BLE1BQU0sWUFBWSxhQUFhQSxJQUFJQSxJQUFJO1FBQ3hEQyxTQUFTRDtJQUNYO0FBQ0Y7QUFDQSxTQUFTRSx3QkFBd0JGLENBQUM7SUFDaEMsSUFBSUEsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsR0FBRyxPQUFPQTtJQUN6RCxJQUFJRyxJQUFJcEIsT0FBT3FCLE1BQU0sQ0FBQztJQUN0QixJQUFJSixHQUFHO1FBQ0xqQixPQUFPc0IsSUFBSSxDQUFDTCxHQUFHTSxPQUFPLENBQUMsU0FBVUMsQ0FBQztZQUNoQyxJQUFJQSxNQUFNLFdBQVc7Z0JBQ25CLElBQUlDLElBQUl6QixPQUFPMEIsd0JBQXdCLENBQUNULEdBQUdPO2dCQUMzQ3hCLE9BQU9DLGNBQWMsQ0FBQ21CLEdBQUdJLEdBQUdDLEVBQUVFLEdBQUcsR0FBR0YsSUFBSTtvQkFDdENHLFlBQVk7b0JBQ1pELEtBQUs7d0JBQ0gsT0FBT1Ys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WyJ3ZWJwYWNrOi8vcGF5bG9hZC1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L2luZGV4LmNqcz8yOWE2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IgPSByZXF1aXJlKCcuL19jaHVua3MvZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3ItMmJKb2xiTGcuY2pzJyk7XG52YXIgZGVjb21wcmVzc1Jlc3BvbnNlID0gcmVxdWlyZSgnZGVjb21wcmVzcy1yZXNwb25zZScpO1xudmFyIGZvbGxvdyA9IHJlcXVpcmUoJ2ZvbGxvdy1yZWRpcmVjdHMnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB0b1N0cmVhbSA9IHJlcXVpcmUoJ2ludG8tc3RyZWFtJyk7XG52YXIgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbnZhciBwcm9ncmVzc1N0cmVhbSA9IHJlcXVpcmUoJ3Byb2dyZXNzLXN0cmVhbScpO1xudmFyIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciB0dW5uZWwgPSByZXF1aXJlKCd0dW5uZWwtYWdlbnQnKTtcbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdENvbXBhdChlKSB7XG4gIHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7XG4gICAgZGVmYXVsdDogZVxuICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VDb21wYXQoZSkge1xuICBpZiAoZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUpIHJldHVybiBlO1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbi5kZWZhdWx0ID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG52YXIgZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChkZWNvbXByZXNzUmVzcG9uc2UpO1xudmFyIGZvbGxvd19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoZm9sbG93KTtcbnZhciBodHRwX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChodHRwKTtcbnZhciBodHRwc19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoaHR0cHMpO1xudmFyIHRvU3RyZWFtX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdCh0b1N0cmVhbSk7XG52YXIgaXNTdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KGlzU3RyZWFtKTtcbnZhciBwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQocHJvZ3Jlc3NTdHJlYW0pO1xudmFyIHFzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChxcyk7XG52YXIgdXJsX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdCh1cmwpO1xudmFyIHR1bm5lbF9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlQ29tcGF0KHR1bm5lbCk7XG5jb25zdCBtaWRkbGV3YXJlUmVkdWNlciA9IG1pZGRsZXdhcmUgPT4gZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKGhvb2ssIGRlZmF1bHRWYWx1ZSkge1xuICBjb25zdCBiYWlsRWFybHkgPSBob29rID09PSBcIm9uRXJyb3JcIjtcbiAgbGV0IHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaWRkbGV3YXJlW2hvb2tdLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG1pZGRsZXdhcmVbaG9va11baV07XG4gICAgdmFsdWUgPSBoYW5kbGVyKHZhbHVlLCAuLi5hcmdzKTtcbiAgICBpZiAoYmFpbEVhcmx5ICYmICF2YWx1ZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5mdW5jdGlvbiBjcmVhdGVQdWJTdWIoKSB7XG4gIGNvbnN0IHN1YnNjcmliZXJzID0gLyogQF9fUFVSRV9fICovT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG5leHRJZCA9IDA7XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgaWQgPSBuZXh0SWQrKztcbiAgICBzdWJzY3JpYmVyc1tpZF0gPSBzdWJzY3JpYmVyO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1tpZF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwdWJsaXNoKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiBzdWJzY3JpYmVycykge1xuICAgICAgc3Vic2NyaWJlcnNbaWRdKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwdWJsaXNoLFxuICAgIHN1YnNjcmliZVxuICB9O1xufVxuY29uc3QgY2hhbm5lbE5hbWVzID0gW1wicmVxdWVzdFwiLCBcInJlc3BvbnNlXCIsIFwicHJvZ3Jlc3NcIiwgXCJlcnJvclwiLCBcImFib3J0XCJdO1xuY29uc3QgbWlkZGxlaG9va3MgPSBbXCJwcm9jZXNzT3B0aW9uc1wiLCBcInZhbGlkYXRlT3B0aW9uc1wiLCBcImludGVyY2VwdFJlcXVlc3RcIiwgXCJmaW5hbGl6ZU9wdGlvbnNcIiwgXCJvblJlcXVlc3RcIiwgXCJvblJlc3BvbnNlXCIsIFwib25FcnJvclwiLCBcIm9uUmV0dXJuXCIsIFwib25IZWFkZXJzXCJdO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdGVyKGluaXRNaWRkbGV3YXJlLCBodHRwUmVxdWVzdCkge1xuICBjb25zdCBsb2FkZWRNaWRkbGV3YXJlID0gW107XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSBtaWRkbGVob29rcy5yZWR1Y2UoKHdhcmUsIG5hbWUpID0+IHtcbiAgICB3YXJlW25hbWVdID0gd2FyZVtuYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gd2FyZTtcbiAgfSwge1xuICAgIHByb2Nlc3NPcHRpb25zOiBbZGVmYXVsdE9wdGlvbnNWYWxpZGF0b3IucHJvY2Vzc09wdGlvbnNdLFxuICAgIHZhbGlkYXRlT3B0aW9uczogW2RlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnZhbGlkYXRlT3B0aW9uc11cbiAgfSk7XG4gIGZ1bmN0aW9uIHJlcXVlc3Qob3B0cykge1xuICAgIGNvbnN0IG9uUmVzcG9uc2UgPSAocmVxRXJyLCByZXMsIGN0eCkgPT4ge1xuICAgICAgbGV0IGVycm9yID0gcmVxRXJyO1xuICAgICAgbGV0IHJlc3BvbnNlID0gcmVzO1xuICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXBwbHlNaWRkbGV3YXJlKFwib25SZXNwb25zZVwiLCByZXMsIGN0eCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXJyb3IgPSBlcnJvciAmJiBhcHBseU1pZGRsZXdhcmUoXCJvbkVycm9yXCIsIGVycm9yLCBjdHgpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNoYW5uZWxzLmVycm9yLnB1Ymxpc2goZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZSkge1xuICAgICAgICBjaGFubmVscy5yZXNwb25zZS5wdWJsaXNoKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNoYW5uZWxzID0gY2hhbm5lbE5hbWVzLnJlZHVjZSgodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBjcmVhdGVQdWJTdWIoKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGFwcGx5TWlkZGxld2FyZSA9IG1pZGRsZXdhcmVSZWR1Y2VyKG1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcHBseU1pZGRsZXdhcmUoXCJwcm9jZXNzT3B0aW9uc1wiLCBvcHRzKTtcbiAgICBhcHBseU1pZGRsZXdhcmUoXCJ2YWxpZGF0ZU9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFubmVscyxcbiAgICAgIGFwcGx5TWlkZGxld2FyZVxuICAgIH07XG4gICAgbGV0IG9uZ29pbmdSZXF1ZXN0O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gY2hhbm5lbHMucmVxdWVzdC5zdWJzY3JpYmUoY3R4ID0+IHtcbiAgICAgIG9uZ29pbmdSZXF1ZXN0ID0gaHR0cFJlcXVlc3QoY3R4LCAoZXJyLCByZXMpID0+IG9uUmVzcG9uc2UoZXJyLCByZXMsIGN0eCkpO1xuICAgIH0pO1xuICAgIGNoYW5uZWxzLmFib3J0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgaWYgKG9uZ29pbmdSZXF1ZXN0KSB7XG4gICAgICAgIG9uZ29pbmdSZXF1ZXN0LmFib3J0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSBhcHBseU1pZGRsZXdhcmUoXCJvblJldHVyblwiLCBjaGFubmVscywgY29udGV4dCk7XG4gICAgaWYgKHJldHVyblZhbHVlID09PSBjaGFubmVscykge1xuICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cbiAgcmVxdWVzdC51c2UgPSBmdW5jdGlvbiB1c2UobmV3TWlkZGxld2FyZSkge1xuICAgIGlmICghbmV3TWlkZGxld2FyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gYWRkIG1pZGRsZXdhcmUgdGhhdCByZXNvbHZlZCB0byBmYWxzZXkgdmFsdWVcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbmV3TWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBhZGQgbWlkZGxld2FyZSB0aGF0IHdhcyBhIGZ1bmN0aW9uLiBJdCBwcm9iYWJseSBleHBlY3RzIHlvdSB0byBwYXNzIG9wdGlvbnMgdG8gaXQuXCIpO1xuICAgIH1cbiAgICBpZiAobmV3TWlkZGxld2FyZS5vblJldHVybiAmJiBtaWRkbGV3YXJlLm9uUmV0dXJuLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGFkZCBuZXcgbWlkZGxld2FyZSB3aXRoIGBvblJldHVybmAgaGFuZGxlciwgYnV0IGFub3RoZXIgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgZXZlbnRcIik7XG4gICAgfVxuICAgIG1pZGRsZWhvb2tzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChuZXdNaWRkbGV3YXJlW2tleV0pIHtcbiAgICAgICAgbWlkZGxld2FyZVtrZXldLnB1c2gobmV3TWlkZGxld2FyZVtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBsb2FkZWRNaWRkbGV3YXJlLnB1c2gobmV3TWlkZGxld2FyZSk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH07XG4gIHJlcXVlc3QuY2xvbmUgPSAoKSA9PiBjcmVhdGVSZXF1ZXN0ZXIobG9hZGVkTWlkZGxld2FyZSwgaHR0cFJlcXVlc3QpO1xuICBpbml0TWlkZGxld2FyZS5mb3JFYWNoKHJlcXVlc3QudXNlKTtcbiAgcmV0dXJuIHJlcXVlc3Q7XG59XG5mdW5jdGlvbiBsb3dlckNhc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGhlYWRlcnMgfHwge30pLnJlZHVjZSgoYWNjLCBoZWFkZXIpID0+IHtcbiAgICBhY2NbaGVhZGVyLnRvTG93ZXJDYXNlKCldID0gaGVhZGVyc1toZWFkZXJdO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEhvc3RuYW1lKGhvc3RuYW1lKSB7XG4gIHJldHVybiBob3N0bmFtZS5yZXBsYWNlKC9eXFwuKi8sIFwiLlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gcGFyc2VOb1Byb3h5Wm9uZSh6b25lU3RyKSB7XG4gIGNvbnN0IHpvbmUgPSB6b25lU3RyLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCB6b25lUGFydHMgPSB6b25lLnNwbGl0KFwiOlwiLCAyKTtcbiAgY29uc3Qgem9uZUhvc3QgPSBmb3JtYXRIb3N0bmFtZSh6b25lUGFydHNbMF0pO1xuICBjb25zdCB6b25lUG9ydCA9IHpvbmVQYXJ0c1sxXTtcbiAgY29uc3QgaGFzUG9ydCA9IHpvbmUuaW5kZXhPZihcIjpcIikgPiAtMTtcbiAgcmV0dXJuIHtcbiAgICBob3N0bmFtZTogem9uZUhvc3QsXG4gICAgcG9ydDogem9uZVBvcnQsXG4gICAgaGFzUG9ydFxuICB9O1xufVxuZnVuY3Rpb24gdXJpSW5Ob1Byb3h5KHVyaSwgbm9Qcm94eSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQgfHwgKHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiNDQzXCIgOiBcIjgwXCIpO1xuICBjb25zdCBob3N0bmFtZSA9IGZvcm1hdEhvc3RuYW1lKHVyaS5ob3N0bmFtZSk7XG4gIGNvbnN0IG5vUHJveHlMaXN0ID0gbm9Qcm94eS5zcGxpdChcIixcIik7XG4gIHJldHVybiBub1Byb3h5TGlzdC5tYXAocGFyc2VOb1Byb3h5Wm9uZSkuc29tZShub1Byb3h5Wm9uZSA9PiB7XG4gICAgY29uc3QgaXNNYXRjaGVkQXQgPSBob3N0bmFtZS5pbmRleE9mKG5vUHJveHlab25lLmhvc3RuYW1lKTtcbiAgICBjb25zdCBob3N0bmFtZU1hdGNoZWQgPSBpc01hdGNoZWRBdCA+IC0xICYmIGlzTWF0Y2hlZEF0ID09PSBob3N0bmFtZS5sZW5ndGggLSBub1Byb3h5Wm9uZS5ob3N0bmFtZS5sZW5ndGg7XG4gICAgaWYgKG5vUHJveHlab25lLmhhc1BvcnQpIHtcbiAgICAgIHJldHVybiBwb3J0ID09PSBub1Byb3h5Wm9uZS5wb3J0ICYmIGhvc3RuYW1lTWF0Y2hlZDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RuYW1lTWF0Y2hlZDtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUZyb21VcmkodXJpKSB7XG4gIGNvbnN0IG5vUHJveHkgPSBwcm9jZXNzLmVudi5OT19QUk9YWSB8fCBwcm9jZXNzLmVudi5ub19wcm94eSB8fCBcIlwiO1xuICBpZiAobm9Qcm94eSA9PT0gXCIqXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAobm9Qcm94eSAhPT0gXCJcIiAmJiB1cmlJbk5vUHJveHkodXJpLCBub1Byb3h5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh1cmkucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5IVFRQX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgbnVsbDtcbiAgfVxuICBpZiAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkhUVFBTX1BST1hZIHx8IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IHByb2Nlc3MuZW52LkhUVFBfUFJPWFkgfHwgcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SG9zdEZyb21VcmkodXJpKSB7XG4gIGxldCBob3N0ID0gdXJpLmhvc3Q7XG4gIGlmICh1cmkucG9ydCkge1xuICAgIGlmICh1cmkucG9ydCA9PT0gXCI4MFwiICYmIHVyaS5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHVyaS5wb3J0ID09PSBcIjQ0M1wiICYmIHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgICAgaG9zdCA9IHVyaS5ob3N0bmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhvc3Q7XG59XG5mdW5jdGlvbiBnZXRIb3N0SGVhZGVyV2l0aFBvcnQodXJpKSB7XG4gIGNvbnN0IHBvcnQgPSB1cmkucG9ydCB8fCAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiID8gXCI0NDNcIiA6IFwiODBcIik7XG4gIHJldHVybiBcIlwiLmNvbmNhdCh1cmkuaG9zdG5hbWUsIFwiOlwiKS5jb25jYXQocG9ydCk7XG59XG5mdW5jdGlvbiByZXdyaXRlVXJpRm9yUHJveHkocmVxT3B0cywgdXJpLCBwcm94eSkge1xuICBjb25zdCBoZWFkZXJzID0gcmVxT3B0cy5oZWFkZXJzIHx8IHt9O1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxT3B0cywge1xuICAgIGhlYWRlcnNcbiAgfSk7XG4gIGhlYWRlcnMuaG9zdCA9IGhlYWRlcnMuaG9zdCB8fCBnZXRIb3N0SGVhZGVyV2l0aFBvcnQodXJpKTtcbiAgb3B0aW9ucy5wcm90b2NvbCA9IHByb3h5LnByb3RvY29sIHx8IG9wdGlvbnMucHJvdG9jb2w7XG4gIG9wdGlvbnMuaG9zdG5hbWUgPSBwcm94eS5ob3N0LnJlcGxhY2UoLzpcXGQrLywgXCJcIik7XG4gIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQ7XG4gIG9wdGlvbnMuaG9zdCA9IGdldEhvc3RGcm9tVXJpKE9iamVjdC5hc3NpZ24oe30sIHVyaSwgcHJveHkpKTtcbiAgb3B0aW9ucy5ocmVmID0gXCJcIi5jb25jYXQob3B0aW9ucy5wcm90b2NvbCwgXCIvL1wiKS5jb25jYXQob3B0aW9ucy5ob3N0KS5jb25jYXQob3B0aW9ucy5wYXRoKTtcbiAgb3B0aW9ucy5wYXRoID0gdXJsX19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0KHVyaSk7XG4gIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IHByb3h5O1xuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcInByb3h5XCIpKSB7XG4gICAgcHJveHkgPSBvcHRpb25zLnByb3h5O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHVyaSA9IHVybF9fZGVmYXVsdC5kZWZhdWx0LnBhcnNlKG9wdGlvbnMudXJsKTtcbiAgICBwcm94eSA9IGdldFByb3h5RnJvbVVyaSh1cmkpO1xuICB9XG4gIHJldHVybiB0eXBlb2YgcHJveHkgPT09IFwic3RyaW5nXCIgPyB1cmxfX2RlZmF1bHQuZGVmYXVsdC5wYXJzZShwcm94eSkgOiBwcm94eTtcbn1cblxuLyohIHNpbXBsZS1jb25jYXQuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmZ1bmN0aW9uIGNvbmNhdChzdHJlYW0sIGNiKSB7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBzdHJlYW0ub24oXCJkYXRhXCIsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgfSk7XG4gIHN0cmVhbS5vbmNlKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIGNiKG51bGwsIEJ1ZmZlci5jb25jYXQoY2h1bmtzKSk7XG4gICAgY2IgPSBudWxsO1xuICB9KTtcbiAgc3RyZWFtLm9uY2UoXCJlcnJvclwiLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNiKSBjYihlcnIpO1xuICAgIGNiID0gbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiB0aW1lZE91dChyZXEsIHRpbWUpIHtcbiAgaWYgKHJlcS50aW1lb3V0VGltZXIpIHtcbiAgICByZXR1cm4gcmVxO1xuICB9XG4gIGNvbnN0IGRlbGF5cyA9IGlzTmFOKHRpbWUpID8gdGltZSA6IHtcbiAgICBzb2NrZXQ6IHRpbWUsXG4gICAgY29ubmVjdDogdGltZVxuICB9O1xuICBjb25zdCBob3N0SGVhZGVyID0gcmVxLmdldEhlYWRlcihcImhvc3RcIik7XG4gIGNvbnN0IGhvc3QgPSBob3N0SGVhZGVyID8gXCIgdG8gXCIgKyBob3N0SGVhZGVyIDogXCJcIjtcbiAgaWYgKGRlbGF5cy5jb25uZWN0ICE9PSB2b2lkIDApIHtcbiAgICByZXEudGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0SGFuZGxlcigpIHtcbiAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgIHJlcS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgfSwgZGVsYXlzLmNvbm5lY3QpO1xuICB9XG4gIHJlcS5vbihcInNvY2tldFwiLCBmdW5jdGlvbiBhc3NpZ24oc29ja2V0KSB7XG4gICAgaWYgKCEoc29ja2V0LmNvbm5lY3RpbmcgfHwgc29ja2V0Ll9jb25uZWN0aW5nKSkge1xuICAgICAgY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzb2NrZXQub25jZShcImNvbm5lY3RcIiwgY29ubmVjdCk7XG4gIH0pO1xuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAocmVxLnRpbWVvdXRUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHJlcS50aW1lb3V0VGltZXIpO1xuICAgICAgcmVxLnRpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgY2xlYXIoKTtcbiAgICBpZiAoZGVsYXlzLnNvY2tldCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXEuc2V0VGltZW91dChkZWxheXMuc29ja2V0LCBmdW5jdGlvbiBzb2NrZXRUaW1lb3V0SGFuZGxlcigpIHtcbiAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXCJTb2NrZXQgdGltZWQgb3V0IG9uIHJlcXVlc3RcIiArIGhvc3QpO1xuICAgICAgICBlLmNvZGUgPSBcIkVTT0NLRVRUSU1FRE9VVFwiO1xuICAgICAgICByZXEuZW1pdChcImVycm9yXCIsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXEub24oXCJlcnJvclwiLCBjbGVhcik7XG59XG5jb25zdCB1cmlQYXJ0cyA9IFtcInByb3RvY29sXCIsIFwic2xhc2hlc1wiLCBcImF1dGhcIiwgXCJob3N0XCIsIFwicG9ydFwiLCBcImhvc3RuYW1lXCIsIFwiaGFzaFwiLCBcInNlYXJjaFwiLCBcInF1ZXJ5XCIsIFwicGF0aG5hbWVcIiwgXCJwYXRoXCIsIFwiaHJlZlwiXTtcbmNvbnN0IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCA9IFtcImFjY2VwdFwiLCBcImFjY2VwdC1jaGFyc2V0XCIsIFwiYWNjZXB0LWVuY29kaW5nXCIsIFwiYWNjZXB0LWxhbmd1YWdlXCIsIFwiYWNjZXB0LXJhbmdlc1wiLCBcImNhY2hlLWNvbnRyb2xcIiwgXCJjb250ZW50LWVuY29kaW5nXCIsIFwiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtbG9jYXRpb25cIiwgXCJjb250ZW50LW1kNVwiLCBcImNvbnRlbnQtcmFuZ2VcIiwgXCJjb250ZW50LXR5cGVcIiwgXCJjb25uZWN0aW9uXCIsIFwiZGF0ZVwiLCBcImV4cGVjdFwiLCBcIm1heC1mb3J3YXJkc1wiLCBcInByYWdtYVwiLCBcInJlZmVyZXJcIiwgXCJ0ZVwiLCBcInVzZXItYWdlbnRcIiwgXCJ2aWFcIl07XG5jb25zdCBkZWZhdWx0UHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0ID0gW1wicHJveHktYXV0aG9yaXphdGlvblwiXTtcbmZ1bmN0aW9uIHNob3VsZEVuYWJsZShvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy50dW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihvcHRpb25zLnR1bm5lbCk7XG4gIH1cbiAgY29uc3QgdXJpID0gdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpO1xuICBpZiAodXJpLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXBwbHlBZ2VudCgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBsZXQgcHJveHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpO1xuICBjb25zdCBwcm94eUhlYWRlcldoaXRlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdC5jb25jYXQob3B0aW9ucy5wcm94eUhlYWRlcldoaXRlTGlzdCB8fCBbXSkubWFwKGhlYWRlciA9PiBoZWFkZXIudG9Mb3dlckNhc2UoKSk7XG4gIGNvbnN0IHByb3h5SGVhZGVyRXhjbHVzaXZlTGlzdCA9IGRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QuY29uY2F0KG9wdGlvbnMucHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0IHx8IFtdKS5tYXAoaGVhZGVyID0+IGhlYWRlci50b0xvd2VyQ2FzZSgpKTtcbiAgY29uc3QgcHJveHlIZWFkZXJzID0gZ2V0QWxsb3dlZFByb3h5SGVhZGVycyhvcHRpb25zLmhlYWRlcnMsIHByb3h5SGVhZGVyV2hpdGVMaXN0KTtcbiAgcHJveHlIZWFkZXJzLmhvc3QgPSBjb25zdHJ1Y3RQcm94eUhvc3Qob3B0aW9ucyk7XG4gIG9wdGlvbnMuaGVhZGVycyA9IE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkucmVkdWNlKChoZWFkZXJzLCBoZWFkZXIpID0+IHtcbiAgICBjb25zdCBpc0FsbG93ZWQgPSBwcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuICAgIGlmIChpc0FsbG93ZWQpIHtcbiAgICAgIGhlYWRlcnNbaGVhZGVyXSA9IG9wdGlvbnMuaGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwge30pO1xuICBjb25zdCB0dW5uZWxGbiA9IGdldFR1bm5lbEZuKG9wdGlvbnMsIHByb3h5KTtcbiAgY29uc3QgdHVubmVsT3B0aW9ucyA9IGNvbnN0cnVjdFR1bm5lbE9wdGlvbnMob3B0aW9ucywgcHJveHksIHByb3h5SGVhZGVycyk7XG4gIG9wdGlvbnMuYWdlbnQgPSB0dW5uZWxGbih0dW5uZWxPcHRpb25zKTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBnZXRUdW5uZWxGbihvcHRpb25zLCBwcm94eSkge1xuICBjb25zdCB1cmkgPSBnZXRVcmlQYXJ0cyhvcHRpb25zKTtcbiAgY29uc3QgdHVubmVsRm5OYW1lID0gY29uc3RydWN0VHVubmVsRm5OYW1lKHVyaSwgcHJveHkpO1xuICByZXR1cm4gdHVubmVsX19uYW1lc3BhY2VbdHVubmVsRm5OYW1lXTtcbn1cbmZ1bmN0aW9uIGdldFVyaVBhcnRzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHVyaVBhcnRzLnJlZHVjZSgodXJpLCBwYXJ0KSA9PiB7XG4gICAgdXJpW3BhcnRdID0gb3B0aW9uc1twYXJ0XTtcbiAgICByZXR1cm4gdXJpO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjb25zdHJ1Y3RUdW5uZWxGbk5hbWUodXJpLCBwcm94eSkge1xuICBjb25zdCB1cmlQcm90b2NvbCA9IHVyaS5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICBjb25zdCBwcm94eVByb3RvY29sID0gcHJveHkucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIkh0dHBzXCIgOiBcIkh0dHBcIjtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHVyaVByb3RvY29sLCBcIk92ZXJcIikuY29uY2F0KHByb3h5UHJvdG9jb2wpO1xufVxuZnVuY3Rpb24gY29uc3RydWN0UHJveHlIb3N0KHVyaSkge1xuICBjb25zdCBwb3J0ID0gdXJpLnBvcnQ7XG4gIGNvbnN0IHByb3RvY29sID0gdXJpLnByb3RvY29sO1xuICBsZXQgcHJveHlIb3N0ID0gXCJcIi5jb25jYXQodXJpLmhvc3RuYW1lLCBcIjpcIik7XG4gIGlmIChwb3J0KSB7XG4gICAgcHJveHlIb3N0ICs9IHBvcnQ7XG4gIH0gZWxzZSBpZiAocHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICBwcm94eUhvc3QgKz0gXCI0NDNcIjtcbiAgfSBlbHNlIHtcbiAgICBwcm94eUhvc3QgKz0gXCI4MFwiO1xuICB9XG4gIHJldHVybiBwcm94eUhvc3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxvd2VkUHJveHlIZWFkZXJzKGhlYWRlcnMsIHdoaXRlTGlzdCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMoaGVhZGVycykuZmlsdGVyKGhlYWRlciA9PiB3aGl0ZUxpc3QuaW5kZXhPZihoZWFkZXIudG9Mb3dlckNhc2UoKSkgIT09IC0xKS5yZWR1Y2UoKHNldCwgaGVhZGVyKSA9PiB7XG4gICAgc2V0W2hlYWRlcl0gPSBoZWFkZXJzW2hlYWRlcl07XG4gICAgcmV0dXJuIHNldDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gY29uc3RydWN0VHVubmVsT3B0aW9ucyhvcHRpb25zLCBwcm94eSwgcHJveHlIZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJveHk6IHtcbiAgICAgIGhvc3Q6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgcG9ydDogK3Byb3h5LnBvcnQsXG4gICAgICBwcm94eUF1dGg6IHByb3h5LmF1dGgsXG4gICAgICBoZWFkZXJzOiBwcm94eUhlYWRlcnNcbiAgICB9LFxuICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICBjYTogb3B0aW9ucy5jYSxcbiAgICBjZXJ0OiBvcHRpb25zLmNlcnQsXG4gICAga2V5OiBvcHRpb25zLmtleSxcbiAgICBwYXNzcGhyYXNlOiBvcHRpb25zLnBhc3NwaHJhc2UsXG4gICAgcGZ4OiBvcHRpb25zLnBmeCxcbiAgICBjaXBoZXJzOiBvcHRpb25zLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCxcbiAgICBzZWN1cmVPcHRpb25zOiBvcHRpb25zLnNlY3VyZU9wdGlvbnMsXG4gICAgc2VjdXJlUHJvdG9jb2w6IG9wdGlvbnMuc2VjdXJlUHJvdG9jb2xcbiAgfTtcbn1cbmNvbnN0IGFkYXB0ZXIgPSBcIm5vZGVcIjtcbmNvbnN0IHJlZHVjZVJlc3BvbnNlID0gKHJlcywgcmVxVXJsLCBtZXRob2QsIGJvZHkpID0+ICh7XG4gIGJvZHksXG4gIHVybDogcmVxVXJsLFxuICBtZXRob2QsXG4gIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICBzdGF0dXNDb2RlOiByZXMuc3RhdHVzQ29kZSxcbiAgc3RhdHVzTWVzc2FnZTogcmVzLnN0YXR1c01lc3NhZ2Vcbn0pO1xuY29uc3QgaHR0cFJlcXVlc3RlciA9IChjb250ZXh0LCBjYikgPT4ge1xuICBjb25zdCB7XG4gICAgb3B0aW9uc1xuICB9ID0gY29udGV4dDtcbiAgY29uc3QgdXJpID0gT2JqZWN0LmFzc2lnbih7fSwgdXJsX19kZWZhdWx0LmRlZmF1bHQucGFyc2Uob3B0aW9ucy51cmwpKTtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiICYmIG9wdGlvbnMuZmV0Y2gpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHJlcU9wdHMyID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJmaW5hbGl6ZU9wdGlvbnNcIiwge1xuICAgICAgLi4udXJpLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uKHR5cGVvZiBvcHRpb25zLmZldGNoID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuZmV0Y2guaGVhZGVycyA/IGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5mZXRjaC5oZWFkZXJzKSA6IHt9KSxcbiAgICAgICAgLi4ubG93ZXJDYXNlSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gICAgICB9LFxuICAgICAgbWF4UmVkaXJlY3RzOiBvcHRpb25zLm1heFJlZGlyZWN0c1xuICAgIH0pO1xuICAgIGNvbnN0IGZldGNoT3B0cyA9IHtcbiAgICAgIGNyZWRlbnRpYWxzOiBvcHRpb25zLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICAuLi4odHlwZW9mIG9wdGlvbnMuZmV0Y2ggPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmZldGNoIDoge30pLFxuICAgICAgbWV0aG9kOiByZXFPcHRzMi5tZXRob2QsXG4gICAgICBoZWFkZXJzOiByZXFPcHRzMi5oZWFkZXJzLFxuICAgICAgYm9keTogb3B0aW9ucy5ib2R5LFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgIH07XG4gICAgY29uc3QgaW5qZWN0ZWRSZXNwb25zZTIgPSBjb250ZXh0LmFwcGx5TWlkZGxld2FyZShcImludGVyY2VwdFJlcXVlc3RcIiwgdm9pZCAwLCB7XG4gICAgICBhZGFwdGVyLFxuICAgICAgY29udGV4dFxuICAgIH0pO1xuICAgIGlmIChpbmplY3RlZFJlc3BvbnNlMikge1xuICAgICAgY29uc3QgY2JUaW1lciA9IHNldFRpbWVvdXQoY2IsIDAsIG51bGwsIGluamVjdGVkUmVzcG9uc2UyKTtcbiAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IGNsZWFyVGltZW91dChjYlRpbWVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFib3J0OiBjYW5jZWxcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3QyID0gZmV0Y2gob3B0aW9ucy51cmwsIGZldGNoT3B0cyk7XG4gICAgY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvblJlcXVlc3RcIiwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIGFkYXB0ZXIsXG4gICAgICByZXF1ZXN0OiByZXF1ZXN0MixcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICByZXF1ZXN0Mi50aGVuKGFzeW5jIHJlcyA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5yYXdCb2R5ID8gcmVzLmJvZHkgOiBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgcmVzLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgY2IobnVsbCwge1xuICAgICAgICBib2R5LFxuICAgICAgICB1cmw6IHJlcy51cmwsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXMsXG4gICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlcy5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKGVyci5uYW1lID09IFwiQWJvcnRFcnJvclwiKSByZXR1cm47XG4gICAgICBjYihlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBhYm9ydDogKCkgPT4gY29udHJvbGxlci5hYm9ydCgpXG4gICAgfTtcbiAgfVxuICBjb25zdCBib2R5VHlwZSA9IGlzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQob3B0aW9ucy5ib2R5KSA/IFwic3RyZWFtXCIgOiB0eXBlb2Ygb3B0aW9ucy5ib2R5O1xuICBpZiAoYm9keVR5cGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYm9keVR5cGUgIT09IFwic3RyZWFtXCIgJiYgYm9keVR5cGUgIT09IFwic3RyaW5nXCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihvcHRpb25zLmJvZHkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWVzdCBib2R5IG11c3QgYmUgYSBzdHJpbmcsIGJ1ZmZlciBvciBzdHJlYW0sIGdvdCBcIi5jb25jYXQoYm9keVR5cGUpKTtcbiAgfVxuICBjb25zdCBsZW5ndGhIZWFkZXIgPSB7fTtcbiAgaWYgKG9wdGlvbnMuYm9keVNpemUpIHtcbiAgICBsZW5ndGhIZWFkZXJbXCJjb250ZW50LWxlbmd0aFwiXSA9IG9wdGlvbnMuYm9keVNpemU7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ib2R5ICYmIGJvZHlUeXBlICE9PSBcInN0cmVhbVwiKSB7XG4gICAgbGVuZ3RoSGVhZGVyW1wiY29udGVudC1sZW5ndGhcIl0gPSBCdWZmZXIuYnl0ZUxlbmd0aChvcHRpb25zLmJvZHkpO1xuICB9XG4gIGxldCBhYm9ydGVkID0gZmFsc2U7XG4gIGNvbnN0IGNhbGxiYWNrID0gKGVyciwgcmVzKSA9PiAhYWJvcnRlZCAmJiBjYihlcnIsIHJlcyk7XG4gIGNvbnRleHQuY2hhbm5lbHMuYWJvcnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCByZXFPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdXJpLCB7XG4gICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBsb3dlckNhc2VIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyksIGxlbmd0aEhlYWRlciksXG4gICAgbWF4UmVkaXJlY3RzOiBvcHRpb25zLm1heFJlZGlyZWN0c1xuICB9KTtcbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eU9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IHR1bm5lbCA9IHByb3h5ICYmIHNob3VsZEVuYWJsZShvcHRpb25zKTtcbiAgY29uc3QgaW5qZWN0ZWRSZXNwb25zZSA9IGNvbnRleHQuYXBwbHlNaWRkbGV3YXJlKFwiaW50ZXJjZXB0UmVxdWVzdFwiLCB2b2lkIDAsIHtcbiAgICBhZGFwdGVyLFxuICAgIGNvbnRleHRcbiAgfSk7XG4gIGlmIChpbmplY3RlZFJlc3BvbnNlKSB7XG4gICAgY29uc3QgY2JUaW1lciA9IHNldEltbWVkaWF0ZShjYWxsYmFjaywgbnVsbCwgaW5qZWN0ZWRSZXNwb25zZSk7XG4gICAgY29uc3QgYWJvcnQgPSAoKSA9PiBjbGVhckltbWVkaWF0ZShjYlRpbWVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWJvcnRcbiAgICB9O1xuICB9XG4gIGlmIChvcHRpb25zLm1heFJlZGlyZWN0cyAhPT0gMCkge1xuICAgIHJlcU9wdHMubWF4UmVkaXJlY3RzID0gb3B0aW9ucy5tYXhSZWRpcmVjdHMgfHwgNTtcbiAgfVxuICBpZiAocHJveHkgJiYgdHVubmVsKSB7XG4gICAgcmVxT3B0cyA9IGFwcGx5QWdlbnQocmVxT3B0cywgcHJveHkpO1xuICB9IGVsc2UgaWYgKHByb3h5ICYmICF0dW5uZWwpIHtcbiAgICByZXFPcHRzID0gcmV3cml0ZVVyaUZvclByb3h5KHJlcU9wdHMsIHVyaSwgcHJveHkpO1xuICB9XG4gIGlmICghdHVubmVsICYmIHByb3h5ICYmIHByb3h5LmF1dGggJiYgIXJlcU9wdHMuaGVhZGVyc1tcInByb3h5LWF1dGhvcml6YXRpb25cIl0pIHtcbiAgICBjb25zdCBbdXNlcm5hbWUsIHBhc3N3b3JkXSA9IHByb3h5LmF1dGgudXNlcm5hbWUgPyBbcHJveHkuYXV0aC51c2VybmFtZSwgcHJveHkuYXV0aC5wYXNzd29yZF0gOiBwcm94eS5hdXRoLnNwbGl0KFwiOlwiKS5tYXAoaXRlbSA9PiBxc19fZGVmYXVsdC5kZWZhdWx0LnVuZXNjYXBlKGl0ZW0pKTtcbiAgICBjb25zdCBhdXRoID0gQnVmZmVyLmZyb20oXCJcIi5jb25jYXQodXNlcm5hbWUsIFwiOlwiKS5jb25jYXQocGFzc3dvcmQpLCBcInV0ZjhcIik7XG4gICAgY29uc3QgYXV0aEJhc2U2NCA9IGF1dGgudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgcmVxT3B0cy5oZWFkZXJzW1wicHJveHktYXV0aG9yaXphdGlvblwiXSA9IFwiQmFzaWMgXCIuY29uY2F0KGF1dGhCYXNlNjQpO1xuICB9XG4gIGNvbnN0IHRyYW5zcG9ydCA9IGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbCk7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWJ1ZyA9PT0gXCJmdW5jdGlvblwiICYmIHByb3h5KSB7XG4gICAgb3B0aW9ucy5kZWJ1ZyhcIlByb3h5aW5nIHVzaW5nICVzXCIsIHJlcU9wdHMuYWdlbnQgPyBcInR1bm5lbCBhZ2VudFwiIDogXCJcIi5jb25jYXQocmVxT3B0cy5ob3N0LCBcIjpcIikuY29uY2F0KHJlcU9wdHMucG9ydCkpO1xuICB9XG4gIGNvbnN0IHRyeUNvbXByZXNzZWQgPSByZXFPcHRzLm1ldGhvZCAhPT0gXCJIRUFEXCI7XG4gIGlmICh0cnlDb21wcmVzc2VkICYmICFyZXFPcHRzLmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gJiYgb3B0aW9ucy5jb21wcmVzcyAhPT0gZmFsc2UpIHtcbiAgICByZXFPcHRzLmhlYWRlcnNbXCJhY2NlcHQtZW5jb2RpbmdcIl0gPSBcImJyLCBnemlwLCBkZWZsYXRlXCI7XG4gIH1cbiAgY29uc3QgZmluYWxPcHRpb25zID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJmaW5hbGl6ZU9wdGlvbnNcIiwgcmVxT3B0cyk7XG4gIGNvbnN0IHJlcXVlc3QgPSB0cmFuc3BvcnQucmVxdWVzdChmaW5hbE9wdGlvbnMsIHJlc3BvbnNlID0+IHtcbiAgICBjb25zdCByZXMgPSB0cnlDb21wcmVzc2VkID8gZGVjb21wcmVzc1Jlc3BvbnNlX19kZWZhdWx0LmRlZmF1bHQocmVzcG9uc2UpIDogcmVzcG9uc2U7XG4gICAgY29uc3QgcmVzU3RyZWFtID0gY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvbkhlYWRlcnNcIiwgcmVzLCB7XG4gICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgYWRhcHRlcixcbiAgICAgIGNvbnRleHRcbiAgICB9KTtcbiAgICBjb25zdCByZXFVcmwgPSBcInJlc3BvbnNlVXJsXCIgaW4gcmVzcG9uc2UgPyByZXNwb25zZS5yZXNwb25zZVVybCA6IG9wdGlvbnMudXJsO1xuICAgIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVkdWNlUmVzcG9uc2UocmVzLCByZXFVcmwsIHJlcU9wdHMubWV0aG9kLCByZXNTdHJlYW0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uY2F0KHJlc1N0cmVhbSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLnJhd0JvZHkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcmVkdWNlZCA9IHJlZHVjZVJlc3BvbnNlKHJlcywgcmVxVXJsLCByZXFPcHRzLm1ldGhvZCwgYm9keSk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVkdWNlZCk7XG4gICAgfSk7XG4gIH0pO1xuICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgdGltZWRPdXQocmVxdWVzdCwgb3B0aW9ucy50aW1lb3V0KTtcbiAgfVxuICByZXF1ZXN0Lm9uY2UoXCJlcnJvclwiLCBjYWxsYmFjayk7XG4gIGNvbnN0IHtcbiAgICBib2R5U3RyZWFtLFxuICAgIHByb2dyZXNzXG4gIH0gPSBnZXRQcm9ncmVzc1N0cmVhbShvcHRpb25zKTtcbiAgY29udGV4dC5hcHBseU1pZGRsZXdhcmUoXCJvblJlcXVlc3RcIiwge1xuICAgIG9wdGlvbnMsXG4gICAgYWRhcHRlcixcbiAgICByZXF1ZXN0LFxuICAgIGNvbnRleHQsXG4gICAgcHJvZ3Jlc3NcbiAgfSk7XG4gIGlmIChib2R5U3RyZWFtKSB7XG4gICAgYm9keVN0cmVhbS5waXBlKHJlcXVlc3QpO1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuZW5kKG9wdGlvbnMuYm9keSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhYm9ydDogKCkgPT4gcmVxdWVzdC5hYm9ydCgpXG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NTdHJlYW0ob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuYm9keSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBib2R5SXNTdHJlYW0gPSBpc1N0cmVhbV9fZGVmYXVsdC5kZWZhdWx0KG9wdGlvbnMuYm9keSk7XG4gIGNvbnN0IGxlbmd0aCA9IG9wdGlvbnMuYm9keVNpemUgfHwgKGJvZHlJc1N0cmVhbSA/IG51bGwgOiBCdWZmZXIuYnl0ZUxlbmd0aChvcHRpb25zLmJvZHkpKTtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gYm9keUlzU3RyZWFtID8ge1xuICAgICAgYm9keVN0cmVhbTogb3B0aW9ucy5ib2R5XG4gICAgfSA6IHt9O1xuICB9XG4gIGNvbnN0IHByb2dyZXNzID0gcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQuZGVmYXVsdCh7XG4gICAgdGltZTogMTYsXG4gICAgbGVuZ3RoXG4gIH0pO1xuICBjb25zdCBib2R5U3RyZWFtID0gYm9keUlzU3RyZWFtID8gb3B0aW9ucy5ib2R5IDogdG9TdHJlYW1fX2RlZmF1bHQuZGVmYXVsdChvcHRpb25zLmJvZHkpO1xuICByZXR1cm4ge1xuICAgIGJvZHlTdHJlYW06IGJvZHlTdHJlYW0ucGlwZShwcm9ncmVzcyksXG4gICAgcHJvZ3Jlc3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RUcmFuc3BvcnQocmVxT3B0cywgcHJveHksIHR1bm5lbCkge1xuICBjb25zdCBpc0h0dHBzUmVxdWVzdCA9IHJlcU9wdHMucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIGNvbnN0IHRyYW5zcG9ydHMgPSByZXFPcHRzLm1heFJlZGlyZWN0cyA9PT0gMCA/IHtcbiAgICBodHRwOiBodHRwX19kZWZhdWx0LmRlZmF1bHQsXG4gICAgaHR0cHM6IGh0dHBzX19kZWZhdWx0LmRlZmF1bHRcbiAgfSA6IHtcbiAgICBodHRwOiBmb2xsb3dfX2RlZmF1bHQuZGVmYXVsdC5odHRwLFxuICAgIGh0dHBzOiBmb2xsb3dfX2RlZmF1bHQuZGVmYXVsdC5odHRwc1xuICB9O1xuICBpZiAoIXByb3h5IHx8IHR1bm5lbCkge1xuICAgIHJldHVybiBpc0h0dHBzUmVxdWVzdCA/IHRyYW5zcG9ydHMuaHR0cHMgOiB0cmFuc3BvcnRzLmh0dHA7XG4gIH1cbiAgbGV0IGlzSHR0cHNQcm94eSA9IHByb3h5LnBvcnQgPT09IDQ0MztcbiAgaWYgKHByb3h5LnByb3RvY29sKSB7XG4gICAgaXNIdHRwc1Byb3h5ID0gL15odHRwczo/Ly50ZXN0KHByb3h5LnByb3RvY29sKTtcbiAgfVxuICByZXR1cm4gaXNIdHRwc1Byb3h5ID8gdHJhbnNwb3J0cy5odHRwcyA6IHRyYW5zcG9ydHMuaHR0cDtcbn1cbmNvbnN0IGdldEl0ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgaW5pdE1pZGRsZXdhcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFtdO1xuICBsZXQgaHR0cFJlcXVlc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGh0dHBSZXF1ZXN0ZXI7XG4gIHJldHVybiBjcmVhdGVSZXF1ZXN0ZXIoaW5pdE1pZGRsZXdhcmUsIGh0dHBSZXF1ZXN0KTtcbn07XG5jb25zdCBlbnZpcm9ubWVudCA9IFwibm9kZVwiO1xuZXhwb3J0cy5hZGFwdGVyID0gYWRhcHRlcjtcbmV4cG9ydHMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbmV4cG9ydHMuZ2V0SXQgPSBnZXRJdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmNqcy5tYXBcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHRPcHRpb25zVmFsaWRhdG9yIiwicmVxdWlyZSIsImRlY29tcHJlc3NSZXNwb25zZSIsImZvbGxvdyIsImh0dHAiLCJodHRwcyIsInRvU3RyZWFtIiwiaXNTdHJlYW0iLCJwcm9ncmVzc1N0cmVhbSIsInFzIiwidXJsIiwidHVubmVsIiwiX2ludGVyb3BEZWZhdWx0Q29tcGF0IiwiZSIsImRlZmF1bHQiLCJfaW50ZXJvcE5hbWVzcGFjZUNvbXBhdCIsIm4iLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZyZWV6ZSIsImRlY29tcHJlc3NSZXNwb25zZV9fZGVmYXVsdCIsImZvbGxvd19fZGVmYXVsdCIsImh0dHBfX2RlZmF1bHQiLCJodHRwc19fZGVmYXVsdCIsInRvU3RyZWFtX19kZWZhdWx0IiwiaXNTdHJlYW1fX2RlZmF1bHQiLCJwcm9ncmVzc1N0cmVhbV9fZGVmYXVsdCIsInFzX19kZWZhdWx0IiwidXJsX19kZWZhdWx0IiwidHVubmVsX19uYW1lc3BhY2UiLCJtaWRkbGV3YXJlUmVkdWNlciIsIm1pZGRsZXdhcmUiLCJhcHBseU1pZGRsZXdhcmUiLCJob29rIiwiZGVmYXVsdFZhbHVlIiwiYmFpbEVhcmx5IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJpIiwiaGFuZGxlciIsImNyZWF0ZVB1YlN1YiIsInN1YnNjcmliZXJzIiwibmV4dElkIiwic3Vic2NyaWJlIiwic3Vic2NyaWJlciIsImlkIiwidW5zdWJzY3JpYmUiLCJwdWJsaXNoIiwiZXZlbnQiLCJjaGFubmVsTmFtZXMiLCJtaWRkbGVob29rcyIsImNyZWF0ZVJlcXVlc3RlciIsImluaXRNaWRkbGV3YXJlIiwiaHR0cFJlcXVlc3QiLCJsb2FkZWRNaWRkbGV3YXJlIiwicmVkdWNlIiwid2FyZSIsIm5hbWUiLCJwcm9jZXNzT3B0aW9ucyIsInZhbGlkYXRlT3B0aW9ucyIsInJlcXVlc3QiLCJvcHRzIiwib25SZXNwb25zZSIsInJlcUVyciIsInJlcyIsImN0eCIsImVycm9yIiwicmVzcG9uc2UiLCJlcnIiLCJjaGFubmVscyIsInRhcmdldCIsIm9wdGlvbnMiLCJjb250ZXh0Iiwib25nb2luZ1JlcXVlc3QiLCJhYm9ydCIsInJldHVyblZhbHVlIiwidXNlIiwibmV3TWlkZGxld2FyZSIsIkVycm9yIiwib25SZXR1cm4iLCJrZXkiLCJwdXNoIiwiY2xvbmUiLCJsb3dlckNhc2VIZWFkZXJzIiwiaGVhZGVycyIsImFjYyIsImhlYWRlciIsInRvTG93ZXJDYXNlIiwiZm9ybWF0SG9zdG5hbWUiLCJob3N0bmFtZSIsInJlcGxhY2UiLCJwYXJzZU5vUHJveHlab25lIiwiem9uZVN0ciIsInpvbmUiLCJ0cmltIiwiem9uZVBhcnRzIiwic3BsaXQiLCJ6b25lSG9zdCIsInpvbmVQb3J0IiwiaGFzUG9ydCIsImluZGV4T2YiLCJwb3J0IiwidXJpSW5Ob1Byb3h5IiwidXJpIiwibm9Qcm94eSIsInByb3RvY29sIiwibm9Qcm94eUxpc3QiLCJtYXAiLCJzb21lIiwibm9Qcm94eVpvbmUiLCJpc01hdGNoZWRBdCIsImhvc3RuYW1lTWF0Y2hlZCIsImdldFByb3h5RnJvbVVyaSIsInByb2Nlc3MiLCJlbnYiLCJOT19QUk9YWSIsIm5vX3Byb3h5IiwiSFRUUF9QUk9YWSIsImh0dHBfcHJveHkiLCJIVFRQU19QUk9YWSIsImh0dHBzX3Byb3h5IiwiZ2V0SG9zdEZyb21VcmkiLCJob3N0IiwiZ2V0SG9zdEhlYWRlcldpdGhQb3J0IiwiY29uY2F0IiwicmV3cml0ZVVyaUZvclByb3h5IiwicmVxT3B0cyIsInByb3h5IiwiYXNzaWduIiwiaHJlZiIsInBhdGgiLCJmb3JtYXQiLCJnZXRQcm94eU9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnNlIiwic3RyZWFtIiwiY2IiLCJjaHVua3MiLCJvbiIsImNodW5rIiwib25jZSIsIkJ1ZmZlciIsInRpbWVkT3V0IiwicmVxIiwidGltZSIsInRpbWVvdXRUaW1lciIsImRlbGF5cyIsImlzTmFOIiwic29ja2V0IiwiY29ubmVjdCIsImhvc3RIZWFkZXIiLCJnZXRIZWFkZXIiLCJzZXRUaW1lb3V0IiwidGltZW91dEhhbmRsZXIiLCJjb2RlIiwiZW1pdCIsImNvbm5lY3RpbmciLCJfY29ubmVjdGluZyIsImNsZWFyIiwiY2xlYXJUaW1lb3V0Iiwic29ja2V0VGltZW91dEhhbmRsZXIiLCJ1cmlQYXJ0cyIsImRlZmF1bHRQcm94eUhlYWRlcldoaXRlTGlzdCIsImRlZmF1bHRQcm94eUhlYWRlckV4Y2x1c2l2ZUxpc3QiLCJzaG91bGRFbmFibGUiLCJCb29sZWFuIiwiYXBwbHlBZ2VudCIsInVuZGVmaW5lZCIsInByb3h5SGVhZGVyV2hpdGVMaXN0IiwicHJveHlIZWFkZXJFeGNsdXNpdmVMaXN0IiwicHJveHlIZWFkZXJzIiwiZ2V0QWxsb3dlZFByb3h5SGVhZGVycyIsImNvbnN0cnVjdFByb3h5SG9zdCIsImlzQWxsb3dlZCIsInR1bm5lbEZuIiwiZ2V0VHVubmVsRm4iLCJ0dW5uZWxPcHRpb25zIiwiY29uc3RydWN0VHVubmVsT3B0aW9ucyIsImFnZW50IiwiZ2V0VXJpUGFydHMiLCJ0dW5uZWxGbk5hbWUiLCJjb25zdHJ1Y3RUdW5uZWxGbk5hbWUiLCJwYXJ0IiwidXJpUHJvdG9jb2wiLCJwcm94eVByb3RvY29sIiwicHJveHlIb3N0Iiwid2hpdGVMaXN0IiwiZmlsdGVyIiwic2V0IiwicHJveHlBdXRoIiwiYXV0aCIsImNhIiwiY2VydCIsInBhc3NwaHJhc2UiLCJwZngiLCJjaXBoZXJzIiwicmVqZWN0VW5hdXRob3JpemVkIiwic2VjdXJlT3B0aW9ucyIsInNlY3VyZVByb3RvY29sIiwiYWRhcHRlciIsInJlZHVjZVJlc3BvbnNlIiwicmVxVXJsIiwibWV0aG9kIiwiYm9keSIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiaHR0cFJlcXVlc3RlciIsImZldGNoIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInJlcU9wdHMyIiwibWF4UmVkaXJlY3RzIiwiZmV0Y2hPcHRzIiwiY3JlZGVudGlhbHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJzaWduYWwiLCJpbmplY3RlZFJlc3BvbnNlMiIsImNiVGltZXIiLCJjYW5jZWwiLCJyZXF1ZXN0MiIsInRoZW4iLCJyYXdCb2R5IiwidGV4dCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJjYXRjaCIsImJvZHlUeXBlIiwiaXNCdWZmZXIiLCJsZW5ndGhIZWFkZXIiLCJib2R5U2l6ZSIsImJ5dGVMZW5ndGgiLCJhYm9ydGVkIiwiY2FsbGJhY2siLCJpbmplY3RlZFJlc3BvbnNlIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiaXRlbSIsInVuZXNjYXBlIiwiZnJvbSIsImF1dGhCYXNlNjQiLCJ0b1N0cmluZyIsInRyYW5zcG9ydCIsImdldFJlcXVlc3RUcmFuc3BvcnQiLCJkZWJ1ZyIsInRyeUNvbXByZXNzZWQiLCJjb21wcmVzcyIsImZpbmFsT3B0aW9ucyIsInJlc1N0cmVhbSIsInJlc3BvbnNlVXJsIiwiZGF0YSIsInJlZHVjZWQiLCJ0aW1lb3V0IiwiYm9keVN0cmVhbSIsInByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3NTdHJlYW0iLCJwaXBlIiwiZW5kIiwiYm9keUlzU3RyZWFtIiwiaXNIdHRwc1JlcXVlc3QiLCJ0cmFuc3BvcnRzIiwiaXNIdHRwc1Byb3h5IiwidGVzdCIsImdldEl0IiwiZW52aXJvbm1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/get-it/dist/middleware.cjs":
/*!*************************************************!*\
  !*** ./node_modules/get-it/dist/middleware.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar debugIt = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\nvar defaultOptionsValidator = __webpack_require__(/*! ./_chunks/defaultOptionsValidator-2bJolbLg.cjs */ \"(ssr)/./node_modules/get-it/dist/_chunks/defaultOptionsValidator-2bJolbLg.cjs\");\nvar isPlainObject = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/is-plain-object/dist/is-plain-object.js\");\nvar progressStream = __webpack_require__(/*! progress-stream */ \"(ssr)/./node_modules/progress-stream/index.js\");\nvar allowed = __webpack_require__(/*! is-retry-allowed */ \"(ssr)/./node_modules/is-retry-allowed/index.js\");\nfunction _interopDefaultCompat(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        default: e\n    };\n}\nvar debugIt__default = /*#__PURE__*/ _interopDefaultCompat(debugIt);\nvar progressStream__default = /*#__PURE__*/ _interopDefaultCompat(progressStream);\nvar allowed__default = /*#__PURE__*/ _interopDefaultCompat(allowed);\nconst isHttpsProto = /^https:/i;\nfunction agent(opts) {\n    const httpAgent = new http.Agent(opts);\n    const httpsAgent = new https.Agent(opts);\n    const agents = {\n        http: httpAgent,\n        https: httpsAgent\n    };\n    return {\n        finalizeOptions: (options)=>{\n            if (options.agent) {\n                return options;\n            }\n            if (options.maxRedirects > 0) {\n                return {\n                    ...options,\n                    agents\n                };\n            }\n            const isHttps = isHttpsProto.test(options.href || options.protocol);\n            return {\n                ...options,\n                agent: isHttps ? httpsAgent : httpAgent\n            };\n        }\n    };\n}\nconst leadingSlash = /^\\//;\nconst trailingSlash = /\\/$/;\nfunction base(baseUrl) {\n    const baseUri = baseUrl.replace(trailingSlash, \"\");\n    return {\n        processOptions: (options)=>{\n            if (/^https?:\\/\\//i.test(options.url)) {\n                return options;\n            }\n            const url = [\n                baseUri,\n                options.url.replace(leadingSlash, \"\")\n            ].join(\"/\");\n            return Object.assign({}, options, {\n                url\n            });\n        }\n    };\n}\nconst SENSITIVE_HEADERS = [\n    \"cookie\",\n    \"authorization\"\n];\nconst hasOwn = Object.prototype.hasOwnProperty;\nconst redactKeys = (source, redacted)=>{\n    const target = {};\n    for(const key in source){\n        if (hasOwn.call(source, key)) {\n            target[key] = redacted.indexOf(key.toLowerCase()) > -1 ? \"<redacted>\" : source[key];\n        }\n    }\n    return target;\n};\nfunction debug() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const verbose = opts.verbose;\n    const namespace = opts.namespace || \"get-it\";\n    const defaultLogger = debugIt__default.default(namespace);\n    const log = opts.log || defaultLogger;\n    const shortCircuit = log === defaultLogger && !debugIt__default.default.enabled(namespace);\n    let requestId = 0;\n    return {\n        processOptions: (options)=>{\n            options.debug = log;\n            options.requestId = options.requestId || ++requestId;\n            return options;\n        },\n        onRequest: (event)=>{\n            if (shortCircuit || !event) {\n                return event;\n            }\n            const options = event.options;\n            log(\"[%s] HTTP %s %s\", options.requestId, options.method, options.url);\n            if (verbose && options.body && typeof options.body === \"string\") {\n                log(\"[%s] Request body: %s\", options.requestId, options.body);\n            }\n            if (verbose && options.headers) {\n                const headers = opts.redactSensitiveHeaders === false ? options.headers : redactKeys(options.headers, SENSITIVE_HEADERS);\n                log(\"[%s] Request headers: %s\", options.requestId, JSON.stringify(headers, null, 2));\n            }\n            return event;\n        },\n        onResponse: (res, context)=>{\n            if (shortCircuit || !res) {\n                return res;\n            }\n            const reqId = context.options.requestId;\n            log(\"[%s] Response code: %s %s\", reqId, res.statusCode, res.statusMessage);\n            if (verbose && res.body) {\n                log(\"[%s] Response body: %s\", reqId, stringifyBody(res));\n            }\n            return res;\n        },\n        onError: (err, context)=>{\n            const reqId = context.options.requestId;\n            if (!err) {\n                log(\"[%s] Error encountered, but handled by an earlier middleware\", reqId);\n                return err;\n            }\n            log(\"[%s] ERROR: %s\", reqId, err.message);\n            return err;\n        }\n    };\n}\nfunction stringifyBody(res) {\n    const contentType = (res.headers[\"content-type\"] || \"\").toLowerCase();\n    const isJson = contentType.indexOf(\"application/json\") !== -1;\n    return isJson ? tryFormat(res.body) : res.body;\n}\nfunction tryFormat(body) {\n    try {\n        const parsed = typeof body === \"string\" ? JSON.parse(body) : body;\n        return JSON.stringify(parsed, null, 2);\n    } catch (err) {\n        return body;\n    }\n}\nfunction headers(_headers) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n        processOptions: (options)=>{\n            const existing = options.headers || {};\n            options.headers = opts.override ? Object.assign({}, existing, _headers) : Object.assign({}, _headers, existing);\n            return options;\n        }\n    };\n}\nclass HttpError extends Error {\n    constructor(res, ctx){\n        super();\n        const truncatedUrl = res.url.length > 400 ? \"\".concat(res.url.slice(0, 399), \"…\") : res.url;\n        let msg = \"\".concat(res.method, \"-request to \").concat(truncatedUrl, \" resulted in \");\n        msg += \"HTTP \".concat(res.statusCode, \" \").concat(res.statusMessage);\n        this.message = msg.trim();\n        this.response = res;\n        this.request = ctx.options;\n    }\n}\nfunction httpErrors() {\n    return {\n        onResponse: (res, ctx)=>{\n            const isHttpError = res.statusCode >= 400;\n            if (!isHttpError) {\n                return res;\n            }\n            throw new HttpError(res, ctx);\n        }\n    };\n}\nfunction injectResponse() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof opts.inject !== \"function\") {\n        throw new Error(\"`injectResponse` middleware requires a `inject` function\");\n    }\n    const inject = function inject2(prevValue, event) {\n        const response = opts.inject(event, prevValue);\n        if (!response) {\n            return prevValue;\n        }\n        const options = event.context.options;\n        return {\n            body: \"\",\n            url: options.url,\n            method: options.method,\n            headers: {},\n            statusCode: 200,\n            statusMessage: \"OK\",\n            ...response\n        };\n    };\n    return {\n        interceptRequest: inject\n    };\n}\nconst isBuffer = typeof Buffer === \"undefined\" ? ()=>false : (obj)=>Buffer.isBuffer(obj);\nconst serializeTypes = [\n    \"boolean\",\n    \"string\",\n    \"number\"\n];\nfunction jsonRequest() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body) !== -1 || Array.isArray(body) || isPlainObject.isPlainObject(body));\n            if (!shouldSerialize) {\n                return options;\n            }\n            return Object.assign({}, options, {\n                body: JSON.stringify(options.body),\n                headers: Object.assign({}, options.headers, {\n                    \"Content-Type\": \"application/json\"\n                })\n            });\n        }\n    };\n}\nfunction jsonResponse(opts) {\n    return {\n        onResponse: (response)=>{\n            const contentType = response.headers[\"content-type\"] || \"\";\n            const shouldDecode = opts && opts.force || contentType.indexOf(\"application/json\") !== -1;\n            if (!response.body || !contentType || !shouldDecode) {\n                return response;\n            }\n            return Object.assign({}, response, {\n                body: tryParse(response.body)\n            });\n        },\n        processOptions: (options)=>Object.assign({}, options, {\n                headers: Object.assign({\n                    Accept: \"application/json\"\n                }, options.headers)\n            })\n    };\n    function tryParse(body) {\n        try {\n            return JSON.parse(body);\n        } catch (err) {\n            err.message = \"Failed to parsed response body as JSON: \".concat(err.message);\n            throw err;\n        }\n    }\n}\nfunction isBrowserOptions(options) {\n    return typeof options === \"object\" && options !== null && !(\"protocol\" in options);\n}\nfunction mtls() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!config.ca) {\n        throw new Error('Required mtls option \"ca\" is missing');\n    }\n    if (!config.cert) {\n        throw new Error('Required mtls option \"cert\" is missing');\n    }\n    if (!config.key) {\n        throw new Error('Required mtls option \"key\" is missing');\n    }\n    return {\n        finalizeOptions: (options)=>{\n            if (isBrowserOptions(options)) {\n                return options;\n            }\n            const mtlsOpts = {\n                cert: config.cert,\n                key: config.key,\n                ca: config.ca\n            };\n            return Object.assign({}, options, mtlsOpts);\n        }\n    };\n}\nlet actualGlobal = {};\nif (typeof globalThis !== \"undefined\") {\n    actualGlobal = globalThis;\n} else if (false) {} else if (typeof global !== \"undefined\") {\n    actualGlobal = global;\n} else if (typeof self !== \"undefined\") {\n    actualGlobal = self;\n}\nvar global$1 = actualGlobal;\nfunction observable() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const Observable = // eslint-disable-next-line @typescript-eslint/no-explicit-any -- @TODO consider dropping checking for a global Observable since it's not on a standards track\n    opts.implementation || global$1.Observable;\n    if (!Observable) {\n        throw new Error(\"`Observable` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new Observable((observer)=>{\n                channels.error.subscribe((err)=>observer.error(err));\n                channels.progress.subscribe((event)=>observer.next(Object.assign({\n                        type: \"progress\"\n                    }, event)));\n                channels.response.subscribe((response)=>{\n                    observer.next(Object.assign({\n                        type: \"response\"\n                    }, response));\n                    observer.complete();\n                });\n                channels.request.publish(context);\n                return ()=>channels.abort.publish();\n            })\n    };\n}\nfunction normalizer(stage) {\n    return (prog)=>({\n            stage,\n            percent: prog.percentage,\n            total: prog.length,\n            loaded: prog.transferred,\n            lengthComputable: !(prog.length === 0 && prog.percentage === 0)\n        });\n}\nfunction progress() {\n    return {\n        onHeaders: (response, evt)=>{\n            const _progress = progressStream__default.default({\n                time: 16\n            });\n            const normalize = normalizer(\"download\");\n            const contentLength = response.headers[\"content-length\"];\n            const length = contentLength ? Number(contentLength) : 0;\n            if (!isNaN(length) && length > 0) {\n                _progress.setLength(length);\n            }\n            _progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n            return response.pipe(_progress);\n        },\n        onRequest: (evt)=>{\n            if (!evt.progress) {\n                return;\n            }\n            const normalize = normalizer(\"upload\");\n            evt.progress.on(\"progress\", (prog)=>evt.context.channels.progress.publish(normalize(prog)));\n        }\n    };\n}\nconst promise = function() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const PromiseImplementation = options.implementation || Promise;\n    if (!PromiseImplementation) {\n        throw new Error(\"`Promise` is not available in global scope, and no implementation was passed\");\n    }\n    return {\n        onReturn: (channels, context)=>new PromiseImplementation((resolve, reject)=>{\n                const cancel = context.options.cancelToken;\n                if (cancel) {\n                    cancel.promise.then((reason)=>{\n                        channels.abort.publish(reason);\n                        reject(reason);\n                    });\n                }\n                channels.error.subscribe(reject);\n                channels.response.subscribe((response)=>{\n                    resolve(options.onlyBody ? response.body : response);\n                });\n                setTimeout(()=>{\n                    try {\n                        channels.request.publish(context);\n                    } catch (err) {\n                        reject(err);\n                    }\n                }, 0);\n            })\n    };\n};\nclass Cancel {\n    constructor(message){\n        this.__CANCEL__ = true;\n        this.message = message;\n    }\n    toString() {\n        return \"Cancel\".concat(this.message ? \": \".concat(this.message) : \"\");\n    }\n}\nconst _CancelToken = class _CancelToken {\n    constructor(executor){\n        if (typeof executor !== \"function\") {\n            throw new TypeError(\"executor must be a function.\");\n        }\n        let resolvePromise = null;\n        this.promise = new Promise((resolve)=>{\n            resolvePromise = resolve;\n        });\n        executor((message)=>{\n            if (this.reason) {\n                return;\n            }\n            this.reason = new Cancel(message);\n            resolvePromise(this.reason);\n        });\n    }\n};\n_CancelToken.source = ()=>{\n    let cancel;\n    const token = new _CancelToken((can)=>{\n        cancel = can;\n    });\n    return {\n        token,\n        cancel\n    };\n};\nlet CancelToken = _CancelToken;\nconst isCancel = (value)=>!!(value && (value == null ? void 0 : value.__CANCEL__));\npromise.Cancel = Cancel;\npromise.CancelToken = CancelToken;\npromise.isCancel = isCancel;\nfunction proxy(_proxy) {\n    if (_proxy !== false && (!_proxy || !_proxy.host)) {\n        throw new Error(\"Proxy middleware takes an object of host, port and auth properties\");\n    }\n    return {\n        processOptions: (options)=>Object.assign({\n                proxy: _proxy\n            }, options)\n    };\n}\nvar defaultShouldRetry = (err, num, options)=>{\n    if (options.method !== \"GET\" && options.method !== \"HEAD\") {\n        return false;\n    }\n    if (err.response && err.response.statusCode) {\n        return false;\n    }\n    return allowed__default.default(err);\n};\nconst isStream = (stream)=>stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";\nvar sharedRetry = (opts)=>{\n    const maxRetries = opts.maxRetries || 5;\n    const retryDelay = opts.retryDelay || getRetryDelay;\n    const allowRetry = opts.shouldRetry;\n    return {\n        onError: (err, context)=>{\n            const options = context.options;\n            const max = options.maxRetries || maxRetries;\n            const shouldRetry = options.shouldRetry || allowRetry;\n            const attemptNumber = options.attemptNumber || 0;\n            if (isStream(options.body)) {\n                return err;\n            }\n            if (!shouldRetry(err, attemptNumber, options) || attemptNumber >= max) {\n                return err;\n            }\n            const newContext = Object.assign({}, context, {\n                options: Object.assign({}, options, {\n                    attemptNumber: attemptNumber + 1\n                })\n            });\n            setTimeout(()=>context.channels.request.publish(newContext), retryDelay(attemptNumber));\n            return null;\n        }\n    };\n};\nfunction getRetryDelay(attemptNum) {\n    return 100 * Math.pow(2, attemptNum) + Math.random() * 100;\n}\nconst retry = function() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return sharedRetry({\n        shouldRetry: defaultShouldRetry,\n        ...opts\n    });\n};\nretry.shouldRetry = defaultShouldRetry;\nfunction encode(data) {\n    const query = new URLSearchParams();\n    const nest = (name, _value)=>{\n        const value = _value instanceof Set ? Array.from(_value) : _value;\n        if (Array.isArray(value)) {\n            if (value.length) {\n                for(const index in value){\n                    nest(\"\".concat(name, \"[\").concat(index, \"]\"), value[index]);\n                }\n            } else {\n                query.append(\"\".concat(name, \"[]\"), \"\");\n            }\n        } else if (typeof value === \"object\" && value !== null) {\n            for (const [key, obj] of Object.entries(value)){\n                nest(\"\".concat(name, \"[\").concat(key, \"]\"), obj);\n            }\n        } else {\n            query.append(name, value);\n        }\n    };\n    for (const [key, value] of Object.entries(data)){\n        nest(key, value);\n    }\n    return query.toString();\n}\nfunction urlEncoded() {\n    return {\n        processOptions: (options)=>{\n            const body = options.body;\n            if (!body) {\n                return options;\n            }\n            const isStream = typeof body.pipe === \"function\";\n            const shouldSerialize = !isStream && !isBuffer(body) && isPlainObject.isPlainObject(body);\n            if (!shouldSerialize) {\n                return options;\n            }\n            return {\n                ...options,\n                body: encode(options.body),\n                headers: {\n                    ...options.headers,\n                    \"Content-Type\": \"application/x-www-form-urlencoded\"\n                }\n            };\n        }\n    };\n}\nfunction buildKeepAlive(agent) {\n    return function keepAlive() {\n        let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const ms = config.ms || 1e3;\n        const maxFree = config.maxFree || 256;\n        const agentOptions = {\n            keepAlive: true,\n            keepAliveMsecs: ms,\n            maxFreeSockets: maxFree\n        };\n        return agent(agentOptions);\n    };\n}\nconst keepAlive = buildKeepAlive(agent);\nexports.processOptions = defaultOptionsValidator.processOptions;\nexports.validateOptions = defaultOptionsValidator.validateOptions;\nexports.Cancel = Cancel;\nexports.CancelToken = CancelToken;\nexports.agent = agent;\nexports.base = base;\nexports.debug = debug;\nexports.headers = headers;\nexports.httpErrors = httpErrors;\nexports.injectResponse = injectResponse;\nexports.jsonRequest = jsonRequest;\nexports.jsonResponse = jsonResponse;\nexports.keepAlive = keepAlive;\nexports.mtls = mtls;\nexports.observable = observable;\nexports.progress = progress;\nexports.promise = promise;\nexports.proxy = proxy;\nexports.retry = retry;\nexports.urlEncoded = urlEncoded; //# sourceMappingURL=middleware.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2V0LWl0L2Rpc3QvbWlkZGxld2FyZS5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQzNDRyxPQUFPO0FBQ1QsQ0FBQyxFQUFDO0FBQ0YsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsMEJBQTBCSCxtQkFBT0EsQ0FBQztBQUN0QyxJQUFJSSxnQkFBZ0JKLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlLLGlCQUFpQkwsbUJBQU9BLENBQUM7QUFDN0IsSUFBSU0sVUFBVU4sbUJBQU9BLENBQUM7QUFDdEIsU0FBU08sc0JBQXNCQyxDQUFDO0lBQzlCLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFDeERDLFNBQVNEO0lBQ1g7QUFDRjtBQUNBLElBQUlFLG1CQUFtQixXQUFXLEdBQUVILHNCQUFzQkw7QUFDMUQsSUFBSVMsMEJBQTBCLFdBQVcsR0FBRUosc0JBQXNCRjtBQUNqRSxJQUFJTyxtQkFBbUIsV0FBVyxHQUFFTCxzQkFBc0JEO0FBQzFELE1BQU1PLGVBQWU7QUFDckIsU0FBU0MsTUFBTUMsSUFBSTtJQUNqQixNQUFNQyxZQUFZLElBQUlqQixLQUFLa0IsS0FBSyxDQUFDRjtJQUNqQyxNQUFNRyxhQUFhLElBQUlqQixNQUFNZ0IsS0FBSyxDQUFDRjtJQUNuQyxNQUFNSSxTQUFTO1FBQ2JwQixNQUFNaUI7UUFDTmYsT0FBT2lCO0lBQ1Q7SUFDQSxPQUFPO1FBQ0xFLGlCQUFpQkMsQ0FBQUE7WUFDZixJQUFJQSxRQUFRUCxLQUFLLEVBQUU7Z0JBQ2pCLE9BQU9PO1lBQ1Q7WUFDQSxJQUFJQSxRQUFRQyxZQUFZLEdBQUcsR0FBRztnQkFDNUIsT0FBTztvQkFDTCxHQUFHRCxPQUFPO29CQUNWRjtnQkFDRjtZQUNGO1lBQ0EsTUFBTUksVUFBVVYsYUFB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Q2xCdkssYUFBYSxHQUFHNkw7QUFDaEI3TCxhQUFhLEdBQUdnTjtBQUNoQmhOLGtCQUFrQixHQUFHNk4sWUFDckIsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcGF5bG9hZC1wbGF5Z3JvdW5kLy4vbm9kZV9tb2R1bGVzL2dldC1pdC9kaXN0L21pZGRsZXdhcmUuY2pzPzBlYTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciBkZWJ1Z0l0ID0gcmVxdWlyZSgnZGVidWcnKTtcbnZhciBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvciA9IHJlcXVpcmUoJy4vX2NodW5rcy9kZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci0yYkpvbGJMZy5janMnKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgcHJvZ3Jlc3NTdHJlYW0gPSByZXF1aXJlKCdwcm9ncmVzcy1zdHJlYW0nKTtcbnZhciBhbGxvd2VkID0gcmVxdWlyZSgnaXMtcmV0cnktYWxsb3dlZCcpO1xuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0KGUpIHtcbiAgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHtcbiAgICBkZWZhdWx0OiBlXG4gIH07XG59XG52YXIgZGVidWdJdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRDb21wYXQoZGVidWdJdCk7XG52YXIgcHJvZ3Jlc3NTdHJlYW1fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHByb2dyZXNzU3RyZWFtKTtcbnZhciBhbGxvd2VkX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdENvbXBhdChhbGxvd2VkKTtcbmNvbnN0IGlzSHR0cHNQcm90byA9IC9eaHR0cHM6L2k7XG5mdW5jdGlvbiBhZ2VudChvcHRzKSB7XG4gIGNvbnN0IGh0dHBBZ2VudCA9IG5ldyBodHRwLkFnZW50KG9wdHMpO1xuICBjb25zdCBodHRwc0FnZW50ID0gbmV3IGh0dHBzLkFnZW50KG9wdHMpO1xuICBjb25zdCBhZ2VudHMgPSB7XG4gICAgaHR0cDogaHR0cEFnZW50LFxuICAgIGh0dHBzOiBodHRwc0FnZW50XG4gIH07XG4gIHJldHVybiB7XG4gICAgZmluYWxpemVPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGlmIChvcHRpb25zLmFnZW50KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMubWF4UmVkaXJlY3RzID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgYWdlbnRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpc0h0dHBzID0gaXNIdHRwc1Byb3RvLnRlc3Qob3B0aW9ucy5ocmVmIHx8IG9wdGlvbnMucHJvdG9jb2wpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgYWdlbnQ6IGlzSHR0cHMgPyBodHRwc0FnZW50IDogaHR0cEFnZW50XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGxlYWRpbmdTbGFzaCA9IC9eXFwvLztcbmNvbnN0IHRyYWlsaW5nU2xhc2ggPSAvXFwvJC87XG5mdW5jdGlvbiBiYXNlKGJhc2VVcmwpIHtcbiAgY29uc3QgYmFzZVVyaSA9IGJhc2VVcmwucmVwbGFjZSh0cmFpbGluZ1NsYXNoLCBcIlwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBpZiAoL15odHRwcz86XFwvXFwvL2kudGVzdChvcHRpb25zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICBjb25zdCB1cmwgPSBbYmFzZVVyaSwgb3B0aW9ucy51cmwucmVwbGFjZShsZWFkaW5nU2xhc2gsIFwiXCIpXS5qb2luKFwiL1wiKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHVybFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgU0VOU0lUSVZFX0hFQURFUlMgPSBbXCJjb29raWVcIiwgXCJhdXRob3JpemF0aW9uXCJdO1xuY29uc3QgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IHJlZGFjdEtleXMgPSAoc291cmNlLCByZWRhY3RlZCkgPT4ge1xuICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSByZWRhY3RlZC5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+IC0xID8gXCI8cmVkYWN0ZWQ+XCIgOiBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5mdW5jdGlvbiBkZWJ1ZygpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCB2ZXJib3NlID0gb3B0cy52ZXJib3NlO1xuICBjb25zdCBuYW1lc3BhY2UgPSBvcHRzLm5hbWVzcGFjZSB8fCBcImdldC1pdFwiO1xuICBjb25zdCBkZWZhdWx0TG9nZ2VyID0gZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0KG5hbWVzcGFjZSk7XG4gIGNvbnN0IGxvZyA9IG9wdHMubG9nIHx8IGRlZmF1bHRMb2dnZXI7XG4gIGNvbnN0IHNob3J0Q2lyY3VpdCA9IGxvZyA9PT0gZGVmYXVsdExvZ2dlciAmJiAhZGVidWdJdF9fZGVmYXVsdC5kZWZhdWx0LmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgbGV0IHJlcXVlc3RJZCA9IDA7XG4gIHJldHVybiB7XG4gICAgcHJvY2Vzc09wdGlvbnM6IG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucy5kZWJ1ZyA9IGxvZztcbiAgICAgIG9wdGlvbnMucmVxdWVzdElkID0gb3B0aW9ucy5yZXF1ZXN0SWQgfHwgKytyZXF1ZXN0SWQ7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LFxuICAgIG9uUmVxdWVzdDogZXZlbnQgPT4ge1xuICAgICAgaWYgKHNob3J0Q2lyY3VpdCB8fCAhZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50Lm9wdGlvbnM7XG4gICAgICBsb2coXCJbJXNdIEhUVFAgJXMgJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVybCk7XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmJvZHkgJiYgdHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgYm9keTogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIG9wdGlvbnMuYm9keSk7XG4gICAgICB9XG4gICAgICBpZiAodmVyYm9zZSAmJiBvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG9wdHMucmVkYWN0U2Vuc2l0aXZlSGVhZGVycyA9PT0gZmFsc2UgPyBvcHRpb25zLmhlYWRlcnMgOiByZWRhY3RLZXlzKG9wdGlvbnMuaGVhZGVycywgU0VOU0lUSVZFX0hFQURFUlMpO1xuICAgICAgICBsb2coXCJbJXNdIFJlcXVlc3QgaGVhZGVyczogJXNcIiwgb3B0aW9ucy5yZXF1ZXN0SWQsIEpTT04uc3RyaW5naWZ5KGhlYWRlcnMsIG51bGwsIDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9LFxuICAgIG9uUmVzcG9uc2U6IChyZXMsIGNvbnRleHQpID0+IHtcbiAgICAgIGlmIChzaG9ydENpcmN1aXQgfHwgIXJlcykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgbG9nKFwiWyVzXSBSZXNwb25zZSBjb2RlOiAlcyAlc1wiLCByZXFJZCwgcmVzLnN0YXR1c0NvZGUsIHJlcy5zdGF0dXNNZXNzYWdlKTtcbiAgICAgIGlmICh2ZXJib3NlICYmIHJlcy5ib2R5KSB7XG4gICAgICAgIGxvZyhcIlslc10gUmVzcG9uc2UgYm9keTogJXNcIiwgcmVxSWQsIHN0cmluZ2lmeUJvZHkocmVzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgb25FcnJvcjogKGVyciwgY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgcmVxSWQgPSBjb250ZXh0Lm9wdGlvbnMucmVxdWVzdElkO1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgbG9nKFwiWyVzXSBFcnJvciBlbmNvdW50ZXJlZCwgYnV0IGhhbmRsZWQgYnkgYW4gZWFybGllciBtaWRkbGV3YXJlXCIsIHJlcUlkKTtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGxvZyhcIlslc10gRVJST1I6ICVzXCIsIHJlcUlkLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJvZHkocmVzKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gKHJlcy5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGlzSnNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpICE9PSAtMTtcbiAgcmV0dXJuIGlzSnNvbiA/IHRyeUZvcm1hdChyZXMuYm9keSkgOiByZXMuYm9keTtcbn1cbmZ1bmN0aW9uIHRyeUZvcm1hdChib2R5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkID0gdHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGJvZHkpIDogYm9keTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkLCBudWxsLCAyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhlYWRlcnMoX2hlYWRlcnMpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0cy5vdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBfaGVhZGVycykgOiBPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycywgZXhpc3RpbmcpO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9O1xufVxuY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXMsIGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgdHJ1bmNhdGVkVXJsID0gcmVzLnVybC5sZW5ndGggPiA0MDAgPyBcIlwiLmNvbmNhdChyZXMudXJsLnNsaWNlKDAsIDM5OSksIFwiXFx1MjAyNlwiKSA6IHJlcy51cmw7XG4gICAgbGV0IG1zZyA9IFwiXCIuY29uY2F0KHJlcy5tZXRob2QsIFwiLXJlcXVlc3QgdG8gXCIpLmNvbmNhdCh0cnVuY2F0ZWRVcmwsIFwiIHJlc3VsdGVkIGluIFwiKTtcbiAgICBtc2cgKz0gXCJIVFRQIFwiLmNvbmNhdChyZXMuc3RhdHVzQ29kZSwgXCIgXCIpLmNvbmNhdChyZXMuc3RhdHVzTWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbXNnLnRyaW0oKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzO1xuICAgIHRoaXMucmVxdWVzdCA9IGN0eC5vcHRpb25zO1xuICB9XG59XG5mdW5jdGlvbiBodHRwRXJyb3JzKCkge1xuICByZXR1cm4ge1xuICAgIG9uUmVzcG9uc2U6IChyZXMsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgaXNIdHRwRXJyb3IgPSByZXMuc3RhdHVzQ29kZSA+PSA0MDA7XG4gICAgICBpZiAoIWlzSHR0cEVycm9yKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgSHR0cEVycm9yKHJlcywgY3R4KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpbmplY3RSZXNwb25zZSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBpZiAodHlwZW9mIG9wdHMuaW5qZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgaW5qZWN0UmVzcG9uc2VgIG1pZGRsZXdhcmUgcmVxdWlyZXMgYSBgaW5qZWN0YCBmdW5jdGlvblwiKTtcbiAgfVxuICBjb25zdCBpbmplY3QgPSBmdW5jdGlvbiBpbmplY3QyKHByZXZWYWx1ZSwgZXZlbnQpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IG9wdHMuaW5qZWN0KGV2ZW50LCBwcmV2VmFsdWUpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC5jb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvZHk6IFwiXCIsXG4gICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgLi4ucmVzcG9uc2VcbiAgICB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGludGVyY2VwdFJlcXVlc3Q6IGluamVjdFxuICB9O1xufVxuY29uc3QgaXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSBcInVuZGVmaW5lZFwiID8gKCkgPT4gZmFsc2UgOiBvYmogPT4gQnVmZmVyLmlzQnVmZmVyKG9iaik7XG5jb25zdCBzZXJpYWxpemVUeXBlcyA9IFtcImJvb2xlYW5cIiwgXCJzdHJpbmdcIiwgXCJudW1iZXJcIl07XG5mdW5jdGlvbiBqc29uUmVxdWVzdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBjb25zdCBzaG91bGRTZXJpYWxpemUgPSAhaXNTdHJlYW0gJiYgIWlzQnVmZmVyKGJvZHkpICYmIChzZXJpYWxpemVUeXBlcy5pbmRleE9mKHR5cGVvZiBib2R5KSAhPT0gLTEgfHwgQXJyYXkuaXNBcnJheShib2R5KSB8fCBpc1BsYWluT2JqZWN0LmlzUGxhaW5PYmplY3QoYm9keSkpO1xuICAgICAgaWYgKCFzaG91bGRTZXJpYWxpemUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShvcHRpb25zLmJvZHkpLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24ganNvblJlc3BvbnNlKG9wdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvblJlc3BvbnNlOiByZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgXCJcIjtcbiAgICAgIGNvbnN0IHNob3VsZERlY29kZSA9IG9wdHMgJiYgb3B0cy5mb3JjZSB8fCBjb250ZW50VHlwZS5pbmRleE9mKFwiYXBwbGljYXRpb24vanNvblwiKSAhPT0gLTE7XG4gICAgICBpZiAoIXJlc3BvbnNlLmJvZHkgfHwgIWNvbnRlbnRUeXBlIHx8ICFzaG91bGREZWNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlLCB7XG4gICAgICAgIGJvZHk6IHRyeVBhcnNlKHJlc3BvbnNlLmJvZHkpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LCBvcHRpb25zLmhlYWRlcnMpXG4gICAgfSlcbiAgfTtcbiAgZnVuY3Rpb24gdHJ5UGFyc2UoYm9keSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShib2R5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gXCJGYWlsZWQgdG8gcGFyc2VkIHJlc3BvbnNlIGJvZHkgYXMgSlNPTjogXCIuY29uY2F0KGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQnJvd3Nlck9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucyAhPT0gbnVsbCAmJiAhKFwicHJvdG9jb2xcIiBpbiBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIG10bHMoKSB7XG4gIGxldCBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBpZiAoIWNvbmZpZy5jYSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgbXRscyBvcHRpb24gXCJjYVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICBpZiAoIWNvbmZpZy5jZXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImNlcnRcIiBpcyBtaXNzaW5nJyk7XG4gIH1cbiAgaWYgKCFjb25maWcua2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBtdGxzIG9wdGlvbiBcImtleVwiIGlzIG1pc3NpbmcnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsaXplT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBpZiAoaXNCcm93c2VyT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG10bHNPcHRzID0ge1xuICAgICAgICBjZXJ0OiBjb25maWcuY2VydCxcbiAgICAgICAga2V5OiBjb25maWcua2V5LFxuICAgICAgICBjYTogY29uZmlnLmNhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIG10bHNPcHRzKTtcbiAgICB9XG4gIH07XG59XG5sZXQgYWN0dWFsR2xvYmFsID0ge307XG5pZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gZ2xvYmFsVGhpcztcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgYWN0dWFsR2xvYmFsID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBhY3R1YWxHbG9iYWwgPSBzZWxmO1xufVxudmFyIGdsb2JhbCQxID0gYWN0dWFsR2xvYmFsO1xuZnVuY3Rpb24gb2JzZXJ2YWJsZSgpIHtcbiAgbGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBjb25zdCBPYnNlcnZhYmxlID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgLS0gQFRPRE8gY29uc2lkZXIgZHJvcHBpbmcgY2hlY2tpbmcgZm9yIGEgZ2xvYmFsIE9ic2VydmFibGUgc2luY2UgaXQncyBub3Qgb24gYSBzdGFuZGFyZHMgdHJhY2tcbiAgb3B0cy5pbXBsZW1lbnRhdGlvbiB8fCBnbG9iYWwkMS5PYnNlcnZhYmxlO1xuICBpZiAoIU9ic2VydmFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgT2JzZXJ2YWJsZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb25SZXR1cm46IChjaGFubmVscywgY29udGV4dCkgPT4gbmV3IE9ic2VydmFibGUob2JzZXJ2ZXIgPT4ge1xuICAgICAgY2hhbm5lbHMuZXJyb3Iuc3Vic2NyaWJlKGVyciA9PiBvYnNlcnZlci5lcnJvcihlcnIpKTtcbiAgICAgIGNoYW5uZWxzLnByb2dyZXNzLnN1YnNjcmliZShldmVudCA9PiBvYnNlcnZlci5uZXh0KE9iamVjdC5hc3NpZ24oe1xuICAgICAgICB0eXBlOiBcInByb2dyZXNzXCJcbiAgICAgIH0sIGV2ZW50KSkpO1xuICAgICAgY2hhbm5lbHMucmVzcG9uc2Uuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICB0eXBlOiBcInJlc3BvbnNlXCJcbiAgICAgICAgfSwgcmVzcG9uc2UpKTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbm5lbHMucmVxdWVzdC5wdWJsaXNoKGNvbnRleHQpO1xuICAgICAgcmV0dXJuICgpID0+IGNoYW5uZWxzLmFib3J0LnB1Ymxpc2goKTtcbiAgICB9KVxuICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplcihzdGFnZSkge1xuICByZXR1cm4gcHJvZyA9PiAoe1xuICAgIHN0YWdlLFxuICAgIHBlcmNlbnQ6IHByb2cucGVyY2VudGFnZSxcbiAgICB0b3RhbDogcHJvZy5sZW5ndGgsXG4gICAgbG9hZGVkOiBwcm9nLnRyYW5zZmVycmVkLFxuICAgIGxlbmd0aENvbXB1dGFibGU6ICEocHJvZy5sZW5ndGggPT09IDAgJiYgcHJvZy5wZXJjZW50YWdlID09PSAwKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHByb2dyZXNzKCkge1xuICByZXR1cm4ge1xuICAgIG9uSGVhZGVyczogKHJlc3BvbnNlLCBldnQpID0+IHtcbiAgICAgIGNvbnN0IF9wcm9ncmVzcyA9IHByb2dyZXNzU3RyZWFtX19kZWZhdWx0LmRlZmF1bHQoe1xuICAgICAgICB0aW1lOiAxNlxuICAgICAgfSk7XG4gICAgICBjb25zdCBub3JtYWxpemUgPSBub3JtYWxpemVyKFwiZG93bmxvYWRcIik7XG4gICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gY29udGVudExlbmd0aCA/IE51bWJlcihjb250ZW50TGVuZ3RoKSA6IDA7XG4gICAgICBpZiAoIWlzTmFOKGxlbmd0aCkgJiYgbGVuZ3RoID4gMCkge1xuICAgICAgICBfcHJvZ3Jlc3Muc2V0TGVuZ3RoKGxlbmd0aCk7XG4gICAgICB9XG4gICAgICBfcHJvZ3Jlc3Mub24oXCJwcm9ncmVzc1wiLCBwcm9nID0+IGV2dC5jb250ZXh0LmNoYW5uZWxzLnByb2dyZXNzLnB1Ymxpc2gobm9ybWFsaXplKHByb2cpKSk7XG4gICAgICByZXR1cm4gcmVzcG9uc2UucGlwZShfcHJvZ3Jlc3MpO1xuICAgIH0sXG4gICAgb25SZXF1ZXN0OiBldnQgPT4ge1xuICAgICAgaWYgKCFldnQucHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9ybWFsaXplID0gbm9ybWFsaXplcihcInVwbG9hZFwiKTtcbiAgICAgIGV2dC5wcm9ncmVzcy5vbihcInByb2dyZXNzXCIsIHByb2cgPT4gZXZ0LmNvbnRleHQuY2hhbm5lbHMucHJvZ3Jlc3MucHVibGlzaChub3JtYWxpemUocHJvZykpKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBwcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIGNvbnN0IFByb21pc2VJbXBsZW1lbnRhdGlvbiA9IG9wdGlvbnMuaW1wbGVtZW50YXRpb24gfHwgUHJvbWlzZTtcbiAgaWYgKCFQcm9taXNlSW1wbGVtZW50YXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgUHJvbWlzZWAgaXMgbm90IGF2YWlsYWJsZSBpbiBnbG9iYWwgc2NvcGUsIGFuZCBubyBpbXBsZW1lbnRhdGlvbiB3YXMgcGFzc2VkXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgb25SZXR1cm46IChjaGFubmVscywgY29udGV4dCkgPT4gbmV3IFByb21pc2VJbXBsZW1lbnRhdGlvbigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYW5jZWwgPSBjb250ZXh0Lm9wdGlvbnMuY2FuY2VsVG9rZW47XG4gICAgICBpZiAoY2FuY2VsKSB7XG4gICAgICAgIGNhbmNlbC5wcm9taXNlLnRoZW4ocmVhc29uID0+IHtcbiAgICAgICAgICBjaGFubmVscy5hYm9ydC5wdWJsaXNoKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2hhbm5lbHMuZXJyb3Iuc3Vic2NyaWJlKHJlamVjdCk7XG4gICAgICBjaGFubmVscy5yZXNwb25zZS5zdWJzY3JpYmUocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXNvbHZlKG9wdGlvbnMub25seUJvZHkgPyByZXNwb25zZS5ib2R5IDogcmVzcG9uc2UpO1xuICAgICAgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2goY29udGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9KVxuICB9O1xufTtcbmNsYXNzIENhbmNlbCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9fQ0FOQ0VMX18gPSB0cnVlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwiQ2FuY2VsXCIuY29uY2F0KHRoaXMubWVzc2FnZSA/IFwiOiBcIi5jb25jYXQodGhpcy5tZXNzYWdlKSA6IFwiXCIpO1xuICB9XG59XG5jb25zdCBfQ2FuY2VsVG9rZW4gPSBjbGFzcyBfQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuICAgIGxldCByZXNvbHZlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgZXhlY3V0b3IobWVzc2FnZSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodGhpcy5yZWFzb24pO1xuICAgIH0pO1xuICB9XG59O1xuX0NhbmNlbFRva2VuLnNvdXJjZSA9ICgpID0+IHtcbiAgbGV0IGNhbmNlbDtcbiAgY29uc3QgdG9rZW4gPSBuZXcgX0NhbmNlbFRva2VuKGNhbiA9PiB7XG4gICAgY2FuY2VsID0gY2FuO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbixcbiAgICBjYW5jZWxcbiAgfTtcbn07XG5sZXQgQ2FuY2VsVG9rZW4gPSBfQ2FuY2VsVG9rZW47XG5jb25zdCBpc0NhbmNlbCA9IHZhbHVlID0+ICEhKHZhbHVlICYmICh2YWx1ZSA9PSBudWxsID8gdm9pZCAwIDogdmFsdWUuX19DQU5DRUxfXykpO1xucHJvbWlzZS5DYW5jZWwgPSBDYW5jZWw7XG5wcm9taXNlLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5wcm9taXNlLmlzQ2FuY2VsID0gaXNDYW5jZWw7XG5mdW5jdGlvbiBwcm94eShfcHJveHkpIHtcbiAgaWYgKF9wcm94eSAhPT0gZmFsc2UgJiYgKCFfcHJveHkgfHwgIV9wcm94eS5ob3N0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IG1pZGRsZXdhcmUgdGFrZXMgYW4gb2JqZWN0IG9mIGhvc3QsIHBvcnQgYW5kIGF1dGggcHJvcGVydGllc1wiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NPcHRpb25zOiBvcHRpb25zID0+IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcHJveHk6IF9wcm94eVxuICAgIH0sIG9wdGlvbnMpXG4gIH07XG59XG52YXIgZGVmYXVsdFNob3VsZFJldHJ5ID0gKGVyciwgbnVtLCBvcHRpb25zKSA9PiB7XG4gIGlmIChvcHRpb25zLm1ldGhvZCAhPT0gXCJHRVRcIiAmJiBvcHRpb25zLm1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVyci5yZXNwb25zZSAmJiBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYWxsb3dlZF9fZGVmYXVsdC5kZWZhdWx0KGVycik7XG59O1xuY29uc3QgaXNTdHJlYW0gPSBzdHJlYW0gPT4gc3RyZWFtICE9PSBudWxsICYmIHR5cGVvZiBzdHJlYW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHN0cmVhbS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG52YXIgc2hhcmVkUmV0cnkgPSBvcHRzID0+IHtcbiAgY29uc3QgbWF4UmV0cmllcyA9IG9wdHMubWF4UmV0cmllcyB8fCA1O1xuICBjb25zdCByZXRyeURlbGF5ID0gb3B0cy5yZXRyeURlbGF5IHx8IGdldFJldHJ5RGVsYXk7XG4gIGNvbnN0IGFsbG93UmV0cnkgPSBvcHRzLnNob3VsZFJldHJ5O1xuICByZXR1cm4ge1xuICAgIG9uRXJyb3I6IChlcnIsIGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICBjb25zdCBtYXggPSBvcHRpb25zLm1heFJldHJpZXMgfHwgbWF4UmV0cmllcztcbiAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gb3B0aW9ucy5zaG91bGRSZXRyeSB8fCBhbGxvd1JldHJ5O1xuICAgICAgY29uc3QgYXR0ZW1wdE51bWJlciA9IG9wdGlvbnMuYXR0ZW1wdE51bWJlciB8fCAwO1xuICAgICAgaWYgKGlzU3RyZWFtKG9wdGlvbnMuYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyLCBhdHRlbXB0TnVtYmVyLCBvcHRpb25zKSB8fCBhdHRlbXB0TnVtYmVyID49IG1heCkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQsIHtcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgIGF0dGVtcHROdW1iZXI6IGF0dGVtcHROdW1iZXIgKyAxXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gY29udGV4dC5jaGFubmVscy5yZXF1ZXN0LnB1Ymxpc2gobmV3Q29udGV4dCksIHJldHJ5RGVsYXkoYXR0ZW1wdE51bWJlcikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJldHJ5RGVsYXkoYXR0ZW1wdE51bSkge1xuICByZXR1cm4gMTAwICogTWF0aC5wb3coMiwgYXR0ZW1wdE51bSkgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xufVxuY29uc3QgcmV0cnkgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIHNoYXJlZFJldHJ5KHtcbiAgICBzaG91bGRSZXRyeTogZGVmYXVsdFNob3VsZFJldHJ5LFxuICAgIC4uLm9wdHNcbiAgfSk7XG59O1xucmV0cnkuc2hvdWxkUmV0cnkgPSBkZWZhdWx0U2hvdWxkUmV0cnk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgY29uc3QgbmVzdCA9IChuYW1lLCBfdmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IF92YWx1ZSBpbnN0YW5jZW9mIFNldCA/IEFycmF5LmZyb20oX3ZhbHVlKSA6IF92YWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbmRleCBpbiB2YWx1ZSkge1xuICAgICAgICAgIG5lc3QoXCJcIi5jb25jYXQobmFtZSwgXCJbXCIpLmNvbmNhdChpbmRleCwgXCJdXCIpLCB2YWx1ZVtpbmRleF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeS5hcHBlbmQoXCJcIi5jb25jYXQobmFtZSwgXCJbXVwiKSwgXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgb2JqXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgbmVzdChcIlwiLmNvbmNhdChuYW1lLCBcIltcIikuY29uY2F0KGtleSwgXCJdXCIpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeS5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICBuZXN0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBxdWVyeS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdXJsRW5jb2RlZCgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9jZXNzT3B0aW9uczogb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNTdHJlYW0gPSB0eXBlb2YgYm9keS5waXBlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICBjb25zdCBzaG91bGRTZXJpYWxpemUgPSAhaXNTdHJlYW0gJiYgIWlzQnVmZmVyKGJvZHkpICYmIGlzUGxhaW5PYmplY3QuaXNQbGFpbk9iamVjdChib2R5KTtcbiAgICAgIGlmICghc2hvdWxkU2VyaWFsaXplKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgYm9keTogZW5jb2RlKG9wdGlvbnMuYm9keSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkS2VlcEFsaXZlKGFnZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiBrZWVwQWxpdmUoKSB7XG4gICAgbGV0IGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgbXMgPSBjb25maWcubXMgfHwgMWUzO1xuICAgIGNvbnN0IG1heEZyZWUgPSBjb25maWcubWF4RnJlZSB8fCAyNTY7XG4gICAgY29uc3QgYWdlbnRPcHRpb25zID0ge1xuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAga2VlcEFsaXZlTXNlY3M6IG1zLFxuICAgICAgbWF4RnJlZVNvY2tldHM6IG1heEZyZWVcbiAgICB9O1xuICAgIHJldHVybiBhZ2VudChhZ2VudE9wdGlvbnMpO1xuICB9O1xufVxuY29uc3Qga2VlcEFsaXZlID0gYnVpbGRLZWVwQWxpdmUoYWdlbnQpO1xuZXhwb3J0cy5wcm9jZXNzT3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zVmFsaWRhdG9yLnByb2Nlc3NPcHRpb25zO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbnMgPSBkZWZhdWx0T3B0aW9uc1ZhbGlkYXRvci52YWxpZGF0ZU9wdGlvbnM7XG5leHBvcnRzLkNhbmNlbCA9IENhbmNlbDtcbmV4cG9ydHMuQ2FuY2VsVG9rZW4gPSBDYW5jZWxUb2tlbjtcbmV4cG9ydHMuYWdlbnQgPSBhZ2VudDtcbmV4cG9ydHMuYmFzZSA9IGJhc2U7XG5leHBvcnRzLmRlYnVnID0gZGVidWc7XG5leHBvcnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuZXhwb3J0cy5odHRwRXJyb3JzID0gaHR0cEVycm9ycztcbmV4cG9ydHMuaW5qZWN0UmVzcG9uc2UgPSBpbmplY3RSZXNwb25zZTtcbmV4cG9ydHMuanNvblJlcXVlc3QgPSBqc29uUmVxdWVzdDtcbmV4cG9ydHMuanNvblJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuZXhwb3J0cy5rZWVwQWxpdmUgPSBrZWVwQWxpdmU7XG5leHBvcnRzLm10bHMgPSBtdGxzO1xuZXhwb3J0cy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmV4cG9ydHMucHJvbWlzZSA9IHByb21pc2U7XG5leHBvcnRzLnByb3h5ID0gcHJveHk7XG5leHBvcnRzLnJldHJ5ID0gcmV0cnk7XG5leHBvcnRzLnVybEVuY29kZWQgPSB1cmxFbmNvZGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWlkZGxld2FyZS5janMubWFwXG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJodHRwIiwicmVxdWlyZSIsImh0dHBzIiwiZGVidWdJdCIsImRlZmF1bHRPcHRpb25zVmFsaWRhdG9yIiwiaXNQbGFpbk9iamVjdCIsInByb2dyZXNzU3RyZWFtIiwiYWxsb3dlZCIsIl9pbnRlcm9wRGVmYXVsdENvbXBhdCIsImUiLCJkZWZhdWx0IiwiZGVidWdJdF9fZGVmYXVsdCIsInByb2dyZXNzU3RyZWFtX19kZWZhdWx0IiwiYWxsb3dlZF9fZGVmYXVsdCIsImlzSHR0cHNQcm90byIsImFnZW50Iiwib3B0cyIsImh0dHBBZ2VudCIsIkFnZW50IiwiaHR0cHNBZ2VudCIsImFnZW50cyIsImZpbmFsaXplT3B0aW9ucyIsIm9wdGlvbnMiLCJtYXhSZWRpcmVjdHMiLCJpc0h0dHBzIiwidGVzdCIsImhyZWYiLCJwcm90b2NvbCIsImxlYWRpbmdTbGFzaCIsInRyYWlsaW5nU2xhc2giLCJiYXNlIiwiYmFzZVVybCIsImJhc2VVcmkiLCJyZXBsYWNlIiwicHJvY2Vzc09wdGlvbnMiLCJ1cmwiLCJqb2luIiwiYXNzaWduIiwiU0VOU0lUSVZFX0hFQURFUlMiLCJoYXNPd24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlZGFjdEtleXMiLCJzb3VyY2UiLCJyZWRhY3RlZCIsInRhcmdldCIsImtleSIsImNhbGwiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJkZWJ1ZyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInZlcmJvc2UiLCJuYW1lc3BhY2UiLCJkZWZhdWx0TG9nZ2VyIiwibG9nIiwic2hvcnRDaXJjdWl0IiwiZW5hYmxlZCIsInJlcXVlc3RJZCIsIm9uUmVxdWVzdCIsImV2ZW50IiwibWV0aG9kIiwiYm9keSIsImhlYWRlcnMiLCJyZWRhY3RTZW5zaXRpdmVIZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9uUmVzcG9uc2UiLCJyZXMiLCJjb250ZXh0IiwicmVxSWQiLCJzdGF0dXNDb2RlIiwic3RhdHVzTWVzc2FnZSIsInN0cmluZ2lmeUJvZHkiLCJvbkVycm9yIiwiZXJyIiwibWVzc2FnZSIsImNvbnRlbnRUeXBlIiwiaXNKc29uIiwidHJ5Rm9ybWF0IiwicGFyc2VkIiwicGFyc2UiLCJfaGVhZGVycyIsImV4aXN0aW5nIiwib3ZlcnJpZGUiLCJIdHRwRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY3R4IiwidHJ1bmNhdGVkVXJsIiwiY29uY2F0Iiwic2xpY2UiLCJtc2ciLCJ0cmltIiwicmVzcG9uc2UiLCJyZXF1ZXN0IiwiaHR0cEVycm9ycyIsImlzSHR0cEVycm9yIiwiaW5qZWN0UmVzcG9uc2UiLCJpbmplY3QiLCJpbmplY3QyIiwicHJldlZhbHVlIiwiaW50ZXJjZXB0UmVxdWVzdCIsImlzQnVmZmVyIiwiQnVmZmVyIiwib2JqIiwic2VyaWFsaXplVHlwZXMiLCJqc29uUmVxdWVzdCIsImlzU3RyZWFtIiwicGlwZSIsInNob3VsZFNlcmlhbGl6ZSIsIkFycmF5IiwiaXNBcnJheSIsImpzb25SZXNwb25zZSIsInNob3VsZERlY29kZSIsImZvcmNlIiwidHJ5UGFyc2UiLCJBY2NlcHQiLCJpc0Jyb3dzZXJPcHRpb25zIiwibXRscyIsImNvbmZpZyIsImNhIiwiY2VydCIsIm10bHNPcHRzIiwiYWN0dWFsR2xvYmFsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnbG9iYWwkMSIsIm9ic2VydmFibGUiLCJPYnNlcnZhYmxlIiwiaW1wbGVtZW50YXRpb24iLCJvblJldHVybiIsImNoYW5uZWxzIiwib2JzZXJ2ZXIiLCJlcnJvciIsInN1YnNjcmliZSIsInByb2dyZXNzIiwibmV4dCIsInR5cGUiLCJjb21wbGV0ZSIsInB1Ymxpc2giLCJhYm9ydCIsIm5vcm1hbGl6ZXIiLCJzdGFnZSIsInByb2ciLCJwZXJjZW50IiwicGVyY2VudGFnZSIsInRvdGFsIiwibG9hZGVkIiwidHJhbnNmZXJyZWQiLCJsZW5ndGhDb21wdXRhYmxlIiwib25IZWFkZXJzIiwiZXZ0IiwiX3Byb2dyZXNzIiwidGltZSIsIm5vcm1hbGl6ZSIsImNvbnRlbnRMZW5ndGgiLCJOdW1iZXIiLCJpc05hTiIsInNldExlbmd0aCIsIm9uIiwicHJvbWlzZSIsIlByb21pc2VJbXBsZW1lbnRhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FuY2VsIiwiY2FuY2VsVG9rZW4iLCJ0aGVuIiwicmVhc29uIiwib25seUJvZHkiLCJzZXRUaW1lb3V0IiwiQ2FuY2VsIiwiX19DQU5DRUxfXyIsInRvU3RyaW5nIiwiX0NhbmNlbFRva2VuIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInRva2VuIiwiY2FuIiwiQ2FuY2VsVG9rZW4iLCJpc0NhbmNlbCIsInByb3h5IiwiX3Byb3h5IiwiaG9zdCIsImRlZmF1bHRTaG91bGRSZXRyeSIsIm51bSIsInN0cmVhbSIsInNoYXJlZFJldHJ5IiwibWF4UmV0cmllcyIsInJldHJ5RGVsYXkiLCJnZXRSZXRyeURlbGF5IiwiYWxsb3dSZXRyeSIsInNob3VsZFJldHJ5IiwibWF4IiwiYXR0ZW1wdE51bWJlciIsIm5ld0NvbnRleHQiLCJhdHRlbXB0TnVtIiwiTWF0aCIsInBvdyIsInJhbmRvbSIsInJldHJ5IiwiZW5jb2RlIiwiZGF0YSIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwibmVzdCIsIm5hbWUiLCJfdmFsdWUiLCJTZXQiLCJmcm9tIiwiaW5kZXgiLCJhcHBlbmQiLCJlbnRyaWVzIiwidXJsRW5jb2RlZCIsImJ1aWxkS2VlcEFsaXZlIiwia2VlcEFsaXZlIiwibXMiLCJtYXhGcmVlIiwiYWdlbnRPcHRpb25zIiwia2VlcEFsaXZlTXNlY3MiLCJtYXhGcmVlU29ja2V0cyIsInZhbGlkYXRlT3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/get-it/dist/middleware.cjs\n");

/***/ })

};
;